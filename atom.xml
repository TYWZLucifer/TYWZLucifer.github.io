<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pluto</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-28T11:03:44.556Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>pluto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11月做题记录</title>
    <link href="http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-01T04:45:34.000Z</published>
    <updated>2020-10-28T11:03:44.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11月做题记录"><a href="#11月做题记录" class="headerlink" title="11月做题记录"></a>11月做题记录</h1><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p>dp搜索每一个nums[i]之前的项，赋给其能给的最大值，所以优化时间复杂度可以使用二分</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// var lengthOfLIS = function(nums) &#123;</span><span class="hljs-comment">//     dp = [1];</span><span class="hljs-comment">//     for(var i=1;dp[i]=1,i&lt;nums.length;i++) &#123;</span><span class="hljs-comment">//         for(var j=0;j&lt;i;j++) &#123;</span><span class="hljs-comment">//             nums[i]&gt;nums[j] &amp;&amp; (dp[i]=Math.max(dp[j]+1,dp[i]));</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return nums.length&lt;2?nums.length:Math.max(...dp);</span><span class="hljs-comment">// &#125;;</span><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = nums.length;    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        <span class="hljs-keyword">if</span>(nums[i]&gt;tail[end]) &#123;            end++;            tail[end] = nums[i];        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">let</span> right = end;            <span class="hljs-keyword">while</span>(left&lt;right) &#123;                <span class="hljs-keyword">let</span> mid = left + <span class="hljs-built_in">parseInt</span>((right-left)/<span class="hljs-number">2</span>);                <span class="hljs-keyword">if</span>(tail[mid] &lt; nums[i]) left = mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right = mid;            &#125;            tail[left] = nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11月做题记录&quot;&gt;&lt;a href=&quot;#11月做题记录&quot; class=&quot;headerlink&quot; title=&quot;11月做题记录&quot;&gt;&lt;/a&gt;11月做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长上升子序列&quot;&gt;&lt;a href=&quot;#最长上升子序列&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
  </entry>
  
  <entry>
    <title>9月做题记录</title>
    <link href="http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-01T09:45:34.000Z</published>
    <updated>2020-09-28T03:41:08.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9月做题记录"><a href="#9月做题记录" class="headerlink" title="9月做题记录"></a>9月做题记录</h1><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[][] mark;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] board;    <span class="hljs-keyword">public</span> String word;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        m = board.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        n = board[<span class="hljs-number">0</span>].length;        mark = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">this</span>.word = word;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(dfs(i,j,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start==word.length()-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> board[i][j] == word.charAt(start);        <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(start)) &#123;            mark[i][j] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++) &#123;                <span class="hljs-keyword">int</span> newx = i+direction[k][<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newy = j+direction[k][<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span>(inArea(newx,newy) &amp;&amp; !mark[newx][newy]) &#123;                    <span class="hljs-keyword">if</span>(dfs(newx,newy,start+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;            mark[i][j] = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;n;    &#125;&#125;</code></pre></div><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> val = node.val;        <span class="hljs-keyword">if</span>(lower!=<span class="hljs-keyword">null</span> &amp;&amp; val&lt;=lower) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(upper!=<span class="hljs-keyword">null</span> &amp;&amp; val&gt;=upper) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.left,lower,val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.right,val,upper)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p>画个图，数量最多的任务排成一列，每个占n个位置的一行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:tasks) map[c-<span class="hljs-string">'A'</span>]++;        Arrays.sort(map);        <span class="hljs-keyword">int</span> max_val=map[<span class="hljs-number">25</span>]-<span class="hljs-number">1</span>, pool=max_val*n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">24</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; map[i]&gt;<span class="hljs-number">0</span>;i--) pool -= Math.min(max_val,map[i]);        <span class="hljs-keyword">return</span> pool&gt;<span class="hljs-number">0</span>?pool+tasks.length:tasks.length;    &#125;&#125;</code></pre></div><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p>动态规划，<code>dp[i][j]</code>为前i个数可以组成和为j的方法的个数，则有<code>dp[i][j]=dp[i-1][j-num[i]]+dp[i-1][j+num[i]]</code>，或者用递归也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];        dp[nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] = <span class="hljs-number">1</span>;        dp[-nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] += <span class="hljs-number">1</span>;        <span class="hljs-comment">// 因为nums[0]可能是0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=-<span class="hljs-number">1000</span>;sum&lt;=<span class="hljs-number">1000</span>;sum++) &#123;                <span class="hljs-keyword">if</span>(dp[sum+<span class="hljs-number">1000</span>]&gt;<span class="hljs-number">0</span>) &#123;                    next[sum+<span class="hljs-number">1000</span>+nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                    next[sum+<span class="hljs-number">1000</span>-nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                &#125;            &#125;            dp = next;        &#125;        <span class="hljs-keyword">return</span> S&gt;<span class="hljs-number">1000</span>?<span class="hljs-number">0</span>:dp[S+<span class="hljs-number">1000</span>];    &#125;&#125;</code></pre></div><h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p>前K问题一般考虑快排，但我是直接统计次数然后排序。。暴力解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">int</span> value = map.getOrDefault(num,<span class="hljs-number">0</span>).intValue()+<span class="hljs-number">1</span>;            map.put(num,value);        &#125;        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());        list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;              <span class="hljs-keyword">return</span> o2.getValue().compareTo(o1.getValue());          &#125;        &#125;);        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) res[i]=list.get(i).getKey();        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p>总是忘了怎么写</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> check(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> &amp;&amp; q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> || q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);    &#125;&#125;</code></pre></div><h3 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p>不能使用滑动窗口的原因是数组内可能有负值，无法确定右移多少位置会使新加入的值的和为0</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;            pre += nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(pre-k)) res += map.get(pre-k);            map.put(pre,map.getOrDefault(pre,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p>归并排序，没太懂时间复杂度和空间复杂度如何符合要求</p><div class="hljs"><pre><code class="hljs vbscript">/** * Definition <span class="hljs-keyword">for</span> singly-linked list. * <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123; *     <span class="hljs-built_in">int</span> val; *     ListNode <span class="hljs-keyword">next</span>; *     ListNode(<span class="hljs-built_in">int</span> x) &#123; val = x; &#125; * &#125; */<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> ListNode sortList(ListNode head) &#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span>==<span class="hljs-literal">null</span>) return head;        ListNode slow=head,fast=head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>) &#123;            slow = slow.<span class="hljs-keyword">next</span>;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        ListNode tmp = slow.<span class="hljs-keyword">next</span>;        slow.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;        ListNode <span class="hljs-built_in">left</span> = sortList(head);        ListNode <span class="hljs-built_in">right</span> = sortList(tmp);        ListNode h = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode res = h;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">left</span>!=<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">right</span>!=<span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &lt;= <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>;                <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>.<span class="hljs-keyword">next</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &gt; <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">right</span>;                <span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>.<span class="hljs-keyword">next</span>;            &#125;            h = h.<span class="hljs-keyword">next</span>;        &#125;        h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>==<span class="hljs-literal">null</span>?<span class="hljs-built_in">right</span>:<span class="hljs-built_in">left</span>;        return res.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre></div><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p>开始想用队列做，发现题解这TM也能动态规划。。</p><p>把数组分成K大小的块，从左往右定义一个数组存放每个块起点到当前位置的最大值，再从右往左做相同操作，这样当一个窗口包括了两个块的部分区域时，这个窗口内最大值一定是右边块的从左往右数组的最右值，与左边块的从右往左数组的最左值之间的最大值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span>(n*k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        left[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        right[n-<span class="hljs-number">1</span>] = nums[n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i%k==<span class="hljs-number">0</span>) left[i] = nums[i];            <span class="hljs-keyword">else</span> left[i] = Math.max(left[i-<span class="hljs-number">1</span>],nums[i]);            <span class="hljs-keyword">int</span> j = n-i-<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>((j+<span class="hljs-number">1</span>)%k==<span class="hljs-number">0</span>) right[j] = nums[j];            <span class="hljs-keyword">else</span> right[j] = Math.max(right[j+<span class="hljs-number">1</span>],nums[j]);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-k+<span class="hljs-number">1</span>;i++)            res[i] = Math.max(right[i],left[i+k-<span class="hljs-number">1</span>]);                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p>找个好起点移动就行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=matrix.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> n=matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;m &amp;&amp; j&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(target == matrix[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(target &lt; matrix[i][j]) j--;            <span class="hljs-keyword">else</span> i++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p>自己做是克隆数组后排序，从前往后和从后往前分别找无序数组的起点和终点</p><p>官解的思路是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界，所以从头遍历找降序的最小值，从尾遍历找升序的最大值，然后再两次这样的遍历分别找二者的正确位置，这个区间就是res</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] help = nums.clone();        Arrays.sort(help);        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; nums[i]==help[i]) i++;        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j]==help[j]) j--;        <span class="hljs-keyword">return</span> j-i+<span class="hljs-number">1</span>;     &#125;&#125;</code></pre></div><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><ol><li>先按身高降序排序，相同身高按k升序排序，经过此次排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序。请记住这两点，敲黑板</li><li>创建一个集合，这个集合的每个元素是一个一维数组，也就是我们二维数组的一行。</li><li>以行为单位遍历排好序的people[][]数组，假设每行数据是p[], 把每行元素插入到集合的索引为p[1]的位置，</li><li>把集合中的数据转换为一个二维数组，返回即是正确结果</li></ol><p>下面解释为什么经过第三步后就达到了我们题目要求的输出结果：</p><p>经过第一步排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序，所以  在进行第三步的过程中，高的人的数据肯定是先被存入集合的，所以每当我们取出一行数据，集合中已有的元素的身高肯定都是大于等于当前元素的身高的，所以当我们取出p[]数组后，发现前面应该有p[1]个人比自己高或者高度和自己相同，那么当前元素就应该排在集合的p[1]下标的位置(仔细想想是不是)，好比说目前有一个队列的人，这些人要么比你高，要么和你一样高，现在要你插入入队中，保证你前面有p[1]个人的身高大于等于你，你是不是应该排在索引为p[1]的位置</p><p>所以经过第三步的插入操作后，把每个人都插入到了正确的位置，所以根据这个集合转换的二维数组当然就是正确结果了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;        Arrays.sort(people,<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>]?o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>]:o2[<span class="hljs-number">0</span>]-o1[<span class="hljs-number">0</span>];            &#125;        &#125;);        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] p:people) res.add(p[<span class="hljs-number">1</span>],p);        <span class="hljs-keyword">int</span> n = people.length;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p>这题也能动态规划。。时间复杂度为n*n^1/2，官解中有n^1/2的方法(数学方案)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;i-j*j&gt;=<span class="hljs-number">0</span>;j++)                dp[i] = Math.min(dp[i],dp[i-j*j]+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p>自己是用了两层递归，因为只用DFS函数的话某个节点作为起点递归到下一层时它的子节点还可以作为起点递归，而另一边这个节点作为中间节点递归的函数中它的子节点也被作为起点的函数调用，如果这个子节点是终点的话那就是重复计数了两次</p><p>题解中的思路是用前缀和，使用一个map存放从根节点到当前节点之前的所有前缀和及其计数。这样在遍历到当前节点时，无需二重DFS，直接通过求目标差值，这个差值如果是之前某个节点作为终点的路径和，那一定在map中有存放，并且value就是这个值的个数，O(1)时间即可得到以当前节点为目标和路径末尾的路径总数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        helper(root,sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        dfs(root,sum,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) helper(root.left,sum);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) helper(root.right,sum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> now)</span> </span>&#123;        now += root.val;        <span class="hljs-keyword">if</span>(sum == now) res++;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) dfs(root.left,sum,now);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) dfs(root.right,sum,now);    &#125;&#125;</code></pre></div><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p>不会做，背包问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) sum += num;        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[target+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target) dp[nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=target;nums[i]&lt;=j;j--) &#123;                <span class="hljs-keyword">if</span>(dp[target]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                dp[j] = dp[j] || dp[j-nums[i]];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[target];    &#125;&#125;</code></pre></div><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p>动态规划加空间优化，<code>dp[i][j]</code>表示由i到j位置的子串是否是回文串，若<code>j=i或j-i=1且s[i]=s[j]时</code>，它当然是回文串，但如果j与i相隔较远，则需要看<code>s[j]与s[i]是否相等，且dp[i+1][j-1]是否是回文串</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=j;i++) &#123;                <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j) &amp;&amp; (j-i&lt;=<span class="hljs-number">1</span> || dp[i+<span class="hljs-number">1</span>])) &#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    res++;                &#125;                <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><p>开始用JS做题吧，感觉需要提升JS的熟练度</p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p>官解的话：避免使用 O(n)额外空间的方法就是改变输入，所以用快慢指针找到中间节点，同时反转前面或后面的链表，之后按个比较，但官方多了将链表恢复原状，因为实际写成函数后使用者不会想要在调用函数后原链表被改变</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">let</span> mid = head;    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">let</span> reverse = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.next!=<span class="hljs-literal">null</span>) &#123;        pre = mid;        mid = mid.next;        head = head.next.next;        pre.next = reverse;        reverse = pre;    &#125;    <span class="hljs-keyword">if</span>(head) mid = mid.next;    <span class="hljs-keyword">while</span>(mid) &#123;        <span class="hljs-keyword">if</span>(reverse.val != mid.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        reverse = reverse.next;        mid = mid.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p>官解中的并查集写的很棒，DFS和BFS都可以，遍历到值为1的点时开始找这个点所在的连通分量并将其中包含的所有点都变为0，不影响之后寻找其他连通分量，最后岛屿的数量就是连通分量的个数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> numIslands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;    <span class="hljs-keyword">const</span> rows = grid.length;    <span class="hljs-keyword">if</span>(rows==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++) &#123;            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">"1"</span>) &#123;                dfs(grid,i,j,rows,cols);                res++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">grid,i,j,rows,cols</span>) </span>&#123;    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;rows<span class="hljs-number">-1</span> || j&gt;cols<span class="hljs-number">-1</span> || grid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    grid[i][j] = <span class="hljs-string">"0"</span>;    dfs(grid,i+<span class="hljs-number">1</span>,j,rows,cols);    dfs(grid,i<span class="hljs-number">-1</span>,j,rows,cols);    dfs(grid,i,j+<span class="hljs-number">1</span>,rows,cols);    dfs(grid,i,j<span class="hljs-number">-1</span>,rows,cols);&#125;</code></pre></div><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p>自己用双指针，向后找第一个0用i标记，i之后的第一个非0用j标记，交换二者，与官解区别在于交换次数少，主动找0，官解即使是i与j指向同一个非0元素也会交换</p><p>官解：从index=0开始，j指向元素不为0时与i指向元素交换，二者加一，指向为0时i不动j加一</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len=nums.length;    <span class="hljs-keyword">while</span>(j&lt;len) &#123;        <span class="hljs-keyword">while</span>(i&lt;len &amp;&amp; nums[i]!=<span class="hljs-number">0</span>) i++;        j=i;        <span class="hljs-keyword">while</span>(j&lt;len &amp;&amp; nums[j]==<span class="hljs-number">0</span>) j++;        <span class="hljs-keyword">if</span>(j&lt;len) help(nums,i,j);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">help</span>(<span class="hljs-params">nums,i,j</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = nums[i];    nums[i] = nums[j];    nums[j] = tmp;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">var moveZeroes = function(nums) &#123;</span><span class="hljs-comment">    let i=0;</span><span class="hljs-comment">    let j=0;</span><span class="hljs-comment">    let len=nums.length;</span><span class="hljs-comment">    for(j=0;j&lt;len;j++) &#123;</span><span class="hljs-comment">        if(nums[j]!=0) swap(i++,j);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p>和之前做过的思路不同在于，每次新进栈的元素都和最小栈的栈顶元素比较一个最小值后决定，不论是哪个最小栈元素都会新增，所以在出栈时只要同时删除最小栈和主栈的栈顶就可以(不用担心会将最小元素删掉，因为如果主栈删掉的不是它，那最小栈删掉的也只是其复制体，主体还在下面)</p><p>顺便提一下JS的原型链是干嘛的来着。。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack = [];    <span class="hljs-keyword">this</span>.min_stack = [<span class="hljs-literal">Infinity</span>];&#125;;<span class="hljs-comment">/** </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.push(x);    <span class="hljs-keyword">this</span>.min_stack.push(<span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>],x));&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.pop();    <span class="hljs-keyword">this</span>.min_stack.pop();&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x_stack[<span class="hljs-keyword">this</span>.x_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new MinStack()</span><span class="hljs-comment"> * obj.push(x)</span><span class="hljs-comment"> * obj.pop()</span><span class="hljs-comment"> * var param_3 = obj.top()</span><span class="hljs-comment"> * var param_4 = obj.getMin()</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p>JS新建对象怎么做？</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t1, t2</span>) </span>&#123;    <span class="hljs-keyword">if</span>(t1==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t2;    <span class="hljs-keyword">if</span>(t2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t1;    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);    res.val = t1.val + t2.val;    res.left = mergeTrees(t1.left,t2.left);    res.right = mergeTrees(t1.right,t2.right);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p>DP</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProduct = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> min = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">let</span> pre_max = max;        max = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.max(max*nums[i],min*nums[i]),nums[i]);        min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.min(pre_max*nums[i],min*nums[i]),nums[i]);        res = <span class="hljs-built_in">Math</span>.max(res,max);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">最大正方形</a></h3><p>DP，记录每一个点作为正方形的右下角能完成的最大边长，就是它上方，左方，左上方三个点能完成边长的最小值，滚动数组优化</p><p>JS申请数组的方式好奇怪。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maximalSquare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">let</span> m = matrix.length;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> n = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> tmp2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">'0'</span>) &#123;                dp[j] = <span class="hljs-number">0</span>;                <span class="hljs-keyword">continue</span>;            &#125;            tmp2 = dp[j];            dp[j] = <span class="hljs-built_in">Math</span>.min(tmp,<span class="hljs-built_in">Math</span>.min(dp[j],dp[j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;            tmp = tmp2;            res = <span class="hljs-built_in">Math</span>.max(res,dp[j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res*res;&#125;;</code></pre></div><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p>摩尔投票！</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) res = nums[i];        count += res==nums[i]?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>做过的还是不会做。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span> || root==p || root==q) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">let</span> left = lowestCommonAncestor(root.left,p,q);    <span class="hljs-keyword">let</span> right = lowestCommonAncestor(root.right,p,q);    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;    <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9月做题记录&quot;&gt;&lt;a href=&quot;#9月做题记录&quot; class=&quot;headerlink&quot; title=&quot;9月做题记录&quot;&gt;&lt;/a&gt;9月做题记录&lt;/h1&gt;&lt;h3 id=&quot;单词搜索&quot;&gt;&lt;a href=&quot;#单词搜索&quot; class=&quot;headerlink&quot; title=&quot;单</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
  </entry>
  
  <entry>
    <title>8月做题记录</title>
    <link href="http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-01T03:45:34.000Z</published>
    <updated>2020-08-31T09:08:05.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8月做题记录"><a href="#8月做题记录" class="headerlink" title="8月做题记录"></a>8月做题记录</h1><p>每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录</p><h3 id="最小区间"><a href="#最小区间" class="headerlink" title="最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">最小区间</a></h3><p>8月1日，一上来就给我整个这，昨天还误伤了本科同学给人家道歉，晚上要了暗恋的隔壁实验室小姐姐的VX结果发现和想象中的根本不是同一个人，下一周还要出差，我TM烦死</p><p>这题用堆做就是用那个优先队列，记录当前所有列表头指针指向元素中最大最小的两个，获取区间，之后将小值的列表指针后移，更新最小值和最大值，更新区间，当所有列表中有一个走完了就结束循环</p><p>用滑动窗口可太恶心了，用map映射了每一个值在哪些列表里出现过，key就是元素值，value是一个list存放所有包含这个key值的列表的索引，当窗口右指针滑到能包含所有列表索引，更新一次区间，然后左指针左移动，继续找新区间，循环是所有数字中最大最小的两个，相当于遍历所有key。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;        <span class="hljs-keyword">int</span> size = nums.size();        Map&lt;Integer, List&lt;Integer&gt;&gt; indices = <span class="hljs-keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">int</span> xMin = Integer.MAX_VALUE, xMax = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums.get(i)) &#123;                List&lt;Integer&gt; list = indices.getOrDefault(x, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());                list.add(i);                indices.put(x, list);                xMin = Math.min(xMin, x);                xMax = Math.max(xMax, x);            &#125;        &#125;        <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];        <span class="hljs-keyword">int</span> inside = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = xMin, right = xMin - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> bestLeft = xMin, bestRight = xMax;        <span class="hljs-keyword">while</span> (right &lt; xMax) &#123;            right++;            <span class="hljs-keyword">if</span> (indices.containsKey(right)) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : indices.get(right)) &#123;                    freq[x]++;                    <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">1</span>) &#123;                        inside++;                    &#125;                &#125;                <span class="hljs-keyword">while</span> (inside == size) &#123;                    <span class="hljs-keyword">if</span> (right - left &lt; bestRight - bestLeft) &#123;                        bestLeft = left;                        bestRight = right;                    &#125;                    <span class="hljs-keyword">if</span> (indices.containsKey(left)) &#123;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: indices.get(left)) &#123;                            freq[x]--;                            <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">0</span>) &#123;                                inside--;                            &#125;                        &#125;                    &#125;                    left++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;bestLeft, bestRight&#125;;    &#125;&#125;</code></pre></div><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></h3><p>唉，，最近的hard都不会做。。这题用动规也可，只不过双指针更秀</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> leftmax=<span class="hljs-number">0</span>, rightmax=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(left&lt;right) &#123;            <span class="hljs-keyword">if</span>(height[left] &lt;= height[right]) &#123;                <span class="hljs-keyword">if</span>(height[left]&gt;=leftmax) leftmax=height[left];                <span class="hljs-keyword">else</span> res+=leftmax-height[left];                left++;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(height[right]&gt;=rightmax) rightmax=height[right];                <span class="hljs-keyword">else</span> res+=rightmax-height[right];                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right = pre;        root.left = <span class="hljs-keyword">null</span>;        pre = root;    &#125;&#125;</code></pre></div><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a></h3><p>看K神实现的BFS拓扑排序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];        List&lt;List&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++) adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] cp:prerequisites) &#123;            indegrees[cp[<span class="hljs-number">0</span>]]++;            adj.get(cp[<span class="hljs-number">1</span>]).add(cp[<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)            <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>) q.add(i);        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> pre = q.poll();            numCourses--;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur:adj.get(pre))                <span class="hljs-keyword">if</span>(--indegrees[cur] == <span class="hljs-number">0</span>) q.add(cur);        &#125;        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">字符串相加</a></h3><p>每次遇到这种简单题都有点懵逼。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);        <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> n1 = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> n2 = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> tmp = n1 + n2 + carry;            carry = tmp / <span class="hljs-number">10</span>;            res.append(tmp % <span class="hljs-number">10</span>);            i--; j--;        &#125;        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) res.append(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res.reverse().toString();    &#125;&#125;</code></pre></div><h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p>遍历二叉树DP，每个根节点都分为偷与不偷两种情况，用哈希表存储每个节点作为根节点能偷到的最大值(维护两个哈希表分别记录偷与不偷)，可以空间优化。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] res = dfs(root);        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dfs(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[] l = dfs(root.left);        <span class="hljs-keyword">int</span>[] r = dfs(root.right);        <span class="hljs-keyword">int</span> select = root.val + l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> notselect = Math.max(l[<span class="hljs-number">0</span>],l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>],r[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;select,notselect&#125;;    &#125;&#125;</code></pre></div><h3 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">计数二进制子串</a></h3><p>由于0和1都必须是连续的，所以把S分成了0和1个数组成的一个数组[2,3,1,3]，相邻数字分别是0或1，所以取较小值就是他们能组成的合法的子序列的个数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> ptr=<span class="hljs-number">0</span>,last=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>,n=s.length();        <span class="hljs-keyword">while</span>(ptr &lt; n) &#123;            <span class="hljs-keyword">char</span> cur = s.charAt(ptr);            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(ptr&lt;n &amp;&amp; s.charAt(ptr)==cur) &#123;                count++;                ptr++;            &#125;            res += Math.min(last,count);            last = count;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></h3><p>一般这种要求找出符合条件的字符串并放在list里面返回的都是使用DFS</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEG_COUNT=<span class="hljs-number">4</span>;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SEG_COUNT];    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">// segments = new int[SEG_COUNT];</span>        dfs(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> segID, <span class="hljs-keyword">int</span> segStart)</span> </span>&#123;        <span class="hljs-keyword">if</span>(segID == SEG_COUNT) &#123;            <span class="hljs-keyword">if</span>(segStart == s.length()) &#123;                StringBuffer ipaddr = <span class="hljs-keyword">new</span> StringBuffer();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SEG_COUNT;i++) &#123;                    ipaddr.append(segments[i]);                    <span class="hljs-keyword">if</span>(i!=SEG_COUNT-<span class="hljs-number">1</span>) ipaddr.append(<span class="hljs-string">'.'</span>);                &#125;                res.add(ipaddr.toString());            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(segStart == s.length()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(s.charAt(segStart) == <span class="hljs-string">'0'</span>) &#123;            segments[segID] = <span class="hljs-number">0</span>;            dfs(s,segID+<span class="hljs-number">1</span>,segStart+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> addr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> segEnd = segStart;segEnd&lt;s.length();segEnd++) &#123;            addr = addr*<span class="hljs-number">10</span> + (s.charAt(segEnd)-<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span>(addr&gt;<span class="hljs-number">0</span> &amp;&amp; addr&lt;=<span class="hljs-number">255</span>) &#123;                segments[segID] = addr;                dfs(s,segID+<span class="hljs-number">1</span>,segEnd+<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></h3><p>本题优化难度在于如何不使用栈空间中序遍历二叉树，使用<code>Morris中序遍历</code>，由于搜索树的中序遍历是递增序列，所以在遍历过程中找到逆序对交换节点即可</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        TreeNode x = <span class="hljs-keyword">null</span>, y = <span class="hljs-keyword">null</span>, pred = <span class="hljs-keyword">null</span>, predecessor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span>                predecessor = root.left;                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-keyword">null</span> &amp;&amp; predecessor.right != root) &#123;                    predecessor = predecessor.right;                &#125;                                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-keyword">null</span>) &#123;                    predecessor.right = root;                    root = root.left;                &#125;                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span>                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                        y = root;                        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                            x = pred;                        &#125;                    &#125;                    pred = root;                    predecessor.right = <span class="hljs-keyword">null</span>;                    root = root.right;                &#125;            &#125;            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span>            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                    y = root;                    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                        x = pred;                    &#125;                &#125;                pred = root;                root = root.right;            &#125;        &#125;        swap(x, y);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = x.val;        x.val = y.val;        y.val = tmp;    &#125;&#125;</code></pre></div><h3 id="回文对"><a href="#回文对" class="headerlink" title="回文对"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">回文对</a></h3><p>不会做，需要使用<code>字典树 + manacher</code></p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h3><p>总算是自己做出一道DFS的组合问题了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        dfs(nums,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, List&lt;Integer&gt; cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;nums.length;i++) &#123;            cur.add(nums[i]);            swap(nums,i,start);            dfs(nums,start+<span class="hljs-number">1</span>,cur);            cur.remove(cur.size()-<span class="hljs-number">1</span>);            swap(nums,i,start);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h3><p>可以先按角平分线翻转之后再逐行对称反转，或者是像这样按每一个外圈旋转，然后往里面缩</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos2 = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (pos1 &lt; pos2)&#123;            add = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (add &lt; pos2 - pos1)&#123;                temp = matrix[pos1][pos1 + add];                matrix[pos1][pos1 + add] = matrix[pos2 - add][pos1];                matrix[pos2 - add][pos1] = matrix[pos2][pos2 -add];                matrix[pos2][pos2 -add] = matrix[pos1 + add][pos2];                matrix[pos1 + add][pos2] = temp;                add++;            &#125;            pos1++;            pos2--;        &#125;    &#125;&#125;</code></pre></div><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h3><p>可以分到一组的单词，他们之中出现的字符的个数一定都相等，用map保存这些个数，统计26个字母出现的个数用#分割作为key，或者对字符排序后作为key，只要二者一组则字母序排序一定是一样的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();        HashMap&lt;String,List&gt; res = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(String s: strs) &#123;            Arrays.fill(count,<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: s.toCharArray()) count[c-<span class="hljs-string">'a'</span>]++;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++) &#123;                sb.append(<span class="hljs-string">'#'</span>);                sb.append(count[i]);            &#125;            String key = sb.toString();            <span class="hljs-keyword">if</span>(!res.containsKey(key)) res.put(key,<span class="hljs-keyword">new</span> ArrayList());            res.get(key).add(s);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(res.values());    &#125;&#125;</code></pre></div><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></h3><p>用max保存遍历的每一个位置所能到达的最远位置，如果能超过末尾元素说明可达</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i &lt;= max) &#123;                max = Math.max(max,i+nums[i]);                <span class="hljs-keyword">if</span>(max &gt;= n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h3><p>对tuple进行排序，java用数组排序的函数，有接口重写没太看懂，不知道用JS的话要怎么实现呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;        <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][];        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(intervals,Comparator.comparingInt(a-&gt;a[<span class="hljs-number">0</span>]));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] interval: intervals) &#123;            <span class="hljs-keyword">int</span> mergedSize = merged.size();            <span class="hljs-keyword">if</span> (merged.isEmpty()) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!merged.isEmpty() &amp;&amp; merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> lastRight = merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];                merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(lastRight, interval[<span class="hljs-number">1</span>]);            &#125;        &#125;        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);    &#125; &#125;</code></pre></div><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></h3><p>本身字符不需要改变可以直接等于<code>dp[i-1][j-1]</code>,<code>dp[i-1][j]</code>表示删除word1的最后一个字符，<code>dp[i][j-1]</code>表示在最后插入word2的最后一个字符，<code>dp[i-1][j-1]</code>表示word1的最后一个字符替换位word2的最后一个字符</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;        <span class="hljs-keyword">int</span> n1 = word1.length();        <span class="hljs-keyword">int</span> n2 = word2.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) &#123;                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>)) dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                <span class="hljs-keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i][j-<span class="hljs-number">1</span>]),dp[i-<span class="hljs-number">1</span>][j])+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n1][n2];    &#125;&#125;</code></pre></div><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></h3><p>用指针指向边界，然后遍历时交换位置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>,p0=<span class="hljs-number">0</span>,p2=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(cur&lt;=p2) &#123;            <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">0</span>) &#123;                swap(nums,cur,p0);                cur++;                p0++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">2</span>) &#123;                swap(nums,cur,p2);                p2--;            &#125;            <span class="hljs-keyword">else</span> cur++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></h3><p>滑动窗口，不会做，check也看不懂是在干嘛。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">int</span> tLen = t.length();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;            <span class="hljs-keyword">char</span> c = t.charAt(i);            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len = Integer.MAX_VALUE, ansL = -<span class="hljs-number">1</span>, ansR = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> sLen = s.length();        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;            ++r;            <span class="hljs-keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;                    len = r - l + <span class="hljs-number">1</span>;                    ansL = l;                    ansR = l + len;                &#125;                <span class="hljs-keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);                &#125;                ++l;            &#125;        &#125;        <span class="hljs-keyword">return</span> ansL == -<span class="hljs-number">1</span> ? <span class="hljs-string">""</span> : s.substring(ansL, ansR);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;        Iterator iter = ori.entrySet().iterator();         <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;             Map.Entry entry = (Map.Entry) iter.next();             Character key = (Character) entry.getKey();             Integer val = (Integer) entry.getValue();             <span class="hljs-keyword">if</span> (cnt.getOrDefault(key, <span class="hljs-number">0</span>) &lt; val) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></h3><p>对输出的集合中每一个小序列添加新的数字后（这里复制用的是新空间），再放到输出集合中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; output = <span class="hljs-keyword">new</span> ArrayList();    output.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;      List&lt;List&lt;Integer&gt;&gt; newSubsets = <span class="hljs-keyword">new</span> ArrayList();      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : output) &#123;        newSubsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(curr)&#123;&#123;add(num);&#125;&#125;);      &#125;      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : newSubsets) &#123;        output.add(curr);      &#125;    &#125;    <span class="hljs-keyword">return</span> output;  &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8月做题记录&quot;&gt;&lt;a href=&quot;#8月做题记录&quot; class=&quot;headerlink&quot; title=&quot;8月做题记录&quot;&gt;&lt;/a&gt;8月做题记录&lt;/h1&gt;&lt;p&gt;每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.23至7.31做题记录</title>
    <link href="http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-23T06:42:30.000Z</published>
    <updated>2020-07-31T05:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-23至7-31做题记录"><a href="#7-23至7-31做题记录" class="headerlink" title="7.23至7.31做题记录"></a>7.23至7.31做题记录</h1><p>今天开始做HOT100的题目，之前的题目会用JS作为复习更新在JS力扣练习的文章里。</p><p>7.23每日一题是矩阵的最短路径，就不贴上来了。</p><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a></h3><p>时间复杂度要求O(log(m + n))，所以使用两个指针移动计数寻找总长度一半这样的不行，因为复杂度为O(m+n)，题解利用两个数组是排序的，用二分来寻找中位数K，在A的K/2位置与B的K/2位置比较，较小的那一个之前的所有元素一定不包含中位数，所以可以直接排除掉K/2个数，循环即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> totalLength = length1 + length2;        <span class="hljs-keyword">if</span>(totalLength%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> mid = totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = getKthElement(nums1,nums2,mid+<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> median;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> mid1=totalLength/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, mid2=totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, mid1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, mid2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;            <span class="hljs-keyword">return</span> median;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> index1=<span class="hljs-number">0</span>, index2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> KthElement = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span>(index1 == length1) <span class="hljs-keyword">return</span> nums2[index2+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(index2 == length2) <span class="hljs-keyword">return</span> nums1[index1+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[index1],nums2[index2]);            <span class="hljs-keyword">int</span> half = k/<span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> newindex1 = Math.min(index1+half,length1)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> newindex2 = Math.min(index2+half,length2)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> pivot1 = nums1[newindex1], pivot2 = nums2[newindex2];            <span class="hljs-keyword">if</span>(pivot1 &lt;= pivot2) &#123;                k -= (newindex1-index1+<span class="hljs-number">1</span>);                index1 = newindex1+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                k -= (newindex2-index2+<span class="hljs-number">1</span>);                index2 = newindex2+<span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>题解还给了一种O(min(m,n))的方法：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">力扣官方题解</a></p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></h3><p>真尼玛这也能动态规划，中心扩散，还有一种时间复杂度更低的我没有看</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;        String res = s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-comment">// 中心位置枚举到 len - 2 即可</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            String oddStr = centerSpread(s, i, i);            String evenStr = centerSpread(s, i, i + <span class="hljs-number">1</span>);            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;            <span class="hljs-keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;                maxLen = maxLenStr.length();                res = maxLenStr;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">centerSpread</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span>        <span class="hljs-comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span>        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">int</span> i = left;        <span class="hljs-keyword">int</span> j = right;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; len) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;                i--;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span>        <span class="hljs-keyword">return</span> s.substring(i + <span class="hljs-number">1</span>, j);    &#125;&#125;</code></pre></div><h3 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">分割数组的最大值</a></h3><p>是真的牛批，看题解都差点没看懂，这他妈也是DP，时间复杂度更低的是贪心二分，因为那个值一定在数组总和与其中最大元素值之间，通过二分这个值来判断分出来的数组个数是否满足要求，这样更优</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) Arrays.fill(f[i],Integer.MAX_VALUE);        <span class="hljs-keyword">int</span>[] sub = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) sub[i+<span class="hljs-number">1</span>] = sub[i]+nums[i];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=Math.min(i,m);j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++) &#123;                    f[i][j] = Math.min(f[i][j],Math.max(sub[i]-sub[k],f[k][j-<span class="hljs-number">1</span>]));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h3><p>我以为还是DP，想复杂了，双指针O(n)就能解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, j=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j)            res = Math.max(res,height[i]&lt;height[j]?(j-i)*height[i++]:(j-i)*height[j--]);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列</a></h3><p>这个用双指针做的，但是如果要求很多个s求是否为子序列不太好，官解用了DP。。真的离谱，维护了一个DP数组查找每个位置下一个字符的位置在哪里，这样包装成函数会很好用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(t.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&lt;t.length()) &#123;            <span class="hljs-keyword">if</span>(t.charAt(j) == s.charAt(i)) i++;            <span class="hljs-keyword">if</span>(i == s.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            j++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">矩阵中的最长递增路径</a></h3><p>每次控制方向移动的步骤都有点懵，官解用DFS和拓扑排序做，后者其实就是动态规划的思想，但它统计用队列去搞了，就是队列实现拓扑的方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int longestIncreasingPath(int[][] matrix) &#123;</span><span class="hljs-comment">//         int n=matrix.length, m=matrix[0].length;</span><span class="hljs-comment">//         int[][] f = new int[n][m];</span><span class="hljs-comment">//         int res = Integer.MIN_VALUE;</span><span class="hljs-comment">//         // for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//         //     for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//         //         f[i][j]=1;</span><span class="hljs-comment">//         //     &#125;</span><span class="hljs-comment">//         // &#125;</span><span class="hljs-comment">//         for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//                 f[i][j] = </span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public int cal(int i, int j, int[][] matrix, int[][] f) &#123;</span><span class="hljs-comment">//         int top=0, bottom=0,left=0,right=0;</span><span class="hljs-comment">//         if((j-1)&gt;=0) &#123;</span><span class="hljs-comment">//             left = matrix[i][j-1];</span><span class="hljs-comment">//             77</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         if((j+1)&lt;matrix[0].length) right = matrix[i][j+1];</span><span class="hljs-comment">//         if((i-1)&gt;=0) top = matrix[i-1][j];</span><span class="hljs-comment">//         if((i+1)&lt;matrix.length) bottom = matrix[i+1][j];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;这是自己写的DP没写完就去吃小龙虾了。。。回来懒得写直接copy官解</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> rows, columns;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        rows = matrix.length;        columns = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][columns];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; ++j) &#123;                ans = Math.max(ans, dfs(matrix, i, j, memo));            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span>[][] memo)</span> </span>&#123;        <span class="hljs-keyword">if</span> (memo[row][column] != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> memo[row][column];        &#125;        ++memo[row][column];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newRow = row + dir[<span class="hljs-number">0</span>], newColumn = column + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="hljs-number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;                memo[row][column] = Math.max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> memo[row][column];    &#125;&#125;</code></pre></div><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></h3><p>这题K神讲过，用递归深度遍历就行，就是输入每个键对应的字母有点麻烦</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;String, String&gt; phone = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;    put(<span class="hljs-string">"2"</span>, <span class="hljs-string">"abc"</span>);    put(<span class="hljs-string">"3"</span>, <span class="hljs-string">"def"</span>);    put(<span class="hljs-string">"4"</span>, <span class="hljs-string">"ghi"</span>);    put(<span class="hljs-string">"5"</span>, <span class="hljs-string">"jkl"</span>);    put(<span class="hljs-string">"6"</span>, <span class="hljs-string">"mno"</span>);    put(<span class="hljs-string">"7"</span>, <span class="hljs-string">"pqrs"</span>);    put(<span class="hljs-string">"8"</span>, <span class="hljs-string">"tuv"</span>);    put(<span class="hljs-string">"9"</span>, <span class="hljs-string">"wxyz"</span>);  &#125;&#125;;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curres, String nextdigit)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nextdigit.length() == <span class="hljs-number">0</span>) res.add(curres);        <span class="hljs-keyword">else</span> &#123;            String digit = nextdigit.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);            String letter = phone.get(digit);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;letter.length();i++) &#123;                String addletter = letter.substring(i,i+<span class="hljs-number">1</span>);                dfs(curres+addletter,nextdigit.substring(<span class="hljs-number">1</span>));            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits.length() != <span class="hljs-number">0</span>) dfs(<span class="hljs-string">""</span>,digits);        <span class="hljs-keyword">return</span> res;     &#125;&#125;</code></pre></div><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h3><p>自己写的迭代方法恶心的批爆，提交了官解的迭代，在这里码一下官解的递归，简洁明了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l2;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l1, l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="寻宝"><a href="#寻宝" class="headerlink" title="寻宝"></a><a href="https://leetcode-cn.com/problems/xun-bao/" target="_blank" rel="noopener">寻宝</a></h3><p>这个每日一题太强了，我不会做，看官解看的很吃力。</p><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h3><p>用递归回溯，没有考虑到其实只要当前添加位置右括号数量比左括号数量少就一定不会错误，而左括号在没有超过最大数目时可以任意添加</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;         List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();         recur(res,<span class="hljs-keyword">new</span> StringBuilder(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);         <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder cur, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close, <span class="hljs-keyword">int</span> max)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cur.length() == max*<span class="hljs-number">2</span>) &#123;            res.add(cur.toString());            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span>(open &lt; max) &#123;            cur.append(<span class="hljs-string">'('</span>);            recur(res,cur,open+<span class="hljs-number">1</span>,close,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span>(close &lt; open) &#123;            cur.append(<span class="hljs-string">')'</span>);            recur(res,cur,open,close+<span class="hljs-number">1</span>,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></h3><p>合并两个链表和前面的那个方法一样，这里用的是分治的思路合并K个，官解中用优先队列也可以，Java中实现了优先队列的方法可以直接调用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists.length == <span class="hljs-number">0</span> || lists == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,lists.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> lists[left];        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        ListNode l1 = merge(lists,left,mid);        ListNode l2 = merge(lists,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1,l2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val) &#123;            l1.next = mergeTwoLists(l1.next,l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l2.next,l1);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h3><p>题目一开始没太看懂。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="hljs-number">1</span>]) i--;        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(j&gt;i &amp;&amp; nums[j]&lt;=nums[i]) j--;            swap(nums,i,j);        &#125;        reverse(nums,i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = start+<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            swap(nums,i,j);            i++;            j--;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></h3><p>和之前找旋转点一个主要思路，<code>nums[left] &lt;= nums[mid]</code>需要加=号是因为如果target不在left到mid的区间需要<code>left=mid+1</code>，由于计算mid取整，所以mid和left是有可能一样的，没有等号就无法进入这条语句了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid]) &#123;                <span class="hljs-keyword">if</span>(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left=mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right=mid-<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h3><p>二分的边界真的能把人写吐🤮，收藏一篇分析二分边界的文章：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">labuladong</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;=target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span> || nums[j]!=target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> right = j;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,right&#125;;    &#125;&#125;</code></pre></div><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></h3><p>DFS添加和剪枝，先搞一个排序，注意为了不重复需要在循环中定义每次开始的循环位置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        List&lt;Integer&gt; curres = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(candidates);        dfs(candidates,target,curres,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; curres, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(curres));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;candidates.length;i++) &#123;            <span class="hljs-keyword">if</span>(target-candidates[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            curres.add(candidates[i]);            dfs(candidates,target-candidates[i],curres,i);            curres.remove(curres.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-23至7-31做题记录&quot;&gt;&lt;a href=&quot;#7-23至7-31做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.23至7.31做题记录&quot;&gt;&lt;/a&gt;7.23至7.31做题记录&lt;/h1&gt;&lt;p&gt;今天开始做HOT100的题目，之前的题目会用JS作为</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.21至7.22做题记录</title>
    <link href="http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-21T02:57:16.000Z</published>
    <updated>2020-07-22T08:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-21至7-22做题记录"><a href="#7-21至7-22做题记录" class="headerlink" title="7.21至7.22做题记录"></a>7.21至7.22做题记录</h1><h3 id="不同的二叉搜索树2"><a href="#不同的二叉搜索树2" class="headerlink" title="不同的二叉搜索树2"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">不同的二叉搜索树2</a></h3><p>与7.15号那个第一题不同在于那题只需要统计不同树的数量，这个是要创建树并全部返回，那个用dp这个用递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        <span class="hljs-keyword">return</span> create(<span class="hljs-number">1</span>,n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        List&lt;TreeNode&gt; alltree = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(start &gt; end) &#123;            alltree.add(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> alltree;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++) &#123;            List&lt;TreeNode&gt; left = create(start,i-<span class="hljs-number">1</span>);            List&lt;TreeNode&gt; right = create(i+<span class="hljs-number">1</span>,end);            <span class="hljs-keyword">for</span>(TreeNode treel:left) &#123;                <span class="hljs-keyword">for</span>(TreeNode treer:right) &#123;                    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);                    root.left = treel;                    root.right = treer;                    alltree.add(root);                &#125;            &#125;        &#125;                <span class="hljs-keyword">return</span> alltree;    &#125;&#125;</code></pre></div><h3 id="求前N项的和"><a href="#求前N项的和" class="headerlink" title="求前N项的和"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求前N项的和</a></h3><p>不让用加减乘除和条件判断，K神说用逻辑运算符的短路效果控制递归的执行与否</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> x = n&gt;<span class="hljs-number">1</span> &amp;&amp; (n+=sumNums(n-<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> n;    &#125;   &#125;</code></pre></div><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h3><p>K神写的位运算太吊了：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">Krahets</a></p><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>因为是搜索树所以通过节点的值判断p和q的位置：在两侧则当前为公共祖先，在同一侧则有当前节点大于二者或小于二者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p.val &gt; q.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root,q,p);        <span class="hljs-keyword">int</span> left=p.val, right=q.val;        <span class="hljs-keyword">return</span> dfs(root,left,right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(root.val&gt;=left &amp;&amp; root.val&lt;=right) <span class="hljs-keyword">return</span> root;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; left) <span class="hljs-keyword">return</span> dfs(root.right,left,right);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dfs(root.left,left,right);    &#125; &#125;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>看的K神 :<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">Krahets</a>的答案，太tm吊了，我连简单题都不会做呜呜呜~~</p><p>至此，剑指offer的所有题目都做完了，明天开始做HOT100的题目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-21至7-22做题记录&quot;&gt;&lt;a href=&quot;#7-21至7-22做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.21至7.22做题记录&quot;&gt;&lt;/a&gt;7.21至7.22做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同的二叉搜索树2&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.16至7.20做题记录</title>
    <link href="http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-16T06:57:40.000Z</published>
    <updated>2020-07-20T07:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-16至7-20做题记录"><a href="#7-16至7-20做题记录" class="headerlink" title="7.16至7.20做题记录"></a>7.16至7.20做题记录</h1><h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">判断二分图</a></h3><p>看了题解，其实就是遍历图，用染色法在遍历的过程中，将相邻的节点分成不同颜色集合的，如果能分完就返回true，遇到相邻节点但是是一个颜色返回false，DFS\BFS都可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNCOLORED = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RED = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GREEN = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] color;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> valid;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = graph.length;        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        valid = <span class="hljs-keyword">true</span>;        Arrays.fill(color,UNCOLORED);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n &amp;&amp; valid;i++) &#123;            <span class="hljs-keyword">if</span>(color[i] == UNCOLORED)                dfs(i,RED,graph);        &#125;        <span class="hljs-keyword">return</span> valid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> cur_co, <span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        color[cur] = cur_co;        <span class="hljs-keyword">int</span> nei_co = color[cur]==RED?GREEN:RED;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nei:graph[cur]) &#123;            <span class="hljs-keyword">if</span>(color[nei] == UNCOLORED) &#123;                dfs(nei,nei_co,graph);                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[nei] != nei_co) &#123;                valid = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span>;            &#125;            &#125;    &#125;&#125;</code></pre></div><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h3><p>这尼玛居然是简单难度。。。看K神题解用之前的含有min函数的栈那个方法去做，用队列保存一个最大值，这样每次窗口取最大值的时间复杂度就是O(1)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) &#123;            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast()&lt;nums[i]) q.removeLast();            q.addLast(nums[i]);        &#125;        res[<span class="hljs-number">0</span>]=q.peekFirst();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=k; j &lt; nums.length; i++,j++) &#123; <span class="hljs-comment">// 形成窗口后</span>            <span class="hljs-keyword">if</span>(q.peekFirst() == nums[i]) q.removeFirst();            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast() &lt; nums[j]) q.removeLast();            q.addLast(nums[j]);            res[i+<span class="hljs-number">1</span>] = q.peekFirst();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></h3><p>直接二分不解释</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l&lt;=r) &#123;            <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) r=mid-<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;         &#125;        <span class="hljs-keyword">return</span> l;    &#125;&#125;</code></pre></div><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">队列的最大值</a></h3><p>比较辅助队列和主队列的值是否相等时不能用==,需要用equals，思想和之前栈的那个题一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;        Deque&lt;Integer&gt; q;    Deque&lt;Integer&gt; help_q;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help_q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> help_q.peekFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        q.addLast(value);        <span class="hljs-keyword">while</span>(!help_q.isEmpty() &amp;&amp; help_q.peekLast()&lt;value) help_q.removeLast();        help_q.addLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(q.peekFirst().equals(help_q.peekFirst())) help_q.removeFirst();        <span class="hljs-keyword">return</span> q.poll();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></h3><p>和室友讨论想到动规，类似机器人找路径的二维矩阵，只能往左或往下走</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s1.length();        <span class="hljs-keyword">int</span> m = s2.length();        <span class="hljs-keyword">if</span>(s3.length() != n+m) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">int</span> p = i+j-<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) dp[j] = dp[j]&amp;&amp;s1.charAt(i-<span class="hljs-number">1</span>)==s3.charAt(p);                <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) dp[j] |= dp[j-<span class="hljs-number">1</span>]&amp;&amp;s2.charAt(j-<span class="hljs-number">1</span>)==s3.charAt(p);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m];    &#125;&#125;</code></pre></div><h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p>这他妈都能动态规划？原来动规不都是从前往后遍历一次的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] rec = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>][n+<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span>[] val = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];        val[<span class="hljs-number">0</span>] = val[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) val[i] = nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">2</span>;j&lt;=n+<span class="hljs-number">1</span>;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i+<span class="hljs-number">1</span>;k&lt;j;k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i]*val[k]*val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = Math.max(rec[i][j],sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h3><p>这题居然是简单题。。。最高赞的题解是计算出每种点数出现的次数然后除以总次数，我觉得不如这个老哥直接计算概率</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">double</span> pre[]=&#123;<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">5</span>*i+<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;pre.length;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">6</span>;x++) &#123;                    tmp[j+x] += pre[j]/<span class="hljs-number">6</span>;                &#125;            &#125;            pre = tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre></div><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/Ef73zZv6wiaXwiJRnCLpoQ" target="_blank" rel="noopener">动态规划初级试炼场</a></p><h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h3><p>最近的简单题是真滴牛批，约瑟夫环倒推就两行，我想不出来。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-16至7-20做题记录&quot;&gt;&lt;a href=&quot;#7-16至7-20做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.16至7.20做题记录&quot;&gt;&lt;/a&gt;7.16至7.20做题记录&lt;/h1&gt;&lt;h3 id=&quot;判断二分图&quot;&gt;&lt;a href=&quot;#判断二分</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.11至7.15做题记录</title>
    <link href="http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-15T03:19:57.000Z</published>
    <updated>2020-07-15T03:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-11至7-15做题记录"><a href="#7-11至7-15做题记录" class="headerlink" title="7.11至7.15做题记录"></a>7.11至7.15做题记录</h1><h3 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a></h3><p>不会做。。。</p><h3 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">地下城游戏</a></h3><p>从开始往前走需要同时考虑最低初始健康和过程中的路径和两个值，所以“有两个重要程度相同的参数同时影响后续的决策，这样的动态规划是不满足「无后效性」的”</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dungeon)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=dungeon.length, m=dungeon[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[m-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--) &#123;                dp[j] = Math.max(<span class="hljs-number">1</span>,Math.min(dp[j],dp[j+<span class="hljs-number">1</span>])-dungeon[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><h3 id="两个数组的交集2"><a href="#两个数组的交集2" class="headerlink" title="两个数组的交集2"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集2</a></h3><p>很容易想到用hashmap做，但巧妙在于一定去更短的那个数组放到map里</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;            <span class="hljs-keyword">return</span> intersect(nums2, nums1);        &#125;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums1) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;            map.put(num, count);        &#125;        <span class="hljs-keyword">int</span>[] intersection = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums2) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) &#123;                intersection[index++] = num;                count--;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) map.put(num, count);                <span class="hljs-keyword">else</span> map.remove(num);            &#125;        &#125;         <span class="hljs-keyword">return</span> Arrays.copyOfRange(intersection, <span class="hljs-number">0</span>, index);    &#125;&#125;</code></pre></div><h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h3><p>笨比才用两数之和的方法做，人家说了是递增排序肯定是有用的，用双指针滑动窗口就可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>(map.containsKey(num)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num,target-num&#125;;            map.put(target-num,num);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><p>没错我就用的两数之和的那个。。。</p><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></h3><p>题不难想到解法，但边界的转移需要注意</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = triangle.size();        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        f[<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i] = f[i-<span class="hljs-number">1</span>]+triangle.get(i).get(i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;<span class="hljs-number">0</span>;j--) f[j] = Math.min(f[j],f[j-<span class="hljs-number">1</span>])+triangle.get(i).get(j);            f[<span class="hljs-number">0</span>] += triangle.get(i).get(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) min = Math.min(min,f[i]);        <span class="hljs-keyword">return</span> min;    &#125;&#125;</code></pre></div><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">和为s的连续正数序列</a></h3><p>和之前那个题一样，但返回的list toarray没搞明白</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(i&lt;=target/<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(sum &lt; target) sum += j++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) sum -= i++;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;j;k++) arr[k-i] = k;                res.add(arr);                sum -= i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]); <span class="hljs-comment">// 这里的new int[][]没搞清楚</span>    &#125;&#125;</code></pre></div><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p> <a href="https://baike.baidu.com/item/卡特兰数" target="_blank" rel="noopener">卡特兰数</a> 是真滴牛批，<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/" target="_blank" rel="noopener">灵魂画手</a>的题解写的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) dp[i] += dp[j-<span class="hljs-number">1</span>]*dp[i-j];        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-11至7-15做题记录&quot;&gt;&lt;a href=&quot;#7-11至7-15做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.11至7.15做题记录&quot;&gt;&lt;/a&gt;7.11至7.15做题记录&lt;/h1&gt;&lt;h3 id=&quot;计算右侧小于当前元素的个数&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.6至7.10做题记录</title>
    <link href="http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-06T02:14:42.000Z</published>
    <updated>2020-07-10T08:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-6至7-10做题记录"><a href="#7-6至7-10做题记录" class="headerlink" title="7.6至7.10做题记录"></a>7.6至7.10做题记录</h1><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h3><p>题不难但是没想到空间复杂度的优化</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePaths(int m, int n) &#123;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j] + f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 空间复杂度优化</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(cur,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                cur[j] += cur[j-<span class="hljs-number">1</span>] ;            &#125;        &#125;        <span class="hljs-keyword">return</span> cur[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="不同路径2"><a href="#不同路径2" class="headerlink" title="不同路径2"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径2</a></h3><p>和上一个差不多，多了障碍，以后做动规要考虑优化滚动数组</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><span class="hljs-comment">//         if(obstacleGrid[0][0] == 1) return 0;</span><span class="hljs-comment">//         int m=obstacleGrid.length, n=obstacleGrid[0].length;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 if(obstacleGrid[i-1][j-1] == 1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j]+f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 利用滚动数组优化空间复杂度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> m=obstacleGrid.length, n=obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;            res[i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;                    res[j] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>) res[j] += res[j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> res[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h3><p>对各类排序算法的衍生应用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//不一定可以在原数组上更改所以copy一份</span>        <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) copy[i] = nums[i];        <span class="hljs-comment">//传入可以重复使用的辅助空间，这样就不用每次都新开空间了</span>        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">return</span> reversePairs(copy,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,tmp);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> leftPairs = reversePairs(nums,left,mid,tmp);        <span class="hljs-keyword">int</span> rightPairs = reversePairs(nums,mid+<span class="hljs-number">1</span>,right,tmp);        <span class="hljs-keyword">if</span>(nums[mid] &lt;= nums[mid+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> leftPairs + rightPairs;        <span class="hljs-keyword">int</span> mergecount = merge(nums,left,mid,right,tmp);        <span class="hljs-keyword">return</span> leftPairs + rightPairs + mergecount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++) tmp[i] = nums[i];        <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=left;k&lt;=right;k++) &#123;            <span class="hljs-keyword">if</span>(i == mid+<span class="hljs-number">1</span>) nums[k] = tmp[j++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == right+<span class="hljs-number">1</span>) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> &#123;                nums[k] = tmp[j++];                count += mid-i+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></h3><p>题很简单但是感觉自己的代码很干练所以贴一下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span> &amp;&amp; root.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.val == sum;        <span class="hljs-keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找数字1"><a href="#在排序数组中查找数字1" class="headerlink" title="在排序数组中查找数字1"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字1</a></h3><p>我的想法是二分找到tar，再向两边扩散增加res，K神直接两次二分找左右边界：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> mid = right / <span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(nums[mid]!=target &amp;&amp; left&lt;right) &#123;            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;                left = mid+<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;                right = mid-<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(nums[mid] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;nums.length&amp;&amp;nums[i]==target;i++,res++);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==target;i--,res++);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">0~n-1中缺失的数字</a></h3><p>题不难，但是自己对退出循环的条件以及退出后该返回的值总是不清楚，看K神就分析的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == mid) left = mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> right = mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre></div><h3 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">恢复空格</a></h3><p>需要手写字典树，要会</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">respace</span><span class="hljs-params">(String[] dictionary, String sentence)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = sentence.length();        Trie root = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span>(String str: dictionary) root.insert(str);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;            Trie cur = root;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--) &#123;                <span class="hljs-keyword">int</span> t = sentence.charAt(j-<span class="hljs-number">1</span>)-<span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.next[t].isEnd == <span class="hljs-keyword">true</span>) dp[i]=Math.min(dp[i],dp[j-<span class="hljs-number">1</span>]);                <span class="hljs-comment">//防止retrained这种，re不是词但train是，必须一直往前找最小的才行，除非是0</span>                <span class="hljs-keyword">if</span>(dp[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;                cur = cur.next[t];             &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        <span class="hljs-keyword">public</span> Trie[] next;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEnd;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];            isEnd = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;            Trie cur = <span class="hljs-keyword">this</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;                <span class="hljs-keyword">int</span> t=s.charAt(i) - <span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) cur.next[t] = <span class="hljs-keyword">new</span> Trie();                cur = cur.next[t];            &#125;            cur.isEnd = <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p>想不出来，动规每天都好几个状态，每天都新计算这些状态，可优化空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = prices.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]-prices[i]);            f[i][<span class="hljs-number">1</span>] = f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i];            f[i][<span class="hljs-number">2</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);        &#125;        <span class="hljs-keyword">return</span> Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">平衡二叉树</a></h3><p>自顶向下写的，时间复杂度NlogN，最差logN层，每层都遍历N数量级的节点。而自底向上可以做到N复杂度，只需要遍历所有节点就可以，后者是K神的做法：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> Math.abs(depth(root.left)-depth(root.right))&lt;=<span class="hljs-number">1</span>             &amp;&amp; isBalanced(root.left)             &amp;&amp; isBalanced(root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(depth(root.left),depth(root.right));    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数</a></h3><p>位运算找一个很简单，但找两个就很巧妙了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) k ^= num;        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((k&amp;mask) == <span class="hljs-number">0</span>) mask &lt;&lt;= <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>((mask&amp;num) == <span class="hljs-number">0</span>) a^=num;            <span class="hljs-keyword">else</span> b ^= num;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b&#125;;    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 II</a></h3><p>不会做，看K神<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">Krahets</a>的也很难看懂，他的one和two代表的是两个数：</p><p>one：0000000000</p><p>two：0100101000</p><p>num：0101000010</p><p>类似这样的两个数，再遍历数组计算每一位的状态，返回的就是要找的数，因为每一位是同时操作的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-6至7-10做题记录&quot;&gt;&lt;a href=&quot;#7-6至7-10做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.6至7.10做题记录&quot;&gt;&lt;/a&gt;7.6至7.10做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同路径&quot;&gt;&lt;a href=&quot;#不同路径&quot; cla</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS力扣练习</title>
    <link href="http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/</id>
    <published>2020-07-04T07:35:24.000Z</published>
    <updated>2020-07-05T03:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS力扣练习"><a href="#JS力扣练习" class="headerlink" title="JS力扣练习"></a>JS力扣练习</h1><p>这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java</p><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p>这个题目真的很浪漫，错的人迟早会走散，而对的人迟早会相逢。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;    <span class="hljs-keyword">var</span> n1=headA;    <span class="hljs-keyword">var</span> n2=headB;    <span class="hljs-keyword">while</span>(n1!=n2) &#123;        <span class="hljs-keyword">if</span>(n1==<span class="hljs-literal">null</span>) n1=headB;        <span class="hljs-keyword">else</span> n1=n1.next;        <span class="hljs-keyword">if</span>(n2==<span class="hljs-literal">null</span>) n2=headA;        <span class="hljs-keyword">else</span> n2=n2.next;    &#125;    <span class="hljs-keyword">return</span> n1;&#125;;</code></pre></div><h3 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间节点</a></h3><p>思考利用链表节点之间的距离变化来解决</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> fast = head, slow = head;    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>) &#123;        fast = fast.next.next;        slow = slow.next;    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS力扣练习&quot;&gt;&lt;a href=&quot;#JS力扣练习&quot; class=&quot;headerlink&quot; title=&quot;JS力扣练习&quot;&gt;&lt;/a&gt;JS力扣练习&lt;/h1&gt;&lt;p&gt;这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java&lt;/p&gt;
&lt;h3 id=&quot;相交链表&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>7.1至7.5做题记录</title>
    <link href="http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-01T02:45:23.000Z</published>
    <updated>2020-07-06T02:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-1至7-5做题记录"><a href="#7-1至7-5做题记录" class="headerlink" title="7.1至7.5做题记录"></a>7.1至7.5做题记录</h1><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组</a></h3><p>其实想到是用动规去做了，但是状态定义和状态转移都没想到，遇到动规可以尝试从后往前推</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length][B.length];        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.length;i++)            f[i][<span class="hljs-number">0</span>] = A[i]==B[<span class="hljs-number">0</span>]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;A.length;j++)            f[<span class="hljs-number">0</span>][j] = A[<span class="hljs-number">0</span>]==B[j]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;A.length;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;B.length;j++) &#123;                f[i][j] = A[i]==B[j]?f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;                max = Math.max(max,f[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h3><p>我不会做我是笨蛋，看大佬的题解吧：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">Krahets</a></p><h3 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h3><p>呵呵，我会做个吊毛，高中时可能还能做出来吧，看大佬的：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">Krahets</a></p><h3 id="有序矩阵中第K小的元素"><a href="#有序矩阵中第K小的元素" class="headerlink" title="有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">有序矩阵中第K小的元素</a></h3><p>有序矩阵要找好起始点，按条件找移动方式</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=matrix.length;        <span class="hljs-keyword">int</span> left = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> right = matrix[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span>(left&lt;right) &#123;             <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(check(matrix,mid,k,n)) right=mid;            <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j] &lt;= mid) &#123;                num += i+<span class="hljs-number">1</span>;                j++;            &#125;            <span class="hljs-keyword">else</span>                i--;        &#125;        <span class="hljs-keyword">return</span> num&gt;=k;    &#125;&#125;</code></pre></div><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h3><p>发现自己手写快排很不熟练，每次都要看很久。。</p><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></h3><p>二叉搜索树的中序遍历就是一个有序数组，从中间分开递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> help(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        root.left = help(nums,left,mid-<span class="hljs-number">1</span>);        root.right = help(nums,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre></div><h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h3><p>二维矩阵呗</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=grid.length, n=grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;</code></pre></div><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h3><p>自己只用了map，没想到更优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int lengthOfLongestSubstring(String s) &#123;</span><span class="hljs-comment">//         HashMap&lt;Integer,Character&gt; map = new HashMap();</span><span class="hljs-comment">//         int max = Integer.MIN_VALUE;</span><span class="hljs-comment">//         int j = 0;</span><span class="hljs-comment">//         for(int i=0;i&lt;s.length();i++) &#123;</span><span class="hljs-comment">//             char cur = s.charAt(i);</span><span class="hljs-comment">//             if(map.containsValue(cur)) &#123;</span><span class="hljs-comment">//                 max = Math.max(max,map.size());</span><span class="hljs-comment">//                 for(;map.get(j)!=cur;j++) map.remove(j);</span><span class="hljs-comment">//                 map.remove(j++);</span><span class="hljs-comment">//                 map.put(i,cur);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//             else map.put(i,cur);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         max = Math.max(max,map.size());</span><span class="hljs-comment">//         return max;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">int</span> j = map.getOrDefault(s.charAt(i), -<span class="hljs-number">1</span>);            map.put(s.charAt(i),i);            tmp = tmp&lt;i-j?tmp+<span class="hljs-number">1</span>:i-j;            res = Math.max(res,tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></h3><p>东子哥说的动规没想出来，用栈也做错了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        stack.push(-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'('</span>) stack.push(i);            <span class="hljs-keyword">else</span> &#123;                stack.pop();                <span class="hljs-keyword">if</span>(stack.isEmpty()) stack.push(i);                <span class="hljs-keyword">else</span> max = Math.max(max,i-stack.peek());            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h3><p>想象因数分解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h3><p>和之前的正则表达式匹配几乎一模一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=s.length(), m=p.length();        <span class="hljs-keyword">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) f[i][j] = i==<span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">'*'</span>) &#123;                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">1</span>)==s.charAt(i-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">'?'</span>))                            f[i][j] = f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) f[i][j] = f[i][j-<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span>) f[i][j] |= f[i-<span class="hljs-number">1</span>][j];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-1至7-5做题记录&quot;&gt;&lt;a href=&quot;#7-1至7-5做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.1至7.5做题记录&quot;&gt;&lt;/a&gt;7.1至7.5做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长重复子数组&quot;&gt;&lt;a href=&quot;#最长重复子数组&quot; c</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>6.25至6.30做题记录</title>
    <link href="http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-30T12:26:40.000Z</published>
    <updated>2020-07-02T03:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-25至6-30做题记录"><a href="#6-25至6-30做题记录" class="headerlink" title="6.25至6.30做题记录"></a>6.25至6.30做题记录</h1><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p>未排序的数组中找元素，不需要把整个数组实现排序，又快排找位置的思想最快，堆排序也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">return</span> quicksort(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>, nums.length-k);        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> q = randompartition(a,l,r);        <span class="hljs-keyword">if</span>(q == index) <span class="hljs-keyword">return</span> a[q];        <span class="hljs-keyword">return</span> q&gt;index?quicksort(a,l,q-<span class="hljs-number">1</span>,index):quicksort(a,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(a,i,r);        <span class="hljs-keyword">return</span> partition(a,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(a[j] &lt;= a[r])                swap(a,j,++i);        &#125;        swap(a,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=a[i];        a[i]=a[j];        a[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的K个数</a></h3><p>这一题和上一题几乎一样，注意找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN) 的排序，用快排就可以解决topK问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(arr.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> quicksort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] quicksort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index) &#123;        <span class="hljs-keyword">int</span> q = randompartition(arr,l,r);        <span class="hljs-keyword">if</span>(q==index) <span class="hljs-keyword">return</span> Arrays.copyOf(arr, q + <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> q&gt;index?quicksort(arr,l,q-<span class="hljs-number">1</span>,index):quicksort(arr,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(arr,i,r);        <span class="hljs-keyword">return</span> partition(arr,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[r])                swap(arr,j,++i);        &#125;        swap(arr,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=arr[i];        arr[i]=arr[j];        arr[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h3><p>一开始是用队列做的，其实不需要这么麻烦，用双指针可以节省空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (end &lt; n) &#123;            sum += nums[end];            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;                ans = Math.min(ans, end - start + <span class="hljs-number">1</span>);                sum -= nums[start];                start++;            &#125;            end++;        &#125;        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;    &#125;&#125;</code></pre></div><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h3><p>自己用链表实现的，每次插入时插到合适的位置，找中位数时遍历去找，看了大佬的代码发现其实用堆做是最优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> odd = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span>&#123;        <span class="hljs-keyword">int</span> val;        node next;        node(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;    &#125;    node head;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        head=<span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        len++;        odd=!odd;        node n = <span class="hljs-keyword">new</span> node(num);        n.next=<span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) head = n;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(num&lt;head.val) &#123;                n.next=head;                head=n;                <span class="hljs-keyword">return</span> ;            &#125;            node cur=head;            <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-keyword">null</span> &amp;&amp; cur.next.val&lt;num) cur=cur.next;            n.next=cur.next;            cur.next=n;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(odd) &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> cur.val;        &#125;        <span class="hljs-keyword">else</span> &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(cur.val+cur.next.val)/<span class="hljs-number">2</span>;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><span class="hljs-comment"> * obj.addNum(num);</span><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><span class="hljs-comment"> */</span><span class="hljs-comment">// class MedianFinder &#123;</span><span class="hljs-comment">//     Queue&lt;Integer&gt; A, B;</span><span class="hljs-comment">//     public MedianFinder() &#123;</span><span class="hljs-comment">//         A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半</span><span class="hljs-comment">//         B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public void addNum(int num) &#123;</span><span class="hljs-comment">//         if(A.size() != B.size()) &#123;</span><span class="hljs-comment">//             A.add(num);</span><span class="hljs-comment">//             B.add(A.poll());</span><span class="hljs-comment">//         &#125; else &#123;</span><span class="hljs-comment">//             B.add(num);</span><span class="hljs-comment">//             A.add(B.poll());</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public double findMedian() &#123;</span><span class="hljs-comment">//         return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span></code></pre></div><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h3><p>O(n)解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> pre=nums[<span class="hljs-number">0</span>], cur=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            cur=nums[i]&gt;nums[i]+pre?nums[i]:nums[i]+pre;            max=Math.max(cur,max);            pre=cur;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p>这题是真蒙的，居然和题解一样。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)            res[i] = res[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nums.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            res[i] = res[i]*r;            r=r*nums[i];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h3><p>和之前K神写的一个状态转换的题很像，都是一样的递归，一样的剪枝。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();    <span class="hljs-keyword">char</span>[] c;    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        c=s.toCharArray();        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == c.length - <span class="hljs-number">1</span>) &#123;            res.add(String.valueOf(c)); <span class="hljs-comment">// 添加排列方案</span>            <span class="hljs-keyword">return</span>;        &#125;        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;c.length;i++) &#123;            <span class="hljs-keyword">if</span>(set.contains(c[i])) <span class="hljs-keyword">continue</span>;            set.add(c[i]);            swap(i,x);            dfs(x+<span class="hljs-number">1</span>);            swap(i,x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">char</span> tmp = c[a];        c[a] = c[b];        c[b] = tmp;    &#125;&#125;</code></pre></div><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></h3><p>题目要求时间复杂度O(n)，并且使用常数级别空间，这种要求很刁钻的题目，就要让原有的nums数组承担比原本负责记录数据更多的内容，也就是它的下标也要赋予含义，用来记录某种状态</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                <span class="hljs-comment">// 满足在指定范围内、并且没有放在正确的位置上，才交换</span>                <span class="hljs-comment">// 例如：数值 3 应该放在索引 2 的位置上</span>                swap(nums, nums[i] - <span class="hljs-number">1</span>, i);            &#125;        &#125;        <span class="hljs-comment">// [1, -1, 3, 4]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 都正确则返回数组长度 + 1</span>        <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    &#125;&#125;</code></pre></div><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h3><p><strong>摩尔投票法：</strong> 核心理念为 <strong>“正负抵消”</strong> ；时间和空间复杂度分别为 O(N)和 O(1)；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> votes=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;            <span class="hljs-keyword">if</span>(votes==<span class="hljs-number">0</span>) x=num;            votes += x==num?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-25至6-30做题记录&quot;&gt;&lt;a href=&quot;#6-25至6-30做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.25至6.30做题记录&quot;&gt;&lt;/a&gt;6.25至6.30做题记录&lt;/h1&gt;&lt;h3 id=&quot;数组中的第K个最大元素&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS中的变量类型与强制转换</title>
    <link href="http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-06-30T12:18:08.000Z</published>
    <updated>2020-06-30T14:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS中的变量类型与强制转换"><a href="#JS中的变量类型与强制转换" class="headerlink" title="JS中的变量类型与强制转换"></a>JS中的变量类型与强制转换</h1><p>JS中一共有六种数据类型：</p><p>String 字符串    Number 数值    Boolean 布尔值    Null 空值    Undefined 未定义    Object 对象</p><p>其中，前五个都属于基本数据类型，而Object属于引用数据类型。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"abc"</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//string</span>a = <span class="hljs-string">"这是一个双引号 \""</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个换行符 \n"</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个制表符 \t"</span>;<span class="hljs-built_in">console</span>.log(a);</code></pre></div><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span> * <span class="hljs-string">"def"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN Not a Number</span>a = <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//NaN也是number类型</span>a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0.30000000000000004 JS中浮点类型并不精确</span>a = <span class="hljs-built_in">Number</span>.MAX_VALUE+<span class="hljs-built_in">Number</span>.MAX_VALUE;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//Infinity表示超过了number的最大表示范围</span>a = <span class="hljs-literal">Infinity</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//Infinity也是number类型</span></code></pre></div><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>布尔值只有true和false两个值。</p><h3 id="Null和Undefined类型"><a href="#Null和Undefined类型" class="headerlink" title="Null和Undefined类型"></a>Null和Undefined类型</h3><p>null专门用来表示一个空的对象，所以它的类型不是Null。undefined只用来表示声明的未定义的变量。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//Object</span><span class="hljs-keyword">var</span> b;<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//Undefined</span></code></pre></div><h3 id="强制转换为String类型"><a href="#强制转换为String类型" class="headerlink" title="强制转换为String类型"></a>强制转换为String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//调用被转数据类型的toString()方法，但不会改变原数据的类型，注意Null和Undefined是没有toString()方法的</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-keyword">var</span> b = a.toString(); <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;b = a.toString(); <span class="hljs-comment">//无效</span>a = <span class="hljs-literal">undefined</span>;b = a.toString(); <span class="hljs-comment">//无效</span><span class="hljs-comment">//调用String()函数,将转换变量作为参数传入，对于Number和Boolean实际还是调用toString()，但对null和undefined可以转为字符串</span>a = <span class="hljs-number">123</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//null</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span></code></pre></div><h3 id="强制转换为Number类型"><a href="#强制转换为Number类型" class="headerlink" title="强制转换为Number类型"></a>强制转换为Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用Number()函数</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span>; <span class="hljs-comment">//abc不能转换为数字</span>a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"  "</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//如果字符串是空串或者全是空格就会转为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-literal">true</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值真为1</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//1</span>a = <span class="hljs-literal">false</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值假为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//null转为数字就是0</span><span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined只能转为NaN</span><span class="hljs-comment">// 专门负责字符串的转换:parseInt()--字符串转整数 parseFloat()字符串转浮点数</span>a = <span class="hljs-string">"123xp"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123 parseInt()将字符串中有效的数字部分取出转为int</span>a = <span class="hljs-string">"123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span>a = <span class="hljs-string">"gg123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-comment">//对于非string类型的变量如a=true，会先转为字符串“true”，再作为参数，所以返回是NaN</span></code></pre></div><h3 id="强制转换为布尔类型"><a href="#强制转换为布尔类型" class="headerlink" title="强制转换为布尔类型"></a>强制转换为布尔类型</h3><p>对于数字转布尔，除了0和NaN为false，其它值都是true。</p><p>对于字符串转布尔，除了空串为false，其余都是true，包括空格串。</p><p>Null转布尔是false。</p><p>Undefined转布尔是false。</p><h3 id="使用算术运算符转换数据类型"><a href="#使用算术运算符转换数据类型" class="headerlink" title="使用算术运算符转换数据类型"></a>使用算术运算符转换数据类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 对非Number类型的数据运算（加法对字符串有特殊）时，会将其先转为Number再运算，所以对直接a-0可以转number</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span> - <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = +<span class="hljs-string">"123"</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number 正负号直接将数据转为Number</span>a = <span class="hljs-number">1</span> + <span class="hljs-literal">true</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = a + <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN 任何值与NaN运算都是NaN</span><span class="hljs-comment">// 两个字符串相加不是Number，而是拼接字符串，注意只有加法！！</span>a = <span class="hljs-string">"123"</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 123456</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span><span class="hljs-comment">// 任何值与字符串相加都是先转为字符串，然后拼串</span>a = <span class="hljs-number">123</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123456</span><span class="hljs-comment">// 所以对数据直接加一个“”空串可以转为字符串</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;a href=&quot;#JS中的变量类型与强制转换&quot; class=&quot;headerlink&quot; title=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;/a&gt;JS中的变量类型与强制转换&lt;/h1&gt;&lt;p&gt;JS中一共有六种数据类型：&lt;/p&gt;
&lt;p&gt;Strin</summary>
      
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>6.15至6.24做题记录</title>
    <link href="http://yoursite.com/2020/06/24/6.15%E8%87%B36.24%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/24/6.15%E8%87%B36.24%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-24T07:26:40.000Z</published>
    <updated>2020-06-24T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-15至6-24做题记录"><a href="#6-15至6-24做题记录" class="headerlink" title="6.15至6.24做题记录"></a>6.15至6.24做题记录</h1><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h3><p>二叉树的递归问题最重要的就是分析好递归的终止条件，题解中recur函数判断以A为根节点的树是否包含B树，也就是说如果A，B节点值不等则只有可能是A的左子树或右子树包含B，如果节点值相等就继续向下判断——A的左子树包含B的左子树，A右包含B右，直到B为空。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">return</span> (A!=<span class="hljs-keyword">null</span> &amp;&amp; B!=<span class="hljs-keyword">null</span> &amp;&amp; (judge(A,B) || isSubStructure(A.left,B) ||                 isSubStructure(A.right,B)));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode a, TreeNode b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(b==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(a==<span class="hljs-keyword">null</span> || a.val!=b.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> judge(a.left,b.left) &amp;&amp; judge(a.right,b.right);    &#125;&#125;</code></pre></div><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h3><p>这道题的题解是用辅助栈，数据栈存要求的数据，辅助栈存最小值，只有比栈顶小时才入栈(等于时也要入栈，因为出栈判断是只要值相等就出栈)，我的思路是自己建立链表节点，节点中用pre_min记录在它之前的有最小值的节点是哪个，如果他自己最小就指向他自己，这样出栈后只要查找当前栈顶的pre_min指向就可以了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack_node</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        stack_node pre;        stack_node next;        stack_node pre_min;        stack_node(<span class="hljs-keyword">int</span> x) &#123;val=x;&#125;    &#125;    <span class="hljs-keyword">int</span> min=Integer.MAX_VALUE;    stack_node bottom;    stack_node cur;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        bottom = <span class="hljs-keyword">new</span> stack_node(Integer.MAX_VALUE);        cur=bottom;        cur.pre_min=cur;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        stack_node push = <span class="hljs-keyword">new</span> stack_node(x);        push.pre=cur;        cur.next=push;        <span class="hljs-keyword">if</span>(x&lt;min) &#123;            min = x;            push.pre_min=push;        &#125;        <span class="hljs-keyword">else</span>            push.pre_min=cur.pre_min;        cur=push;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        cur=cur.pre;        min=cur.pre_min.val;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cur.val;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化和反序列化</a></h3><p>题目要求是“不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。”这道题的序列化不难，最好选择先序遍历这样重构树的时候比较方便，递归遍历树然后把值一个个加到string里，注意空节点的录入以及节点之间的分割。</p><p>反序列化时用刚才的分割字符转为string数组，再转为list，将list作为参数传入递归，每次用掉一个节点就remove一个节点，然后将list传入递归左子树，然后是右子树。当list的首位给的值代表null就说明这个小子树构建完了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-comment">// Encodes a tree to a single string.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">my_serialize</span><span class="hljs-params">(TreeNode root, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> str+=<span class="hljs-string">"None,"</span>;        str+=String.valueOf(root.val)+<span class="hljs-string">","</span>;        str=my_serialize(root.left,str);        str=my_serialize(root.right,str);        <span class="hljs-keyword">return</span> str;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> my_serialize(root,<span class="hljs-string">""</span>);    &#125;    <span class="hljs-comment">// Decodes your encoded data to tree.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">my_deserialize</span><span class="hljs-params">(List&lt;String&gt; data_list)</span> </span>&#123;        <span class="hljs-keyword">if</span>(data_list.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">"None"</span>)) &#123;            data_list.remove(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        TreeNode root=<span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(data_list.get(<span class="hljs-number">0</span>)));        data_list.remove(<span class="hljs-number">0</span>);        root.left=my_deserialize(data_list);        root.right=my_deserialize(data_list);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        String[] sp_data=data.split(<span class="hljs-string">","</span>);        List&lt;String&gt; data_list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(sp_data));        <span class="hljs-keyword">return</span> my_deserialize(data_list);    &#125;&#125;<span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><span class="hljs-comment">// Codec codec = new Codec();</span><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span></code></pre></div><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h3><p>直接建栈模拟就行，遇到错就返回false，这居然是中等题…..</p><h3 id="最佳观光组合"><a href="#最佳观光组合" class="headerlink" title="最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">最佳观光组合</a></h3><p>一道动规题，遍历一次，记录每个点和它之前的某个点的评分最大值，仔细观察可发现，若i与j组合最大，到j的下一个点k时，要么k与j组合更大，要么k与i组合更大，不可能是k之前的其他元素了，因为如果有m能使k与m的组合更大的话，那么j当初也应该与m组合而不是与i组合，其实光看计算公式就是这个道理：A[i]+i+A[j]-j，对点j来说，A[j]-j是固定值，只要找到j之前的一个i使A[i]+i最大就行，而这样的i找到了就是固定的不会变</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur,pre=A[<span class="hljs-number">0</span>],max=A[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;A.length;i++) &#123;            cur=Math.max(A[i]+A[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>,A[i]+pre-A[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(cur&gt;max) max=cur;            pre=cur;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="从上到下打印二叉树3"><a href="#从上到下打印二叉树3" class="headerlink" title="从上到下打印二叉树3"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树3</a></h3><p>与这个系列的前两题不同在于要“之”字输出，也就是要考虑层数</p><p>我的代码复杂再居然又建了一个栈，其实一个队列就可以，因为java里那个队列是双端队列正反插都可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 -&gt; 队列头部</span>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 -&gt; 队列尾部</span>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="从先序遍历还原二叉树"><a href="#从先序遍历还原二叉树" class="headerlink" title="从先序遍历还原二叉树"></a><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/" target="_blank" rel="noopener">从先序遍历还原二叉树</a></h3><p>题解用栈保存要回溯的状态，参数是一个字符串，作为S之后出现的T字符，它要么是S的左子树的根节点，要么就是S的某个祖先的右子树的根节点，这要看T前有几个“-”来判断，定义“-”的个数是level，则当level与栈的大小+1相等时就表明T就是S的左子树，否则栈内元素不停出栈直到满足条件，每次新建节点最后都入栈。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">recoverFromPreorder</span><span class="hljs-params">(String S)</span> </span>&#123;        Deque&lt;TreeNode&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (pos &lt; S.length()) &#123;            <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (S.charAt(pos) == <span class="hljs-string">'-'</span>) &#123;                ++level;                ++pos;            &#125;            <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (pos &lt; S.length() &amp;&amp; Character.isDigit(S.charAt(pos))) &#123;                value = value * <span class="hljs-number">10</span> + (S.charAt(pos) - <span class="hljs-string">'0'</span>);                ++pos;            &#125;            TreeNode node = <span class="hljs-keyword">new</span> TreeNode(value);            <span class="hljs-keyword">if</span> (level == path.size()) &#123;                <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;                    path.peek().left = node;                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">while</span> (level != path.size()) &#123;                    path.pop();                &#125;                path.peek().right = node;            &#125;            path.push(node);        &#125;        <span class="hljs-keyword">while</span> (path.size() &gt; <span class="hljs-number">1</span>) &#123;            path.pop();        &#125;        <span class="hljs-keyword">return</span> path.peek();    &#125;&#125;</code></pre></div><h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h3><p>后序遍历，所以数组末尾是根节点，作为分割点，从前往后找属于左子树和右子树的部分，看是否满足规则，把分好的索引放入递归处理</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        <span class="hljs-keyword">return</span> recur(postorder,<span class="hljs-number">0</span>,postorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> split=i;        <span class="hljs-keyword">while</span>(postorder[split]&lt;postorder[j]) split++;        <span class="hljs-keyword">int</span> max=split;        <span class="hljs-keyword">while</span>(postorder[max]&gt;postorder[j]) max++;        <span class="hljs-keyword">return</span> max==j &amp;&amp; recur(postorder,i,split-<span class="hljs-number">1</span>) &amp;&amp; recur(postorder,split,max-<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h3><p>递归判断，用一个栈保存已经走过的路径，如果路不通将栈顶remove，如示例中的树，传入参数可以是左子树，tar为22-5=17，和右子树，tar也是17，找到当前节点无左右子树且等于tar，加入path，并将path拷贝一份到res中，继续递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;        recur(root, sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        path.add(root.val);        tar -= root.val;        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            res.add(<span class="hljs-keyword">new</span> LinkedList(path));        recur(root.left, tar);        recur(root.right, tar);        path.removeLast();    &#125;&#125;</code></pre></div><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></h3><p>这题我做的太复杂了，递归很多导致时间复杂度高，实际上当遇到计算自己子树的值为负数时，直接将这个子树的值设为0就可以</p><p>我的代码里recurMaxEdge找到当前节点能连接的最大的一条边，recurMaxRoot找到通过当前节点路径的最大值，最后findmax递归遍历</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> max=Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        findmax(root);        <span class="hljs-keyword">return</span> max;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recurMaxEdge</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> Math.max(root.val,(root.val+Math.max(recurMaxEdge(root.left),recurMaxEdge(root.right))));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recurMaxRoot</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> a=root.val,b=recurMaxEdge(root.left),c=recurMaxEdge(root.right);        <span class="hljs-keyword">return</span> Math.max(a,Math.max(Math.max(a+b,a+c),a+b+c));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findmax</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> cur=recurMaxRoot(root);        <span class="hljs-keyword">if</span>(max&lt;cur) max=cur;        findmax(root.left);        findmax(root.right);    &#125;&#125;</code></pre></div><p>复杂的原因就是不确定一个节点加上它左子树节点给它的那个“最大值”是正是负，所以加了很多没用的判断和递归，实际上对每个节点提供最大值计算时如果结果是负数，那它就是0，因为没人会加上负数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> maxSum = Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        maxGain(root);        <span class="hljs-keyword">return</span> maxSum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;                <span class="hljs-comment">// 递归计算左右子节点的最大贡献值</span>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span>        <span class="hljs-keyword">int</span> leftGain = Math.max(maxGain(node.left), <span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> rightGain = Math.max(maxGain(node.right), <span class="hljs-number">0</span>);        <span class="hljs-comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span>        <span class="hljs-keyword">int</span> priceNewpath = node.val + leftGain + rightGain;        <span class="hljs-comment">// 更新答案</span>        maxSum = Math.max(maxSum, priceNewpath);        <span class="hljs-comment">// 返回节点的最大贡献值</span>        <span class="hljs-keyword">return</span> node.val + Math.max(leftGain, rightGain);    &#125;&#125;</code></pre></div><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>这题很秀，用hashmap做可以，也可以直接复制！！深拷贝和浅拷贝的区别就是这个</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    Node next;</span><span class="hljs-comment">    Node random;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int val) &#123;</span><span class="hljs-comment">        this.val = val;</span><span class="hljs-comment">        this.next = null;</span><span class="hljs-comment">        this.random = null;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;        HashMap&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//创建HashMap集合</span>        Node cur=head;        <span class="hljs-comment">//复制结点值</span>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//存储put:&lt;key,value1&gt;</span>            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val)); <span class="hljs-comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span>            cur=cur.next;        &#125;        <span class="hljs-comment">//复制结点指向</span>        cur = head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//得到get:&lt;key&gt;.value2,3</span>            map.get(cur).next = map.get(cur.next); <span class="hljs-comment">//新结点next指向同旧结点的next指向</span>            map.get(cur).random = map.get(cur.random); <span class="hljs-comment">//新结点random指向同旧结点的random指向</span>            cur = cur.next;        &#125;        <span class="hljs-comment">//返回复制的链表</span>        <span class="hljs-keyword">return</span> map.get(head);    &#125;&#125;</code></pre></div><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h3><p>和三数之和一个思路</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,cur=Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> left=i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right=nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(left&lt;right) &#123;                <span class="hljs-keyword">int</span> sum=nums[i]+nums[left]+nums[right];                <span class="hljs-comment">// while(left&lt;right &amp;&amp; nums[left]==nums[left+1]) left++;</span>                <span class="hljs-comment">// while(left&lt;right &amp;&amp; nums[right]==nums[right-1]) right--; </span>                <span class="hljs-keyword">if</span>(cur&gt;Math.abs(sum-target)) &#123;                    cur=Math.abs(sum-target);                    res=sum;                &#125;                <span class="hljs-keyword">if</span>(sum &lt; target) left++;                <span class="hljs-keyword">if</span>(sum &gt; target) right--;                <span class="hljs-keyword">if</span>(sum == target) <span class="hljs-keyword">return</span> res;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h3><p>二叉搜索树的中序遍历是递增排列！所以根据这个建立链表</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">    public int val;</span><span class="hljs-comment">    public Node left;</span><span class="hljs-comment">    public Node right;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        left = _left;</span><span class="hljs-comment">        right = _right;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Node head,pre;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        dfs(root);        head.left=pre;        pre.right=head;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(cur.left);        <span class="hljs-keyword">if</span>(pre==<span class="hljs-keyword">null</span>) head=cur;        <span class="hljs-keyword">else</span> pre.right=cur;        cur.left=pre;        pre=cur;        dfs(cur.right);     &#125;&#125;</code></pre></div><p>最近因为考试，很久都没有记录题目，晚上总结一下前端CSS的一些内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-15至6-24做题记录&quot;&gt;&lt;a href=&quot;#6-15至6-24做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.15至6.24做题记录&quot;&gt;&lt;/a&gt;6.15至6.24做题记录&lt;/h1&gt;&lt;h3 id=&quot;树的子结构&quot;&gt;&lt;a href=&quot;#树的子结</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>6.10至6.14做题记录</title>
    <link href="http://yoursite.com/2020/06/14/6.10%E8%87%B36.14%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/14/6.10%E8%87%B36.14%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-14T08:15:43.000Z</published>
    <updated>2020-06-14T13:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-10至6-14做题记录"><a href="#6-10至6-14做题记录" class="headerlink" title="6.10至6.14做题记录"></a>6.10至6.14做题记录</h1><h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h3><p>当n不大时当然很好做，如果n非常大需要使用string来表示大数</p><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h3><p>做了这个题才意识到自己有多笨比</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] out=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;Integer&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;T.length;i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i]&gt;T[stack.peek()]) &#123;                out[stack.peek()]=i-stack.peek();                stack.pop();            &#125;            stack.push(i);        &#125;        <span class="hljs-keyword">return</span> out;    &#125;&#125;</code></pre></div><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h3><p>这其实应该和第一题两数之和是一个系列的，两数之和很好做，遍历一次就能得到输出。但这个还不允许输出重复的三元组，而且像这种数组题，遇事不决可先排序。排序之后先固定一个数，那么剩余的两个数分布左右，此时可以根据三数之和与要求的sum之间的差判断分布左右的两个数的移动方式(没错就是因为现在是排好序的数组！！)</p><p>而且在移动过程中完成去除重复的操作，因为固定两个数字后第三个数怎么也不会变，所以直接略过这组数字即可。</p><p>看的题解写的，就不贴自己的代码了，害！<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">灵魂画手</a></p><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">表示数值的字符串</a></h3><p>只怪自己编译原理没好好学！但其实测试用例给的很奇怪，这题.1也算数字的，”   .2e23   “这种也算….</p><h3 id="转变数组后最接近目标值的数组和"><a href="#转变数组后最接近目标值的数组和" class="headerlink" title="转变数组后最接近目标值的数组和"></a><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">转变数组后最接近目标值的数组和</a></h3><p>遇事不决就先排序！这题官解给的是二分，感觉更好一些，当数组长度很长时时间复杂度会比较低，下面代码思路是先排个序，然后从第一个元素开始累加，每次累加后计算目标值减去累加和，除以剩下数字个数得到的平均值avg，等到遇到数字大于他那波计算出的avg，说明此时从他开始往后的数字都可以按规则变成avg，返回avg即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        Arrays.sort(arr);        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> avg=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;            avg=(target-sum)/(arr.length-i);            <span class="hljs-keyword">if</span>(arr[i]&gt;=avg) &#123;                <span class="hljs-keyword">double</span> avgd=(<span class="hljs-keyword">double</span>)(target-sum)/(arr.length-i);                <span class="hljs-keyword">if</span>(avgd-avg&gt;<span class="hljs-number">0.5</span>)                    <span class="hljs-keyword">return</span> avg+<span class="hljs-number">1</span>;                <span class="hljs-keyword">return</span> avg;            &#125;            sum+=arr[i];        &#125;        <span class="hljs-keyword">return</span> arr[arr.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><p>官解的意思是排序之后，对于可能可以作为输入的每个value，二分查找这个value的下标，计算和，比较。</p><p>或者是排序后，将value的上下两个边界值也作为二分条件，找mid。</p><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h3><p>目前除了6.6-6.9中出现过的单词接龙以外最难的hard题目，想暴力基本不可能。</p><p><strong><em>做了这个题有两点感悟：这也要动态规划，这也能动态规划？！</em></strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=s.length();        <span class="hljs-keyword">int</span> m=p.length();        <span class="hljs-keyword">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) &#123;                    f[i][j]= i==<span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>)!=<span class="hljs-string">'*'</span>) &#123;                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">'.'</span>))                            f[i][j]=f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">2</span>)                            f[i][j] |= f[i][j-<span class="hljs-number">2</span>];                        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>)==<span class="hljs-string">'.'</span>))                            f[i][j] |= f[i-<span class="hljs-number">1</span>][j];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div><p>还做了一些链表的题，很明显手生了，但都是简单题目，所以不打算全部放在博客上了，这边只记录一些有价值有思考的题目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-10至6-14做题记录&quot;&gt;&lt;a href=&quot;#6-10至6-14做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.10至6.14做题记录&quot;&gt;&lt;/a&gt;6.10至6.14做题记录&lt;/h1&gt;&lt;h3 id=&quot;打印从1到最大的n位数&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>6.6至6.9做题记录</title>
    <link href="http://yoursite.com/2020/06/09/6.6%E8%87%B36.9%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/09/6.6%E8%87%B36.9%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-09T08:18:29.000Z</published>
    <updated>2020-07-06T02:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-6至6-9做题记录"><a href="#6-6至6-9做题记录" class="headerlink" title="6.6至6.9做题记录"></a>6.6至6.9做题记录</h1><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">机器人的运动范围</a></h3><p>这题我自己用的是DFS，开始没想起来BFS怎么做的，想的是用递归做BFS，看了题解老哥BFS恍然大悟，复习时重写一定用BFS写，下面是DFS代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">boolean</span>[][] im = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">return</span> dfs(m,n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,k,im);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">boolean</span>[][] im)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i&gt;=m || j&gt;=n || im[i][j] || calu(i,j)&gt;k)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        im[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(m,n,i+<span class="hljs-number">1</span>,j,k,im) + dfs(m,n,i,j+<span class="hljs-number">1</span>,k,im);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) &#123;            x+=i%<span class="hljs-number">10</span>;            i=i/<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>) &#123;            x+=j%<span class="hljs-number">10</span>;            j=j/<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre></div><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">最长连续序列</a></h3><p>官方题解有Hashset做的，我这个用Hashmap做的又复杂又慢，几十倍的时间消耗，复习重写要用官解写法，另外这是第一道没看题解一边通过的困难级题目，mark一下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;Integer,Integer&gt; map;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> max = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++) &#123;            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))                <span class="hljs-keyword">continue</span>;            map.put(nums[i],<span class="hljs-number">1</span>);            update(nums[i]);            <span class="hljs-keyword">if</span>(max&lt;map.get(nums[i]))                max = map.get(nums[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">int</span> k = num;        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(map.containsKey(num-<span class="hljs-number">1</span>) &amp;&amp; map.containsKey(num+<span class="hljs-number">1</span>)) &#123;            len = map.get(num-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>+map.get(num+<span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span>(map.containsKey(k)) &#123;                map.put(k,len);                k--;            &#125;            k = num;            <span class="hljs-keyword">while</span>(map.containsKey(k)) &#123;                map.put(k,len);                k++;            &#125;        &#125;        <span class="hljs-keyword">if</span>(map.containsKey(num-<span class="hljs-number">1</span>)) &#123;            len = map.get(num-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(map.containsKey(k)) &#123;                map.put(k,len);                k--;            &#125;        &#125;        <span class="hljs-keyword">if</span>(map.containsKey(num+<span class="hljs-number">1</span>)) &#123;            len = map.get(num+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(map.containsKey(k)) &#123;                map.put(k,len);                k++;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a></h3><p>自己是用最普通的动态规划做的，事实上看了题解才想到可以类似与斐波那契数列那样不用数组，空间压缩只使用两个变量交替前行。另外也可以将每次前进分而治之，使用递归求解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(num/<span class="hljs-number">10</span> == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        String res = Integer.toString(num);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.length()];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(cal(res.charAt(<span class="hljs-number">0</span>),res.charAt(<span class="hljs-number">1</span>)) &lt;= <span class="hljs-number">25</span>)            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">else</span>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;res.length();i++) &#123;            <span class="hljs-keyword">if</span>((cal(res.charAt(i-<span class="hljs-number">1</span>),res.charAt(i)) &lt;= <span class="hljs-number">25</span>) &amp;&amp;                (cal(res.charAt(i-<span class="hljs-number">1</span>),res.charAt(i)) &gt;= <span class="hljs-number">10</span>))                dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];            <span class="hljs-keyword">else</span>                dp[i] = dp[i-<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> dp[res.length()-<span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a,<span class="hljs-keyword">char</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> num1 = a-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">int</span> num2 = b-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">return</span> num1*<span class="hljs-number">10</span>+num2;    &#125;&#125;</code></pre></div><h3 id="单词接龙2"><a href="#单词接龙2" class="headerlink" title="单词接龙2"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">单词接龙2</a></h3><p>这一题hard，我是根本没写出来的。tips：其实如果大二数据结构好好学的话应该是有思路的，但有思路也很难手敲！！！</p><h3 id="等式方程的可满足性"><a href="#等式方程的可满足性" class="headerlink" title="等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">等式方程的可满足性</a></h3><p>中等题目，连着两天每天一道也不会都看题解。。。刚学习了并查集，注意最好给并查集加rank记录树高用来优化合并。</p><h3 id="剪绳子2"><a href="#剪绳子2" class="headerlink" title="剪绳子2"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剪绳子2</a></h3><p>上一道题剪绳子1和这个其实很像，只不过这一题需要多考虑乘积会溢出的问题所以需要取模，另外如何能加速计算？加速取模呢？</p><p>并且类似的这种题目是如何找到最优解的呢？贪心到底是什么？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b=n%<span class="hljs-number">3</span>,p=<span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">long</span> rem=<span class="hljs-number">1</span>,x=<span class="hljs-number">3</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=n/<span class="hljs-number">3</span>-<span class="hljs-number">1</span>;a&gt;<span class="hljs-number">0</span>;a/=<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(a%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)                rem = (rem*x)%p;            x = (x*x)%p;        &#125;        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);    &#125;&#125;</code></pre></div><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h3><p>与上一题一样思考如何快速求幂，发现自己对二进制的位操作以及类型的边界值不是很了解，另外自己的代码写的太冗余了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;        <span class="hljs-keyword">double</span> res=<span class="hljs-number">1.0</span>;        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">long</span> b=n;            b = -b;            x = <span class="hljs-number">1</span>/x;            <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                    x *= x;                    b /= <span class="hljs-number">2</span>;                &#125;                <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                    res*=x;                    x *= x;                    b=(b-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                x *= x;                n /= <span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                res*=x;                x *= x;                n=(n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h3><p>上一题提到的对二进制的位操作与十进制的联系很不熟悉，导致自己的代码看起来很蠢。</p><p>贴一个之前那个天秀老哥的题解链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">// you need to treat n as an unsigned value</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        String result = Integer.toBinaryString(n);        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;result.length();i++) &#123;            <span class="hljs-keyword">if</span>(result.charAt(i) == <span class="hljs-string">'1'</span>)                num++;        &#125;        <span class="hljs-keyword">return</span> num;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-6至6-9做题记录&quot;&gt;&lt;a href=&quot;#6-6至6-9做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.6至6.9做题记录&quot;&gt;&lt;/a&gt;6.6至6.9做题记录&lt;/h1&gt;&lt;h3 id=&quot;机器人的运动范围&quot;&gt;&lt;a href=&quot;#机器人的运动范围&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>6.1至6.5做题记录</title>
    <link href="http://yoursite.com/2020/06/05/6.1%E8%87%B36.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/05/6.1%E8%87%B36.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-05T06:29:10.000Z</published>
    <updated>2020-07-06T02:16:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1至6-5做题记录"><a href="#6-1至6-5做题记录" class="headerlink" title="6.1至6.5做题记录"></a>6.1至6.5做题记录</h1><h3 id="打家劫舍1"><a href="#打家劫舍1" class="headerlink" title="打家劫舍1"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍1</a></h3><p>与官方题解不同，我将dp数组中的每一个数定义为如果一定要偷这家所能得到的最大金额，这样从第四家开始之后的每一家，例如第n家，dp[n]只与n-2、n-3位置保存的金额数有关，用一个max变量记录最大金额，最后返回即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;                max = Math.max(max,nums[i]);            &#125;            <span class="hljs-keyword">return</span> max;        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];        dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">0</span>];        max = Math.max(dp[<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>]);        max = Math.max(max, dp[<span class="hljs-number">2</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;nums.length;i++) &#123;            dp[i] = Math.max(dp[i-<span class="hljs-number">3</span>]+nums[i],dp[i-<span class="hljs-number">2</span>]+nums[i]);            max = Math.max(max,dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶</a></h3><p>这个题其实和斐波那契数列很像，用上面一题中动态规划的思路就可以解决，重点是找好数组保存的是什么状态，状态如何转移，想明白这两个问题就很容易写。</p><p>我个人的方法是使用递归，但会发现空间占用太大，优化策略是使用hashmap保存每一步计算得到的”新”的状态，这样每次需要计算时先去里面找找看有没有，如果有就不需要重复递归了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;Integer,Integer&gt; map;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">()</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> || n==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(map.containsKey(n)) &#123;            <span class="hljs-keyword">return</span> map.get(n);        &#125;        <span class="hljs-keyword">else</span> &#123;            map.put(n,(numWays(n-<span class="hljs-number">1</span>)+numWays(n-<span class="hljs-number">2</span>))%<span class="hljs-number">1000000007</span>);        &#125;        <span class="hljs-keyword">return</span> map.get(n);    &#125;&#125;</code></pre></div><h3 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组的查找</a></h3><p>这个题其实就是一棵树上的查找，想明白root节点在哪很容易做</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;        j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) &#123;                i++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) &#123;                j--;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(matrix[i][j] == target)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h3><p>自己的做法很普通，看map中有没有已保存的key就可以，有个老哥的题解很秀，记录一下：</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/yuan-di-zhi-huan-shi-jian-kong-jian-100-by-derrick/" target="_blank" rel="noopener">原地置换-时间空间100%</a></p><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h3><p>直接按照元素的总个数循环遍历，或者递归，但最重要的是考虑如何进行方向变化的判定与操作。下面使用递归写法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] out = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length*matrix[<span class="hljs-number">0</span>].length];        <span class="hljs-keyword">int</span>[][] im = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length][matrix[<span class="hljs-number">0</span>].length];        find(matrix,out,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,im);        <span class="hljs-keyword">return</span> out;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span>[] out, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> di, <span class="hljs-keyword">int</span>[][] im)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=matrix.length || j&lt;<span class="hljs-number">0</span> || j&gt;=matrix[<span class="hljs-number">0</span>].length || im[i][j]&lt;<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(k == out.length)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        out[k] = matrix[i][j];        im[i][j] = -<span class="hljs-number">1</span>;        k++;        <span class="hljs-keyword">int</span> dx = i + direction[di][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> dy = j + direction[di][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(find(matrix,out,k,dx,dy,di,im))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                di = (di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;        dx = i + direction[di][<span class="hljs-number">0</span>];        dy = j + direction[di][<span class="hljs-number">1</span>];        <span class="hljs-keyword">return</span> find(matrix,out,k,dx,dy,di,im);    &#125;&#125;</code></pre></div><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h3><p>其实从后往前遍历不是不可以，只是时间复杂度较高，看起来不秀，思考使用二分法降低时间复杂度</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-comment">// for(int i=numbers.length-1;i &gt;= 1;i--) &#123;</span>        <span class="hljs-comment">//     if(numbers[i] &lt; numbers[i-1])</span>        <span class="hljs-comment">//         return numbers[i];</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return numbers[0];//遍历的写法</span>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=numbers.length-<span class="hljs-number">1</span>,m=(i+j)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(i!=j) &#123;            <span class="hljs-keyword">if</span>(numbers[m] &lt; numbers[j])                j = m;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[m] &gt; numbers[j])                 i = m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>                j = j-<span class="hljs-number">1</span>;            m = (i+j)/<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> numbers[j];    &#125;&#125;</code></pre></div><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h3><p>大二其实学过的，有了前序遍历和中序遍历，找对root，分割好数组就可以了，官方题解的迭代法好复杂我不想看QAQ…..</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        List&lt;Integer&gt; pre = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : preorder)            pre.add(num);        List&lt;Integer&gt; in = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : inorder)            in.add(num);        <span class="hljs-keyword">return</span> F(pre,in);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">F</span><span class="hljs-params">(List pre, List in)</span> </span>&#123;        <span class="hljs-keyword">if</span>(pre.size() == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode((<span class="hljs-keyword">int</span>)pre.get(<span class="hljs-number">0</span>));        <span class="hljs-keyword">int</span> index = in.indexOf(root.val);        root.left = F(pre.subList(<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>),in.subList(<span class="hljs-number">0</span>,index));        root.right = F(pre.subList(index+<span class="hljs-number">1</span>,pre.size()),in.subList(index+<span class="hljs-number">1</span>,in.size()));        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre></div><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h3><p>从矩阵中找路径，能回溯原来的状态很关键，看了别人的题解，DFS，剪枝，最好自己多敲两边</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] words = word.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++) &#123;                <span class="hljs-keyword">if</span>(dfs(board,words,i,j,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,<span class="hljs-keyword">char</span>[] words,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=board.length || j&lt;<span class="hljs-number">0</span> || j&gt;=board[<span class="hljs-number">0</span>].length || board[i][j]!=words[k])            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(k == words.length-<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">char</span> tmp = board[i][j];        board[i][j] = <span class="hljs-string">'/'</span>;        <span class="hljs-keyword">boolean</span> res = dfs(board,words,i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) || dfs(board,words,i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) ||              dfs(board,words,i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) || dfs(board,words,i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);        board[i][j] = tmp;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-1至6-5做题记录&quot;&gt;&lt;a href=&quot;#6-1至6-5做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.1至6.5做题记录&quot;&gt;&lt;/a&gt;6.1至6.5做题记录&lt;/h1&gt;&lt;h3 id=&quot;打家劫舍1&quot;&gt;&lt;a href=&quot;#打家劫舍1&quot; class</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
