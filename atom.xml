<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pluto</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-22T14:57:23.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>pluto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于CSS预处理与经典布局</title>
    <link href="http://yoursite.com/2021/07/22/%E5%85%B3%E4%BA%8ECSS%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2021/07/22/%E5%85%B3%E4%BA%8ECSS%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80/</id>
    <published>2021-07-22T09:33:16.000Z</published>
    <updated>2021-07-22T14:57:23.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于CSS预处理与经典布局"><a href="#关于CSS预处理与经典布局" class="headerlink" title="关于CSS预处理与经典布局"></a>关于CSS预处理与经典布局</h1><h2 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h2><ul><li>基于CSS的另一种语言</li><li>通过工具编译为CSS</li><li>添加了很多CSS不具备的特性</li><li>主要有less和sass</li></ul><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p>输出CSS：</p><div class="hljs"><pre><code class="hljs javascript">./node_modules/.bin/lessc ./src/index.less &gt; 。/src/index.css</code></pre></div><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-attribute">font-size</span>: medium;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: aqua;        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: medium;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: aqua;&#125;</code></pre></div><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>如果有一段CSS样式需要复用，没有预处理器的做法是给需要这个样式的元素加上相同的class，也就是在HTML中复用。</p><p>如果想在CSS中复用而不增加class可以用mixin（类似一个函数？）：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span>) &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span> &#123;        <span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span>);    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-selector-class">.block</span>(<span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>);        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><p>注意，不加括号的类也可以作为mixin，但加上括号后不会在CSS中编译出来（空括号也可以）</p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p>太多的mixin也会有很多重复代码，可以用extend复用，它能把公共样式提取后整合选择器</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@fontSize:</span> <span class="hljs-number">12px</span>;<span class="hljs-variable">@bgColor:</span> red;<span class="hljs-selector-class">.block</span>&#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">background-color</span>: aliceblue;    <span class="hljs-selector-class">.nav</span><span class="hljs-selector-pseudo">:extend(.block)</span>&#123;        <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;    &#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:extend(.block)</span>;        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;            <span class="hljs-attribute">background-color</span>: lighten(<span class="hljs-variable">@bgColor</span>, <span class="hljs-number">40%</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.block</span>,<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span>,<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">background-color</span>: aliceblue;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.nav</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffcccc</span>;&#125;</code></pre></div><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>用mixin能传参的性质实现，没有循环，实际是用递归实现的：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-class">.gen-col</span>(<span class="hljs-variable">@n</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@n</span> &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-selector-class">.gen-col</span>(<span class="hljs-variable">@n</span> - <span class="hljs-number">1</span>);    <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;n&#125;</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-variable">@n</span>;    &#125;&#125;<span class="hljs-selector-class">.gen-col</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.col-1</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.col-2</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.col-3</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.col-4</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.col-5</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> / <span class="hljs-number">5</span> * <span class="hljs-number">5</span>;&#125;</code></pre></div><h4 id="import-CSS模块化"><a href="#import-CSS模块化" class="headerlink" title="import CSS模块化"></a>import CSS模块化</h4><p>将不同部分的CSS拆分编写，之后统一import进一个文件后编译就能编译到一个大的总集合CSS文件中：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-comment">// variable.less</span><span class="hljs-variable">@themeColor:</span> blue;<span class="hljs-variable">@fontSize:</span> <span class="hljs-number">14px</span>;<span class="hljs-comment">// module1.less</span><span class="hljs-selector-class">.module1</span> &#123;    <span class="hljs-selector-class">.box</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-attribute">color</span>: <span class="hljs-variable">@themeColor</span>;    &#125;    <span class="hljs-selector-class">.tips</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span>;        <span class="hljs-attribute">color</span>: lighten(<span class="hljs-variable">@themeColor</span>, <span class="hljs-number">40%</span>);    &#125;&#125;<span class="hljs-comment">// module2.less</span><span class="hljs-selector-class">.module2</span> &#123;    <span class="hljs-selector-class">.box</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">4px</span>;        <span class="hljs-attribute">color</span>: <span class="hljs-variable">@themeColor</span>;    &#125;    <span class="hljs-selector-class">.tips</span> &#123;        <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@fontSize</span> + <span class="hljs-number">2px</span>;        <span class="hljs-attribute">color</span>: lighten(<span class="hljs-variable">@themeColor</span>, <span class="hljs-number">20%</span>);    &#125;&#125;<span class="hljs-comment">// index.less 依然只用lessc编译这个文件</span><span class="hljs-keyword">@import</span> <span class="hljs-string">"./variable.less"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"./module1.less"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"./module2.less"</span>;<span class="hljs-comment">// CSS</span><span class="hljs-selector-class">.module1</span> <span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-selector-class">.module1</span> <span class="hljs-selector-class">.tips</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccccff</span>;&#125;<span class="hljs-selector-class">.module2</span> <span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-selector-class">.module2</span> <span class="hljs-selector-class">.tips</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#6666ff</span>;&#125;</code></pre></div><p>CSS预处理器还有框架可以用！！</p><h2 id="CSS经典布局"><a href="#CSS经典布局" class="headerlink" title="CSS经典布局"></a>CSS经典布局</h2><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，注意为了保证中间的内容最先被渲染，center的盒子是要放在最上面的！html代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>以下样式全部按照左边定宽100px，中间自适应，右边定宽200px</p><h4 id="绝对定位实现"><a href="#绝对定位实现" class="headerlink" title="绝对定位实现"></a>绝对定位实现</h4><p>左右两栏设置绝对定位，中间设置对应的margin</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;&#125;</code></pre></div><h4 id="flex实现"><a href="#flex实现" class="headerlink" title="flex实现"></a>flex实现</h4><p>左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto</p><div class="hljs"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;    <span class="hljs-attribute">order</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;    <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div><p>记得要加order指定下排列顺序</p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置浮动，两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位到两边。</p><div class="hljs"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">background-color</span>: coral;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">background-color</span>: cornflowerblue;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: right;    <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">background-color</span>: darkgreen;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">float</span>: left;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于CSS预处理与经典布局&quot;&gt;&lt;a href=&quot;#关于CSS预处理与经典布局&quot; class=&quot;headerlink&quot; title=&quot;关于CSS预处理与经典布局&quot;&gt;&lt;/a&gt;关于CSS预处理与经典布局&lt;/h1&gt;&lt;h2 id=&quot;CSS预处理器&quot;&gt;&lt;a href=&quot;#CS</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化与模块</title>
    <link href="http://yoursite.com/2021/07/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2021/07/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-07-21T13:10:45.000Z</published>
    <updated>2021-07-23T04:02:07.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack、babel与模块化"><a href="#webpack、babel与模块化" class="headerlink" title="webpack、babel与模块化"></a>webpack、babel与模块化</h1><p>原因：</p><ul><li>ES6模块化，浏览器暂不支持</li><li>ES6语法，浏览器并不完全支持</li><li>压缩和整合代码，可以让网页加载更快</li></ul><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>工程化一个项目的过程：</p><ul><li><p>npm init -y (-y 跳过按回车的步骤，也就是全选“yes”)，生成一个package.json文件如下：</p><div class="hljs"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">"name"</span>: <span class="hljs-string">"webpack-demo"</span>,  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,  <span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>  &#125;,  <span class="hljs-string">"keywords"</span>: [],  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>&#125;</code></pre></div></li><li><p>npm i webpack webpack-cli -D (-D 是指 –save-dev)，package.json中会添加开发依赖的包：</p><div class="hljs"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">"name"</span>: <span class="hljs-string">"webpack-demo"</span>,  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,  <span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>  &#125;,  <span class="hljs-string">"keywords"</span>: [],  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,  <span class="hljs-string">"dependencies"</span>: &#123;&#125;,  <span class="hljs-string">"devDependencies"</span>: &#123;    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^5.45.1"</span>,    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^4.7.2"</span>  &#125;&#125;</code></pre></div></li><li><p>新建webpack.config.js文件，添加webpack的配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// production 开发/生产环境</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle.js'</span>,        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;&#125;</code></pre></div><p>之后在package.json中添加运行命令：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --config webpack.config.js"</span> <span class="hljs-comment">// 或者"webpack“ 也可</span>&#125;</code></pre></div></li></ul><p>打包好的bundle.js是怎么用的？是需要html文件调用，在src目录下也有写好的html文件（注意这个html并不需要用script引入index.js），使用html-webpack-plugin整合，之后用webpack-dev-server启动本地服务进行调试</p><ul><li><p>webpack配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// production 开发/生产环境</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle.js'</span>,        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;,    plugins: [        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">// 根据模板产出的html，会放在dist文件夹中</span>        &#125;)    ],    devServer: &#123;        port: <span class="hljs-number">3000</span>,        contentBase: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;&#125;</code></pre></div></li><li><p>package.json配置：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>,    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --config webpack.config.js"</span> <span class="hljs-comment">// 与上同理</span>&#125;</code></pre></div></li></ul><p>以上是开发环境，webpack生产环境的配置可以新建一个webpack.prod.js：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    mode: <span class="hljs-string">'production'</span>, <span class="hljs-comment">// 压缩代码</span>    entry: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>), <span class="hljs-comment">// 入口文件 __dirname为当前目录</span>    output: &#123;        filename: <span class="hljs-string">'bundle[contenthash].js'</span>, <span class="hljs-comment">// 打包的文件后缀一个hash值</span>        path: path.join(__dirname, <span class="hljs-string">'dist'</span>)    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules:[            &#123;                test: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 先验证是否是js文件</span>                loader: [<span class="hljs-string">'babel-loader'</span>], <span class="hljs-comment">// 对这些文件都过这些loader</span>                include: path.join(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 包含哪些目录做loader</span>                exclude: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 排除那些目录</span>            &#125;        ]    &#125;,    plugins: [        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">// 根据模板产出的html，会放在dist文件夹中</span>        &#125;)    ]&#125;</code></pre></div><p>记得package.json中写一个新命令：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-string">"build_prod"</span>: <span class="hljs-string">"webpack --config webpack.prod.js"</span></code></pre></div><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>会发现bundle.js中依然是ES6的代码，而实际上有些浏览器不支持这种语法，需要将ES6转为ES5，babel可以完成这个任务，它与webpack是两个东西，webpack是用来打包的工具，而babel提供了一些插件给webpack，本身是做ES的高级语法向低级语法转变的工具。</p><div class="hljs"><pre><code class="hljs javascript">npm install @babel/core @babel/preset-env babel-loader -D</code></pre></div><blockquote><p>@babel 一个组</p><p>/xxx @babel中的一个模块</p><p>babel-loader 给webpack的插件</p></blockquote><p>需要在目录下有一个<code>.babelrc</code>文件：</p><div class="hljs"><pre><code class="hljs javascript">&#123;<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>]&#125;</code></pre></div><p>然后在webpack的配置文件中添加规则：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>: &#123;rules:[&#123;test: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 先验证是否是js文件</span>loader: [<span class="hljs-string">'babel-loader'</span>], <span class="hljs-comment">// 对这些文件都过这些loader</span>include: path.join(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 包含哪些目录做loader</span>exclude: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 排除那些目录</span>&#125;]&#125;</code></pre></div><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="引入多个script（模块）后出现的问题"><a href="#引入多个script（模块）后出现的问题" class="headerlink" title="引入多个script（模块）后出现的问题"></a>引入多个script（模块）后出现的问题</h3><ul><li><p>请求过多</p><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p></li><li><p>依赖模糊</p><p>不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p></li><li><p>难以维护</p><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决。</p></li></ul><h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理</strong></p><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p><strong>CommonJS暴露的模块到底是什么?</strong> </p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>，这个属性是一个对象：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<span class="hljs-keyword">var</span> addX = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">return</span> value + x;&#125;;<span class="hljs-built_in">module</span>.exports.x = x;<span class="hljs-built_in">module</span>.exports.addX = addX;</code></pre></div><p>所以require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p><p>需要注意的点：</p><ul><li><p>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> plusCount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  count++&#125;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, count)&#125;, <span class="hljs-number">1000</span>)<span class="hljs-built_in">module</span>.exports = &#123;  count,  plusCount&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">let</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, mod.count)mod.plusCount()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, mod.count)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    mod.count = <span class="hljs-number">3</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-3'</span>, mod.count)&#125;, <span class="hljs-number">2000</span>)node a.jsa.js<span class="hljs-number">-1</span> <span class="hljs-number">1</span>a.js<span class="hljs-number">-2</span> <span class="hljs-number">1</span>b.js<span class="hljs-number">-1</span> <span class="hljs-number">2</span>  <span class="hljs-comment">// 1秒后</span>a.js<span class="hljs-number">-3</span> <span class="hljs-number">3</span>  <span class="hljs-comment">// 2秒后</span></code></pre></div><p>可以看出，b模块export的count变量，是一个复制。在plusCount方法调用之后，a模块中的count不受影响。同时，可以在a模块中用b导出的函数更改b模块中的值。如果希望能够同步代码，可以export出去一个getter函数。</p></li><li><p>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">let</span> obj = &#123;  count: <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">let</span> plusCount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  obj.count++&#125;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, obj.count)&#125;, <span class="hljs-number">1000</span>)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-2'</span>, obj.count)&#125;, <span class="hljs-number">3000</span>)<span class="hljs-built_in">module</span>.exports = &#123;  obj,  plusCount&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, mod.obj.count)mod.plusCount()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, mod.obj.count)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  mod.obj.count = <span class="hljs-number">3</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-3'</span>, mod.obj.count)&#125;, <span class="hljs-number">2000</span>)node a.jsa.js<span class="hljs-number">-1</span> <span class="hljs-number">1</span>a.js<span class="hljs-number">-2</span> <span class="hljs-number">2</span>b.js<span class="hljs-number">-1</span> <span class="hljs-number">2</span>a.js<span class="hljs-number">-3</span> <span class="hljs-number">3</span>b.js<span class="hljs-number">-2</span> <span class="hljs-number">3</span></code></pre></div></li><li><p>当使用require命令加载某个模块时，就会运行整个模块的代码，并且用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。<strong>值得注意的是，循环加载</strong>时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span>exports.done = <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-1'</span>, a.done)exports.done = <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b.js-2'</span>, <span class="hljs-string">'执行完毕'</span>)<span class="hljs-comment">// a.js</span>exports.done = <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-1'</span>, b.done)exports.done = <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a.js-2'</span>, <span class="hljs-string">'执行完毕'</span>)<span class="hljs-comment">// c.js</span><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a.js'</span>)<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b.js'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c.js-1'</span>, <span class="hljs-string">'执行完毕'</span>, a.done, b.done)node c.jsb.js<span class="hljs-number">-1</span> <span class="hljs-literal">false</span>b.js<span class="hljs-number">-2</span> 执行完毕a.js<span class="hljs-number">-1</span> <span class="hljs-literal">true</span>a.js<span class="hljs-number">-2</span> 执行完毕c.js<span class="hljs-number">-1</span> 执行完毕 <span class="hljs-literal">true</span> <span class="hljs-literal">true</span></code></pre></div><blockquote><p>1.执行c模块。此时遇到require关键字，执行a.js中所有代码。<br>2.在a模块中exports之后，通过require引入了b模块，执行b模块的代码。<br>3.在b模块中exports之后，又require引入了a模块，此时执行a模块的代码。<br>4.a模块执行exports.done = false发现要回b，判断是模块循环，所以对b只输出第一句。<br>5.回到b模块，打印b.js-1 false,  b.js-2，执行完毕。<br>6.回到a模块，接着打印a.js-1 true,  a.js-2，执行完毕<br>7.回到c模块，接着执行require，需要引入b模块。由于在a模块中已经引入过了，所以不会再次打印上面这些内容，也就是没有执行，直接缓存取值就可以。<br>结束。</p></blockquote></li></ul><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS只能在运行时确定这些东西，CommonJS 模块就是对象，输入时必须查找对象属性。</p><ul><li>输出：export / export default</li><li>引入：import</li></ul><p>需要注意的点：</p><ul><li><p>ES6 模块输出的是值的引用：ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且是<strong>动态只读引用</strong>，并且不会缓存值，模块里面的变量绑定其所在的模块。也就是说，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值，并且是动态的，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。但是！！这玩意的只读是类似与const，如果只是++，或者给对象增加属性，不会报错。</p></li><li><p>循环引用时，因为是动态引用，用到啥再去对应的模块找就可以了</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;    foo();  &#125;&#125;<span class="hljs-comment">// a.js</span><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./b.js'</span>;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);  bar();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'执行完毕'</span>);&#125;foo();babel-node a.jsfoobar执行完毕<span class="hljs-comment">// 执行结果也有可能是</span>foobarfoobar执行完毕执行完毕</code></pre></div></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p><p>因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。举个例子：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-keyword">let</span> stat = _fs.stat;<span class="hljs-keyword">let</span> exists = _fs.exists;<span class="hljs-keyword">let</span> readfile = _fs.readfile;</code></pre></div><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;</code></pre></div><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高（ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack、babel与模块化&quot;&gt;&lt;a href=&quot;#webpack、babel与模块化&quot; class=&quot;headerlink&quot; title=&quot;webpack、babel与模块化&quot;&gt;&lt;/a&gt;webpack、babel与模块化&lt;/h1&gt;&lt;p&gt;原因：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端工程化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Web安全</title>
    <link href="http://yoursite.com/2021/07/21/Web%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2021/07/21/Web%E5%AE%89%E5%85%A8/</id>
    <published>2021-07-21T13:05:28.000Z</published>
    <updated>2021-07-22T09:26:34.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><p><strong><em>Tips：本科信安，，这应该算是俺的老本行了。。</em></strong></p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>xss Cross Site Scripting 跨站脚本攻击</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web安全&quot;&gt;&lt;a href=&quot;#Web安全&quot; class=&quot;headerlink&quot; title=&quot;Web安全&quot;&gt;&lt;/a&gt;Web安全&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Tips：本科信安，，这应该算是俺的老本行了。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>网页加载与性能优化</title>
    <link href="http://yoursite.com/2021/07/21/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/07/21/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-07-21T05:24:31.000Z</published>
    <updated>2021-07-21T12:59:31.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网页加载与性能优化"><a href="#网页加载与性能优化" class="headerlink" title="网页加载与性能优化"></a>网页加载与性能优化</h1><p><strong><em>内容包含页面加载过程、前端性能优化</em></strong></p><h2 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h2><h3 id="资源形式"><a href="#资源形式" class="headerlink" title="资源形式"></a>资源形式</h3><ul><li>HTML代码</li><li>媒体文件，如图片、视频等</li><li>JS脚本、CSS样式表</li></ul><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>一个url输入到页面显示的过程：</p><p><strong><em>DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 报文、浏览器解析渲染页面</em></strong>（在渲染过程中介绍）</p><ul><li><p>DNS解析：域名转换到IP地址</p><p>1、在浏览器中输入<a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关   系，如果有，就先调用这个IP地址映射，完成域名解析。 </p><p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<a href="https://link.zhihu.com/?target=http%3A//qq.com">http://qq.com</a>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<a href="https://link.zhihu.com/?target=http%3A//qq.com">http://qq.com</a>域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机。" target="_blank" rel="noopener">www.qq.com主机。</a> </p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><p><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。</p><p><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。</p></li><li><p>TCP连接：</p><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，建立TCP/IP的连接。</p><p>扩展：</p><p>TCP三次握手</p><blockquote><p>第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认。</p><p>第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。</p><p>第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。</p><p>为什么需要三次握手？</p><p><em>“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</em></p><p>​    client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p><p>​    假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p></blockquote><p>TCP四次挥手</p><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><p>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p><p>​    因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN<strong>放在一个报文里</strong>发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，就多了一次。</p></blockquote></li><li><p>发送 HTTP 请求</p><p>包含请求行、请求头、请求体：</p><blockquote><p>请求行包含请求方法、URL、协议版本</p><ul><li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li>URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li><li>协议版本即 http 版本号</li></ul><div class="hljs"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/chapter17/user.html</span> HTTP/1.1</code></pre></div><p>请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔</p><p>请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</p></blockquote></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p><p>浏览器得到上一步中返回的HTTP报文响应体中的HTML文本，开始解析渲染页面</p></li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p><strong><em>HTML 解析出 DOM 树、根据 CSS 解析生成 CSS 规则树、结合 DOM 树和 CSS 规则树生成渲染树、根据渲染树计算每一个节点的信息、根据计算好的信息绘制页面</em></strong></p><ul><li><p>根据 HTML 解析 DOM 树</p><blockquote><p>​    根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析是一个深度优先遍历的过程。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</p><p>​    在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，立即加载并执行这个脚本，直至脚本执行完毕。</p><p>​    注意，添加defer属性的script标签，脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行（有 <code>defer</code> 属性的脚本会阻止 <code>DOMContentLoaded</code> 事件，直到脚本被加载并且解析完成），也就是 DOM 解析后立即执行，并且其加载过程是另开一个线程下载的。</p><p>​    添加async属性的script标签，会在脚本加载好之后立即执行，并且加载也是异步的，不会阻塞DOM解析构建</p></blockquote></li><li><p>根据 CSS 解析生成 CSS 规则树</p><blockquote><p>​    浏览器会有不同的线程，比如说GUI 渲染线程、JS 线程、定时器触发线程 (setTimeout)、浏览器事件线程 (onclick)、http 异步线程</p><p>​    首先，CSS的加载和解析不会影响DOM的解析，只会在DOM树完成后阻塞渲染树的生成</p><p>​    其次，CSS的加载会阻塞JS的执行，因为CSS样式表没下载好的时候，如果JS中有获取样式的代码，就必须等CSS加载完成，所以一般<code>&lt;script&gt;</code>会放在<code>&lt;link&gt;</code>前面。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。</p></blockquote></li><li><p>结合 DOM 树和 CSS 规则树，生成渲染树</p></li><li><p>根据渲染树计算每一个节点的信息</p></li><li><p>根据计算好的信息绘制页面</p><blockquote><ul><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ul></blockquote></li></ul><p>window.onload 和 DOMContentLoaded 的区别：</p><ul><li>onload 资源全部加载完毕才执行</li><li>Content 初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发（图片可能还未下载）</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>核心原则（空间换时间）：</p><ul><li>多使用内存、缓存或其他方法</li><li>减少CPU计算量、减少网络加载耗时</li></ul><p>让加载更快：</p><ul><li><p>减少资源体积： 压缩代码、压缩资源（gzip)</p></li><li><p>减少访问次数：合并代码、SSR、缓存</p><p>对缓存来说，静态资源根据文件内容计算hash并作为后缀，文件内容不变则hash也不便，可以触发http缓存机制，返回304</p></li><li><p>更快的网络：CDN</p></li></ul><p>让渲染更快：</p><ul><li><p>CSS放在head、JS放body最下面</p></li><li><p>尽早执行JS、可以用DOMContentLoaded触发</p></li><li><p>懒加载（图片懒加载、上划加载更多）</p><div class="hljs"><pre><code class="hljs html">// preview是一张很小的缩略图，在满足查看条件后，比如点击了图或者下划之类的，就把真实的src给这个img<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"img1"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"preview.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"yulan"</span> <span class="hljs-attr">data-realsrc</span>=<span class="hljs-string">"realbig.jpg"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> img1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"img1"</span>);</span><span class="actionscript">    img1.src = img1.getAttribute(<span class="hljs-string">'data-realsrc'</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li><li><p>对DOM查询的缓存、频繁的DOM操作要合并</p></li><li><p>节流、防抖</p><p>节流：为了避免短时间内大量触发某一事件造成的函数调用，需设置延迟时间</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay, immediate</span>) </span>&#123; <span class="hljs-comment">// immediate 是否立即执行</span>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;        <span class="hljs-keyword">if</span>(timer) clearTimeout(timer);        <span class="hljs-keyword">if</span>(immediate) &#123;            <span class="hljs-keyword">let</span> callnow = !timer;            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                timer = <span class="hljs-literal">null</span>;            &#125;, delay);            <span class="hljs-keyword">if</span>(callnow) fn.apply(context, args);        &#125; <span class="hljs-keyword">else</span> &#123;            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                fn.apply(context, args);            &#125;, delay);        &#125;    &#125;&#125;</code></pre></div><p>防抖：指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。与防抖不同在于，防抖如果不停止触发事件，则一直不会执行函数，而节流可以在不停触发事件的一段时间中给出反应</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay, type</span>) </span>&#123; <span class="hljs-comment">// 选择两种实现方式 由于存在闭包，previous等变量可以保存</span>    <span class="hljs-keyword">let</span> previous = <span class="hljs-built_in">Date</span>.now();    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;        <span class="hljs-keyword">if</span>(type === <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();            <span class="hljs-keyword">if</span>(now - previous &gt; delay) &#123;                fn.apply(context, args);                previous = now;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(!timer) &#123;                timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    fn.apply(context, args);                    timer = <span class="hljs-literal">null</span>;                &#125;, delay);            &#125;        &#125;    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网页加载与性能优化&quot;&gt;&lt;a href=&quot;#网页加载与性能优化&quot; class=&quot;headerlink&quot; title=&quot;网页加载与性能优化&quot;&gt;&lt;/a&gt;网页加载与性能优化&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;内容包含页面加载过程、前端性能优化&lt;/em&gt;&lt;/strong</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JS基础面试</title>
    <link href="http://yoursite.com/2021/07/19/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2021/07/19/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/</id>
    <published>2021-07-19T05:10:52.000Z</published>
    <updated>2021-07-21T05:26:31.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础面试"><a href="#JS基础面试" class="headerlink" title="JS基础面试"></a>JS基础面试</h1><p><strong><em>内容包含：原型、原型链、作用域、闭包、异步、单线程、DOM、BOM、Ajax、跨域、事件、存储</em></strong></p><h2 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h2><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>值类型用栈存储，引用类型用堆存储，不同存储的原因是数据结构的不同，值类型占内存小且结构简单，引用类型相反。</p><p>常见引用类型：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 特殊引用类型 指针指向空</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <span class="hljs-comment">// 特殊引用类型 不用于存储数据所以没有“深拷贝”</span></code></pre></div><h3 id="typeof和深拷贝"><a href="#typeof和深拷贝" class="headerlink" title="typeof和深拷贝"></a>typeof和深拷贝</h3><p>typeof：</p><ul><li>识别所有<em>值类型</em></li><li>能判断函数 ‘function’</li><li>识别引用类型 ‘object’ 但无法继续识别更深层次，比如这个对象属于哪类 –&gt; null和{x:100}都是‘object’</li></ul><p>深拷贝：记得递归检查对象内部的值是否也是复杂对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'object'</span> || obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;    <span class="hljs-keyword">let</span> res;    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) res = [];    <span class="hljs-keyword">else</span> res = &#123;&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-comment">// 保证key不是原型属性</span>        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) &#123;            res[key] = deepClone(obj[key]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><p>类型转换：</p><ul><li>字符串拼接 100+‘100’=100100</li><li>==运算符号 100 == ‘100’ true 一般只用检查null或undefine时用==</li><li>if和!!会会将变量转换为true或false</li><li>&amp;&amp;和|| 都可以用作计算 ‘0’||’abc’返回‘abc’， 100 || 0 返回100， 0 &amp;&amp;100 返回0</li></ul><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="class和继承"><a href="#class和继承" class="headerlink" title="class和继承"></a>class和继承</h3><p>ES6可以用class，extends，constructor，super完成类的创建和继承，ES5中的继承需要手动实现</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    F.prototype = superType.prototype;    subType.prototype = <span class="hljs-keyword">new</span> F();    subType.prototype.constructor = subType;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">father</span>) </span>&#123;    <span class="hljs-keyword">this</span>.father = father;    Father.prototype.sayFather() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.father);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">son, father</span>) </span>&#123;    <span class="hljs-keyword">this</span>.son = son;    Father.call(<span class="hljs-keyword">this</span>, father);&#125;inheritPrototype(Son, Father);Son.prototype.saySon() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.son);&#125;</code></pre></div><h3 id="原型、原型链和instanceof"><a href="#原型、原型链和instanceof" class="headerlink" title="原型、原型链和instanceof"></a>原型、原型链和instanceof</h3><p>instanceof可以判断引用类型的数据是否是由某个类实例化的</p><p>hasOwnProperty检查是否是自身拥有的属性</p><p>终点是一个object的实例，<code>__proto__</code>为空</p><p>进阶内容：</p><p><em>1.object对象是由 object()方法实例化的，而 object()函数也是对象，是由 function object()声明，这个函数对象的 prototype指向上文中所说的终点（<code>__proto__</code>为空的 object实例），而其自身还拥有一个<code>__proto__</code>，指向构造它的函数的 prototype，也就是 function的 prototype。</em></p><p><em>2.function.prototype是一个 object实例对象，其<code>__proto__</code>指向上文的终点。而 function也是由 function声明的（没错自己是自己的构造函数），所以它是唯一自身的<code>__proto__</code>指向 prototype的函数，对于其他函数而言，由于都是 funciton构造的，所以所有函数的<code>__proto__</code>都指向 function()的 prototype</em></p><p>手写一个简单的jQuery：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jQuery</span></span>&#123;    <span class="hljs-keyword">constructor</span>(selector) &#123;        <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(selector);        <span class="hljs-keyword">const</span> length = result.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) <span class="hljs-keyword">this</span>[i] = result[i];        <span class="hljs-keyword">this</span>.length = length;        <span class="hljs-keyword">this</span>.selector = selector;    &#125;    <span class="hljs-keyword">get</span>(index) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[index];    &#125;    each(fn) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;            <span class="hljs-keyword">const</span> elem = <span class="hljs-keyword">this</span>[i];            fn(elem);        &#125;    &#125;    on(type, fn) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> &#123;            elem.addEventListener(type, fn, <span class="hljs-literal">false</span>);        &#125;)    &#125;&#125;<span class="hljs-comment">// 拓展</span>jQuery.prototype.more() = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;...&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myJQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JQuery</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(selector) &#123;        <span class="hljs-keyword">super</span>(selector);        ...    &#125;&#125;</code></pre></div><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>ES6新增了块级作用域</p><p>闭包：作用域应用的特殊情况，一般有两种表现</p><ul><li>函数作为参数被传递</li><li>函数作为返回值被返回</li></ul><p>自由变量的查找是从函数定义的地方向上层作用域查找，而不是在执行的作用域查找</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数作为返回值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(a);    &#125;&#125;<span class="hljs-keyword">const</span> fn1 = create();<span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span>;fn1(); <span class="hljs-comment">// 100</span><span class="hljs-comment">// 函数作为参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printm</span>(<span class="hljs-params">fn</span>) </span>&#123;    <span class="hljs-keyword">const</span> b = <span class="hljs-number">200</span>;    fn();&#125;<span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(b);&#125;printm(fn2); <span class="hljs-comment">// 100</span></code></pre></div><p>闭包的作用：</p><p>可以隐藏数据，只提供API，防止手动修改数据</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> data = &#123;&#125;; <span class="hljs-comment">// 将data隐藏，外界无法通过data.a更改数据</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-keyword">set</span>(key, value) &#123;            data[key] = value;        &#125;,        <span class="hljs-keyword">get</span>(key) &#123;            <span class="hljs-keyword">return</span> data[key];        &#125;    &#125;;&#125;<span class="hljs-keyword">let</span> x = createCache();x.set(<span class="hljs-string">'a'</span>,<span class="hljs-number">100</span>);<span class="hljs-built_in">console</span>.log(x.get(<span class="hljs-string">'a'</span>))</code></pre></div><p>建立不同的隐藏作用域</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    a[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(i);    &#125;&#125; <span class="hljs-comment">// 每个a点击后都出现 10</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;        a[num].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(num);        &#125;    &#125;)(i);&#125; <span class="hljs-comment">// 每个a点击后都出现对应的数字</span><span class="hljs-comment">// 但是let与var不同在于let有块级作用域（每个循环一个块作用域），每个a都能输出对应的数字</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    a[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(i);    &#125;&#125;</code></pre></div><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this的取值是在函数执行时判断，而不是定义时，适用于所有普通情况=&gt;普通函数、call、apply、bind、对象方法、class</p><p>而对于箭头函数，this是在定义函数时绑定的，而不是执行过程中。（这样做解决了匿名函数、setTimeout的this指向问题），当然用上文闭包中变量在函数定义的地方查找的原理，可以先用一个that保存this，使用that就不会有这些问题了。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;    name: <span class="hljs-string">'a'</span>,    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// a</span>    &#125;,    wait() &#123;        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// window</span>        &#125;)    &#125;&#125;<span class="hljs-keyword">const</span> b = &#123;    name: <span class="hljs-string">'b'</span>,    say() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// b</span>    &#125;,    wait() &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// b</span>        &#125;)    &#125;&#125;</code></pre></div><p>改变this的方式：bind，call，apply。</p><p>某一对象.调用方法.call(准备使用方法的对象, 参数)</p><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p><p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p><p>3.处理传入的参数，截取第一个参数后的所有参数。</p><p>4.将函数作为上下文对象的一个属性。</p><p>5.使用上下文对象来调用这个方法，并保存返回结果。</p><p>6.删除刚才新增的属性。</p><p>7.返回结果。</p><p>apply和bind情况类似，不同点在于，apply传入参数为一整个数组，不需要解构。而bind需要判断最终返回的函数是否会作为一个构造函数调用，如果作为构造函数使用，构造的对象this就是执行上下文，而不是传入的那个context。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    context = context || <span class="hljs-built_in">window</span>;    context.fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>), res;    res = context.fn(...args);    <span class="hljs-keyword">delete</span> context.fn;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    context = context || <span class="hljs-built_in">window</span>;    context.fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) res = context.fn(...arguments[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">else</span> context.fn();    <span class="hljs-keyword">delete</span> context.fn;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);    <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>), fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> fn.apply(            <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Fn ? <span class="hljs-keyword">this</span> : context,            args.concat(...arguments)        );    &#125;&#125;</code></pre></div><p>实现关键字new（new中也有this的问题）</p><p>1.首先创建了一个新的空对象</p><p>2.设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>3.让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>4.如果构造器没有手动返回对象，则返回第一步创建的新对象，如果有，则舍弃掉第一步创建的新对象，返回手动return的对象。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> newObj = <span class="hljs-literal">null</span>, <span class="hljs-keyword">constructor</span> = [].shift.call(arguments);    if(typeof <span class="hljs-keyword">constructor</span> !== "function") console.error("type error");    newObj = Object.create(<span class="hljs-keyword">constructor</span>.prototype);    let res = <span class="hljs-keyword">constructor</span>.apply(newObj, [...arguments]);    return typeof res === "object" ? res : newObj;&#125;</code></pre></div><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>应用场景：主要在网络请求、定时任务等。</p><p>ES5中的异步依赖回调</p><p>ES6新增了promise，它的出现是为了解决回调地狱，从嵌套模式转为管道形式。</p><p>ES7中新增async、await，原理是使用ES6中的generator函数实现。</p><h3 id="ES5-回调"><a href="#ES5-回调" class="headerlink" title="ES5 回调"></a>ES5 回调</h3><p>回调地狱</p><div class="hljs"><pre><code class="hljs javascript">$.<span class="hljs-keyword">get</span>(url1, data1 =&gt; &#123;<span class="hljs-comment">// work with data1...</span>    <span class="hljs-comment">// data2 需要在data1处理之后在请求</span>    $.<span class="hljs-keyword">get</span>(url2, data2 =&gt; &#123;        <span class="hljs-comment">// work with data2</span>        $.<span class="hljs-keyword">get</span>(...)    &#125;)&#125;)</code></pre></div><h3 id="ES6-promise"><a href="#ES6-promise" class="headerlink" title="ES6 promise"></a>ES6 promise</h3><div class="hljs"><pre><code class="hljs javascript">getdata(url1).then(<span class="hljs-function"><span class="hljs-params">data1</span> =&gt;</span> &#123;    <span class="hljs-comment">// work with data1</span>    <span class="hljs-keyword">return</span> getdata(url2);&#125;).then(<span class="hljs-function"><span class="hljs-params">data2</span> =&gt;</span> &#123;    <span class="hljs-comment">// work with data2</span>    <span class="hljs-keyword">return</span> getdata(...)&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">Error</span>(err));</code></pre></div><h2 id="JS-Web-API"><a href="#JS-Web-API" class="headerlink" title="JS Web API"></a>JS Web API</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM的本质：是HTML文本解析出的一棵树</p><p>DOM的节点操作：</p><ul><li>获取节点getElementByID（TagName ClassName）、querySelector</li><li>获取节点的property，比如style、nodeName、nodeType 实际上是修改js变量的属性</li><li>获取节点的attribute，比如p.setAttribute(‘data-name’, ‘hh’) 实际上是修改标签的属性</li></ul><p>DOM的结构操作：</p><ul><li>新建节点 createElement、插入节点appendChild、删除节点removeChild</li></ul><p>DOM性能：要避免频繁的DOM操作</p><p>对DOM查询做缓存（比如for循环不要每次都查列表长度）</p><p>将频繁操作整合到一次操作中（不在for中一直插入，整合后在循环结束再插入）</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>navigator、screen、location、history</p><p>navigator 是一个包含浏览器信息的对象</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// navigator</span><span class="hljs-keyword">const</span> ua = navigator.userAgent;<span class="hljs-built_in">console</span>.log(ua.indexOf(<span class="hljs-string">'Chrome'</span>));<span class="hljs-comment">// screen</span><span class="hljs-built_in">console</span>.log(screen.width);<span class="hljs-comment">// location</span><span class="hljs-built_in">console</span>.log(location.href); <span class="hljs-comment">// 网址</span><span class="hljs-built_in">console</span>.log(location.protocol); <span class="hljs-comment">// 协议</span><span class="hljs-built_in">console</span>.log(location.host); <span class="hljs-comment">// url的host 域名</span><span class="hljs-built_in">console</span>.log(location.search); <span class="hljs-comment">// ?a=100&amp;b=200</span><span class="hljs-built_in">console</span>.log(location.pathname); <span class="hljs-comment">// 域名后的路径</span><span class="hljs-comment">// history 前进后退</span>history.back();history.forward();</code></pre></div><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>event.preventDefault() 阻止默认行为，比如超链接的跳转等 （当a标签的href属性存在并有一个正确的地址时，点击它，它会跳转到对应的地址去，这就是它的默认行为）</p><p>DOM0与DOM2级事件的区别：</p><ul><li>DOM0绑定多个事件后只执行最后一个，而DOM2可以绑定多个，只有当事件名，函数名，发生阶段都一样才会只执行最后一个</li><li>DOM0不需要考虑兼容问题</li><li>DOM0事件规定的事件流包含3个阶段，<strong>事件捕获阶段、处于目标阶段、事件冒泡阶段</strong>。首先发生的事件捕获为截获事件提供机会，然后是实际的目标接收事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。也就是说，<strong>DOM0级事件只能触发事件冒泡阶段而不能触发事件捕获阶段</strong></li><li>DOM2级事件使用<code>addEventListener</code>和<code>removeEventListener</code>创建和删除，第三个参数为true时代表在捕获期间触发</li></ul><p>阻止冒泡使用：</p><ul><li>event.stopPropagation()，可以在DOM0，DOM2使用</li><li>event.target==this 判断是否是当前元素触发的绑定事件</li></ul><p>事件代理：利用冒泡机制，给父元素绑定监听事件</p><ul><li>可以大量节省内存占用，减少事件注册</li><li>实现当新增子对象时无需再次对其绑定</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 通用的事件监听函数 包括普通绑定和代理绑定</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindEvent</span>(<span class="hljs-params">elem, type, selector, fn</span>) </span>&#123;    <span class="hljs-keyword">if</span>(fn == <span class="hljs-literal">null</span>) [fn, selector] = [selector, fn]; <span class="hljs-comment">// 普通绑定第三个参数为fn</span>    elem.addEventListener(type, event =&gt; &#123;        <span class="hljs-keyword">const</span> target = event.target;        <span class="hljs-keyword">if</span>(selector) &#123; <span class="hljs-comment">// 代理绑定</span>            <span class="hljs-keyword">if</span>(target.matches(selector)) fn.call(target, event);            <span class="hljs-keyword">else</span> fn.call(target, event);        &#125;    &#125;)&#125;<span class="hljs-keyword">const</span> ula = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'thisUl'</span>);bindEvent(ula, <span class="hljs-string">'click'</span>, <span class="hljs-string">'li'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.target.innerHTML&#125;);</code></pre></div><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>XMLHttpRequest封装一个简单的ajax</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">url, sucessFn</span>) </span>&#123;    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();    xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// true为 异步请求</span>    xhr.send(<span class="hljs-literal">null</span>);    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">if</span>(xhr.status === <span class="hljs-number">200</span>) &#123;                sucessFn(xhr.responseText);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// post 请求,替换send内容，必须是一个字符串</span><span class="hljs-keyword">const</span> data = &#123;    value: <span class="hljs-number">123</span>&#125;<span class="hljs-comment">// xhr.send(JSON.stringify(data))</span></code></pre></div><p>跨域：ajax请求时，浏览器要求当前网页和server必须同源（安全）</p><ul><li>同源：协议、域名、端口三者一致</li><li>加载图片、css、js可以无视同源策略<code>&lt;img src=imgurl /&gt;</code>、<code>&lt;link href=cssurl /&gt;</code>、<code>&lt;script src=jsurl&gt;&lt;/script&gt;</code>，也就是说CDN引入可以跨域  <strong>tips：<code>&lt;img&gt;</code>可以用来统计打点，访问静态页面时,通过img标签指定src 为访问统计的地址, img标签向统计程序发出请求,实现统计，也可以使用第三方服务，如百度的提供的统计等</strong></li></ul><p>解决方式：</p><ul><li><p>JSONP：利用<code>&lt;script&gt;</code>可以绕过跨域限制，服务器可以任意拼接数据返回</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-built_in">window</span>.callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(data);</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://xxx.xxx/jsonp.js?username=xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 服务器可以拿到username// jsonp.jscallback(&#123; name: 'dfg' &#125;)</code></pre></div><p>请求的数据会立马被浏览器当作javascript语句去执行，所以js文件中用一个函数调用数据的形式，变成一个可执行的js代码，也就是上文的callback(data)，这个函数定义在浏览器端的代码中，这样想要的数据就在包裹中完成传递</p></li><li><p>CORS：全称是”跨域资源共享”（Cross-origin resource sharing），需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。浏览器会在ajax<strong>简单请求</strong>中添加一个origin字段，用于指出当前请求属于哪个域（协议、域名、端口），之后服务器根据这个值决定是否允许其跨域，如果允许，返回的响应头需要携带以下信息：</p><div class="hljs"><pre><code class="hljs javascript">Access-Control-Allow-Origin: http:<span class="hljs-comment">//manage.leyou.com // 可接受的域，是一个具体域名或者*，代表任意</span>Access-Control-Allow-Credentials: <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</span>Content-Type: text/html; charset=utf<span class="hljs-number">-8</span></code></pre></div><p>如果是特殊请求，比如PUT之类的，会在正式通信前用option发一次预检请求，增加信息如下：</p><div class="hljs"><pre><code class="hljs javascript">Access-Control-Request-Method：接下来会用到的请求方式，比如PUTAccess-Control-Request-Headers：会额外用到的头信息<span class="hljs-comment">// 例子</span>OPTIONS /cors HTTP/<span class="hljs-number">1.1</span>Origin: http:<span class="hljs-comment">//manage.leyou.com</span>Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/<span class="hljs-number">5.0</span>...</code></pre></div><p>server端收到option预检请求，如果允许跨域，会发出响应，包含以下增加信息：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">Access-Control-Allow-Methods：允许访问的方式</span><span class="hljs-string">Access-Control-Allow-Headers：允许携带的头</span><span class="hljs-string">Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了</span><span class="hljs-string">//</span> <span class="hljs-string">上面例子的回复</span><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span><span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">01</span> <span class="hljs-string">Dec</span> <span class="hljs-number">2008</span> <span class="hljs-number">01</span><span class="hljs-string">:15:39</span> <span class="hljs-string">GMT</span><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.0.61</span> <span class="hljs-string">(Unix)</span><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">http://manage.leyou.com</span><span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span><span class="hljs-attr">Access-Control-Allow-Methods:</span> <span class="hljs-string">GET,</span> <span class="hljs-string">POST,</span> <span class="hljs-string">PUT</span><span class="hljs-attr">Access-Control-Allow-Headers:</span> <span class="hljs-string">X-Custom-Header</span><span class="hljs-attr">Access-Control-Max-Age:</span> <span class="hljs-number">1728000</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span><span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">0</span><span class="hljs-attr">Keep-Alive:</span> <span class="hljs-string">timeout=2,</span> <span class="hljs-string">max=100</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">Keep-Alive</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/plain</span></code></pre></div><p>如果浏览器得到了上面的响应，后续与简单请求没有区别。</p></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>cookie：</p><ul><li><p>本身用于浏览器与server通讯（请求头），被“借用”到本地存储（HTML5之前）</p></li><li><p>用<code>document.cookie=&#39;...&#39;</code>的方式来修改，且只能这样修改</p></li><li><p>字符串形式，key=value，用；分割，有以下几个属性：</p><div class="hljs"><pre><code class="hljs javascript">name <span class="hljs-comment">// cookie的名称</span>value <span class="hljs-comment">// cookie的值</span>domain <span class="hljs-comment">// 可以访问此cookie的域名</span><span class="hljs-comment">/*</span><span class="hljs-comment">设置：</span><span class="hljs-comment">非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。</span><span class="hljs-comment">顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。</span><span class="hljs-comment"></span><span class="hljs-comment">取值：</span><span class="hljs-comment">二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。</span><span class="hljs-comment">顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。</span><span class="hljs-comment">*/</span>path <span class="hljs-comment">// domain下可访问此cookie的路径</span>expires/Max-Age <span class="hljs-comment">// 过期时间</span><span class="hljs-comment">/*</span><span class="hljs-comment">此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</span><span class="hljs-comment">*/</span>Size <span class="hljs-comment">// cookie大小</span>http <span class="hljs-comment">/*</span><span class="hljs-comment">cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie</span><span class="hljs-comment">*/</span>secure <span class="hljs-comment">// 设置是否只能通过https来传递此条cookie</span></code></pre></div></li><li><p>存储大小4KB（单个cookie），且http请求会将它发送到服务端，增加请求的数据量</p></li></ul><p>localStorage和sessionStorage：</p><ul><li><p>HTML5中专门为存储设计，最大5m（针对每个域名！！）</p></li><li><p>API用setItem、getItem</p><div class="hljs"><pre><code class="hljs javascript">localStorage.setItem(<span class="hljs-string">'a'</span>, <span class="hljs-number">100</span>);localStorage.getItem(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// "100" 是字符串形式</span>localStorage.removeItem(<span class="hljs-string">'a'</span>);sessionStorage.setItem(<span class="hljs-string">'a'</span>, <span class="hljs-number">100</span>);sessionStorage.getItem(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// "100" 是字符串形式</span>sessionStorage.removeItem(<span class="hljs-string">'a'</span>);</code></pre></div></li><li><p>不会随着http请求发送出去</p></li><li><p>localStorage数据会永久存储，除非代码或手动删除，而sessionStorage只存在于当前会话，浏览器关闭会清空</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础面试&quot;&gt;&lt;a href=&quot;#JS基础面试&quot; class=&quot;headerlink&quot; title=&quot;JS基础面试&quot;&gt;&lt;/a&gt;JS基础面试&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;内容包含：原型、原型链、作用域、闭包、异步、单线程、DOM、BOM、Ajax、跨域、</summary>
      
    
    
    
    <category term="前端八股文" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>12月做题记录</title>
    <link href="http://yoursite.com/2020/12/14/12%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/12/14/12%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-14T12:52:38.000Z</published>
    <updated>2020-12-26T12:07:00.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12月做题记录"><a href="#12月做题记录" class="headerlink" title="12月做题记录"></a>12月做题记录</h1><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h3><p>用单词的字典序做key，更秀的是JS中object可以用数组做key，可以统计26个字母的出现次数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) &#123;        <span class="hljs-keyword">let</span> array = <span class="hljs-built_in">Array</span>.from(str);        array.sort();        <span class="hljs-keyword">let</span> key = array.toString();        <span class="hljs-keyword">let</span> list = map.get(key)?map.get(key):<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        list.push(str);        map.set(key,list);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(map.values());&#125;;<span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> strs) &#123;        <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> s) count[c.charCodeAt()-<span class="hljs-string">'a'</span>.charCodeAt()]++;        map[count]?map[count].push(s):map[count]=[s];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(map);&#125;;</code></pre></div><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字</a></h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;    <span class="hljs-keyword">const</span> strN = N.toString().split(<span class="hljs-string">''</span>).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> +v); <span class="hljs-comment">//将V变成number类型</span>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i&lt;strN.length &amp;&amp; strN[i<span class="hljs-number">-1</span>]&lt;=strN[i]) i++;    <span class="hljs-keyword">if</span>(i &lt; strN.length) &#123;        <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; strN[i<span class="hljs-number">-1</span>]&gt;strN[i]) &#123;            strN[i<span class="hljs-number">-1</span>]--;            i--;        &#125;        <span class="hljs-keyword">for</span>(i++;i&lt;strN.length;i++) strN[i]=<span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(strN.join(<span class="hljs-string">''</span>));&#125;;</code></pre></div><h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></h3><p>DP和贪心都可以</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> buy = prices[<span class="hljs-number">0</span>]+fee;    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        <span class="hljs-keyword">if</span>(prices[i]+fee &lt; buy) buy = prices[i]+fee;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i] &gt; buy) &#123;            profit += prices[i] - buy;            buy = prices[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> profit;&#125;;</code></pre></div><h3 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">找不同</a></h3><p>用排序做时间复杂度O(logN)，可以遍历O(N)解决</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;    <span class="hljs-keyword">let</span> sarr = s.split(<span class="hljs-string">''</span>).sort();    <span class="hljs-keyword">let</span> tarr = t.split(<span class="hljs-string">''</span>).sort();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;sarr.length;i++) &#123;        <span class="hljs-keyword">if</span>(sarr[i] !== tarr[i]) <span class="hljs-keyword">return</span> tarr[i];    &#125;    <span class="hljs-keyword">return</span> tarr[sarr.length];&#125;;<span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ch <span class="hljs-keyword">of</span> s) res ^= ch.charCodeAt();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ch <span class="hljs-keyword">of</span> t) res ^= ch.charCodeAt();    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(res);&#125;;</code></pre></div><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h3><p>水平翻转加对角线反转就是旋转</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">const</span> n = matrix.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">Math</span>.floor(n/<span class="hljs-number">2</span>);i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;            [matrix[i][j], matrix[n-i<span class="hljs-number">-1</span>][j]] = [matrix[n-i<span class="hljs-number">-1</span>][j], matrix[i][j]];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];        &#125;    &#125;&#125;;</code></pre></div><h3 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></h3><p>indexOf从i开始找栈顶元素保证栈中可以保留每个字符一次，不会误删除</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">let</span> stack = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = s.length;i &lt; len;i++) &#123;        <span class="hljs-keyword">let</span> ch = s[i];        <span class="hljs-keyword">if</span>(stack.indexOf(ch) &gt; <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">while</span>(stack.length &gt; <span class="hljs-number">0</span> &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>] &gt; ch &amp;&amp; s.indexOf(stack[stack.length - <span class="hljs-number">1</span>], i) &gt; i) stack.pop();        stack.push(ch);    &#125;    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">''</span>);&#125;;</code></pre></div><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层序遍历</a></h3><p>用双端队列写更简单，一层循环用布尔值控制方向(push还是unshift)</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">let</span> left = [];    <span class="hljs-keyword">let</span> right = [];    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    left.push(root);    <span class="hljs-keyword">while</span>(left.length !== <span class="hljs-number">0</span> || right.length !== <span class="hljs-number">0</span>) &#123;        res[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        <span class="hljs-keyword">if</span>(left.length !== <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(left.length !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">let</span> node = left.pop();                res[i].push(node.val);                <span class="hljs-keyword">if</span>(node.left !== <span class="hljs-literal">null</span>) right.push(node.left);                <span class="hljs-keyword">if</span>(node.right !== <span class="hljs-literal">null</span>) right.push(node.right);            &#125;            i++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(right.length !== <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(right.length !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">let</span> node = right.pop();                res[i].push(node.val);                <span class="hljs-keyword">if</span>(node.right !== <span class="hljs-literal">null</span>) left.push(node.right);                <span class="hljs-keyword">if</span>(node.left !== <span class="hljs-literal">null</span>) left.push(node.left);            &#125;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">使用最小花费爬楼梯</a></h3><p>到达i的方式只有两种：从i-1走一步或从i-2走两步，动态规划即可，可以优化空间</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(cost.length).fill(<span class="hljs-number">0</span>);    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>, len = cost.length;i &lt; len;i++) &#123;        dp[i] = cost[i] + <span class="hljs-built_in">Math</span>.min(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(dp[cost.length<span class="hljs-number">-1</span>],dp[cost.length<span class="hljs-number">-2</span>]);&#125;;</code></pre></div><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">分发糖果</a></h3><p>同时满足左遍历和右遍历条件的最大值，没太看懂如何证明有效</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(ratings.length).fill(<span class="hljs-number">1</span>);    <span class="hljs-keyword">let</span> right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(ratings.length).fill(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, len = ratings.length;i &lt; len;i++) &#123;        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>]) left[i] = left[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">let</span> count = left[ratings.length - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = ratings.length - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) right[i] = right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        count += <span class="hljs-built_in">Math</span>.max(left[i],right[i]);    &#125;    <span class="hljs-keyword">return</span> count;&#125;;</code></pre></div><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">分发饼干</a></h3><p>贪心就可以</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    <span class="hljs-keyword">let</span> childNum = g.length, cookieNum = s.length;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;i &lt; childNum &amp;&amp; j &lt; cookieNum;i++, j++) &#123;        <span class="hljs-keyword">while</span>(j &lt; cookieNum &amp;&amp; g[i] &gt; s[j]) j++;        <span class="hljs-keyword">if</span>(j &lt; cookieNum) res++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h4 id="圣诞节快乐！！！"><a href="#圣诞节快乐！！！" class="headerlink" title="圣诞节快乐！！！"></a>圣诞节快乐！！！</h4><h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p>和之前的最大柱状图一个道理，统计矩阵每个点左侧1的数量后就相当于将每一列都看作一排柱状图的底，将这些列作为输入送到最大柱状图的代码中找到最大值即可</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maximalRectangle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">const</span> m = matrix.length;    <span class="hljs-keyword">if</span> (m === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">const</span> n = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">const</span> left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (matrix[i][j] === <span class="hljs-string">'1'</span>) &#123;                left[i][j] = (j === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">let</span> height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;            height[j] = left[j][i];        &#125;        res = <span class="hljs-built_in">Math</span>.max(res,largestRectangleArea(height));    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> stack = [];    heights = [<span class="hljs-number">0</span>,...heights,<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;heights.length;i++) &#123;        <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stack[stack.length<span class="hljs-number">-1</span>]]) &#123;            <span class="hljs-keyword">let</span> stackTopIndex = stack.pop();            maxArea = <span class="hljs-built_in">Math</span>.max(maxArea,heights[stackTopIndex]*(i-stack[stack.length<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>));        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12月做题记录&quot;&gt;&lt;a href=&quot;#12月做题记录&quot; class=&quot;headerlink&quot; title=&quot;12月做题记录&quot;&gt;&lt;/a&gt;12月做题记录&lt;/h1&gt;&lt;h3 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>11月做题记录</title>
    <link href="http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/11/01/11%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-01T04:45:34.000Z</published>
    <updated>2020-11-18T03:03:19.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11月做题记录"><a href="#11月做题记录" class="headerlink" title="11月做题记录"></a>11月做题记录</h1><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p>dp搜索每一个nums[i]之前的项，赋给其能给的最大值，所以优化时间复杂度可以使用二分</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// var lengthOfLIS = function(nums) &#123;</span><span class="hljs-comment">//     dp = [1];</span><span class="hljs-comment">//     for(var i=1;dp[i]=1,i&lt;nums.length;i++) &#123;</span><span class="hljs-comment">//         for(var j=0;j&lt;i;j++) &#123;</span><span class="hljs-comment">//             nums[i]&gt;nums[j] &amp;&amp; (dp[i]=Math.max(dp[j]+1,dp[i]));</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return nums.length&lt;2?nums.length:Math.max(...dp);</span><span class="hljs-comment">// &#125;;</span><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = nums.length;    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        <span class="hljs-keyword">if</span>(nums[i]&gt;tail[end]) &#123;            end++;            tail[end] = nums[i];        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">let</span> right = end;            <span class="hljs-keyword">while</span>(left&lt;right) &#123;                <span class="hljs-keyword">let</span> mid = left + <span class="hljs-built_in">parseInt</span>((right-left)/<span class="hljs-number">2</span>);                <span class="hljs-keyword">if</span>(tail[mid] &lt; nums[i]) left = mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right = mid;            &#125;            tail[left] = nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p>要求找到环形入口，并且空间复杂度为O(1)，所以不能用hashset，用快慢指针，由于F=2S，F=S+nb <code>F比S多走了N个b环的距离，并且走的距离是S的两倍</code>，S=nb，相遇时慢指针一定走过n个环的距离，每次慢指针走到环入口一定是a+nb，所以S接下来到入口的距离就是a，此时把F放置在head，二者同时移动，相遇时就是入口</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> slow = head;    <span class="hljs-keyword">var</span> fast = head;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;         <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span> || fast.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        slow = slow.next;        fast = fast.next.next;        <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;    &#125;    fast = head;    <span class="hljs-keyword">while</span>(slow != fast) &#123;        slow = slow.next;        fast = fast.next;    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div><h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p>从左往右依次遍历heighs，如果递增则说明此时较高的bar还有增长空间，如果遇到比前一个矮的bar，则说明之前的bar已经到达极限可以开始计算，之前的bar无论是否是等高的都可以回推左边界，因为每回推一次都更新最大面积，如果不等高则宽为1，如果等高最左边的高bar会提供最大的宽度，这样算出来的最大面积就是有效的，JS使用栈真的好方便。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> stack = [];    heights = [<span class="hljs-number">0</span>,...heights,<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;heights.length;i++) &#123;        <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stack[stack.length<span class="hljs-number">-1</span>]]) &#123;            <span class="hljs-keyword">let</span> stackTopIndex = stack.pop();            maxArea = <span class="hljs-built_in">Math</span>.max(maxArea,heights[stackTopIndex]*(i-stack[stack.length<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>));        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;;</code></pre></div><p>其中用到JS中的<a href="https://www.cnblogs.com/wangyunhui/p/7511615.html" target="_blank" rel="noopener">扩展运算符</a></p><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p>ES5和ES6的类定义方法不一样，ES5中用函数的形式，ES6可以想Java一样用class定义，使用内置对象Map，其中keys方法返回一个包含插入的键值顺序的Iterator，越晚插入的排越后面</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(capacity) &#123;        <span class="hljs-keyword">this</span>.capacity = capacity;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    &#125;    <span class="hljs-keyword">get</span>(key) &#123;        <span class="hljs-keyword">let</span> val = <span class="hljs-keyword">this</span>.map.get(key);        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(val) === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-keyword">this</span>.map.delete(key);        <span class="hljs-keyword">this</span>.map.set(key,val);        <span class="hljs-keyword">return</span> val;    &#125;    put(key,value) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.map.has(key)) <span class="hljs-keyword">this</span>.map.delete(key);        <span class="hljs-keyword">this</span>.map.set(key,value);        <span class="hljs-keyword">let</span> keys = <span class="hljs-keyword">this</span>.map.keys();        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.map.size&gt;<span class="hljs-keyword">this</span>.capacity) <span class="hljs-keyword">this</span>.map.delete(keys.next().value);    &#125;&#125;</code></pre></div><h3 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><p>搜索词语和搜索前缀只有判定isEnd不同</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.next = &#123;&#125;;        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * Inserts a word into the trie. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment">    */</span>    insert(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;            <span class="hljs-keyword">if</span>(!node.next[word[i]]) node.next[word[i]] = <span class="hljs-keyword">new</span> TrieNode();            node = node.next[word[i]];        &#125;        node.isEnd = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * Returns if the word is in the trie. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">    */</span>    search(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(word);        <span class="hljs-keyword">return</span> node!=<span class="hljs-literal">null</span> &amp;&amp; node.isEnd;    &#125;    searchPrefix(word) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;            <span class="hljs-keyword">if</span>(node.next[word[i]]) node = node.next[word[i]];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> node;    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">    * Returns if there is any word in the trie that starts with the given prefix. </span><span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">prefix</span></span></span><span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">    */</span>     startsWith(prefix) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(prefix);        <span class="hljs-keyword">return</span> node !=<span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new Trie()</span><span class="hljs-comment"> * obj.insert(word)</span><span class="hljs-comment"> * var param_2 = obj.search(word)</span><span class="hljs-comment"> * var param_3 = obj.startsWith(prefix)</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">汉明距离</a></h3><p>布赖恩·克尼根算法，x异或x-1可以消除最右侧的1</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">var</span> xor = x ^ y;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(xor) &#123;        res++;        xor &amp;= xor<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p>类似环形链表找入口，因为有重复数，所以必定存在环，按索引找下一个节点<code>i=nums[i]</code></p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span> &#123;        slow = nums[slow];        fast = nums[nums[fast]];    &#125;<span class="hljs-keyword">while</span>(slow != fast)    slow = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(slow != fast) &#123;        slow = nums[slow];        fast = nums[fast];    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div><h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h3><p>自己的做法是将数组中的元素与下标一一对应，如果有数字没有在它“正确”的位置上就说明这个位置缺少数字，但这样做时间复杂度貌似不符合要求。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findDisappearedNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;        <span class="hljs-keyword">while</span>(nums[i]!=i+<span class="hljs-number">1</span> &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>]!=nums[i]) swap(nums,i);     &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;        <span class="hljs-keyword">if</span>(nums[i] != i+<span class="hljs-number">1</span>) res[j++]=i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums,i</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = nums[nums[i]<span class="hljs-number">-1</span>];    nums[nums[i]<span class="hljs-number">-1</span>] = nums[i];    nums[i] = tmp; &#125;</code></pre></div><p>官方解答是遍历原数组，将<code>nums[nums[i]-1]</code>*-1，如果已经是负数则不需要再×-1，遍历完成后只有缺失数字的下标处对应的数组值是正值。</p><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p>解答做法是用滑动窗口，因为不需要与匹配字符串完全相同，所以用HashMap统计每个字符出现的次数，与匹配符相同就可以了，但是录入时就需要注意控制窗口的大小与匹配符一样大才行</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> needs=&#123;&#125;,windows=&#123;&#125;;    <span class="hljs-keyword">let</span> match=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;p.length;i++) &#123;        needs[p[i]]?needs[p[i]]++:needs[p[i]]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">let</span> needsLen = <span class="hljs-built_in">Object</span>.keys(needs).length;    <span class="hljs-keyword">while</span>(right &lt; s.length) &#123;        <span class="hljs-keyword">let</span> c1 = s[right];        <span class="hljs-keyword">if</span>(needs[c1]) &#123;            windows[c1]?windows[c1]++:windows[c1]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(windows[c1] == needs[c1]) match++;        &#125;        right++;        <span class="hljs-keyword">while</span>(match == needsLen) &#123;            <span class="hljs-keyword">if</span>(right-left == p.length) res.push(left);            <span class="hljs-keyword">let</span> c2 = s[left];            <span class="hljs-keyword">if</span>(needs[c2]) &#123;                <span class="hljs-keyword">if</span>(--windows[c2] &lt; needs[c2]) match--;            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p>这是并查集做法，也可以把关系看成图的边，求解就是找图中两点是否存在路径，可以用DFS，BFS</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> calcEquation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">equations, values, queries</span>) </span>&#123;    <span class="hljs-keyword">let</span> parentMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">let</span> valueMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; equations.length; i++) &#123;        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;            parentMap.set(equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;            parentMap.set(equations[i][<span class="hljs-number">1</span>], equations[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;            valueMap.set(equations[i][<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;            valueMap.set(equations[i][<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);        &#125;        union(parentMap, valueMap, equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">1</span>], values[i]);    &#125;    <span class="hljs-keyword">const</span> result = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;        <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, queries[i][<span class="hljs-number">0</span>]);        <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, queries[i][<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (!tmp1 || !tmp2) &#123;            result.push(<span class="hljs-number">-1.0</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (tmp1.index === tmp2.index) &#123;            result.push(tmp1.value / tmp2.value);        &#125;        <span class="hljs-keyword">else</span> &#123;            result.push(<span class="hljs-number">-1.0</span>);        &#125;         &#125;    <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">parentMap, valueMap, index1, index2, value</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, index1);    <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, index2);    parentMap.set(tmp1.index, tmp2.index);    valueMap.set(tmp1.index, (value * tmp2.value) / tmp1.value);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">parentMap, valueMap, index</span>) </span>&#123;    <span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (parentMap.get(index) &amp;&amp; parentMap.get(index) !== index) &#123;        value *= valueMap.get(index);        index = parentMap.get(index);    &#125;    <span class="hljs-keyword">if</span> (!parentMap.get(index)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> &#123;        index,        value    &#125;;&#125;</code></pre></div><h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p>自己写的这个递归太多所以效率很差，可以用内部函数使用res全局变量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">return</span> calmax(root);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caldistance</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> lefthigh=<span class="hljs-number">0</span>,rigthhigh=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(root.left !== <span class="hljs-literal">null</span>) lefthigh = calhigh(root.left);    <span class="hljs-keyword">if</span>(root.right !== <span class="hljs-literal">null</span>) rigthhigh = calhigh(root.right);    <span class="hljs-keyword">return</span> lefthigh+rigthhigh;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calhigh</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(calhigh(root.left),calhigh(root.right))+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calmax</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(caldistance(root),calmax(root.left),calmax(root.right));&#125;</code></pre></div><p>其中res作为全局变量进入每一轮的递归中，效率更高</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depth</span>(<span class="hljs-params">node</span>) </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> L = depth(node.left);        <span class="hljs-keyword">let</span> R = depth(node.right);        res = <span class="hljs-built_in">Math</span>.max(res,L+R);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(L,R)+<span class="hljs-number">1</span>;    &#125;    depth(root);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p>JS在返回{}这种元组的时候不是按照下标0，1，2索引的，而是传递的变量名作为key来索引</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> decodeString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">return</span> dfs(s,<span class="hljs-number">0</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">s,i</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-string">""</span>;    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt; s.length) &#123;        <span class="hljs-keyword">if</span>(s.charAt(i)&gt;=<span class="hljs-string">'0'</span> &amp;&amp; s.charAt(i)&lt;=<span class="hljs-string">'9'</span>) num = num*<span class="hljs-number">10</span> + <span class="hljs-built_in">Number</span>.parseInt(s.charAt(i));        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'['</span>) &#123;            <span class="hljs-keyword">let</span> tmp = dfs(s,i+<span class="hljs-number">1</span>);            i = tmp[<span class="hljs-string">'i'</span>];            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>) &#123;                res = res + tmp[<span class="hljs-string">'res'</span>];                num--;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">']'</span>) <span class="hljs-keyword">return</span> &#123;i,res&#125;;        <span class="hljs-keyword">else</span> res += s.charAt(i);        i++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特位计数</a></h3><p>对于奇数，只是最后一位比它前面的偶数多了一个1，而对于偶数，除以二不会影响1的个数，只是让末尾少了一个0</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> countBits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++) &#123;        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[i] = res[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> res[i] = res[i/<span class="hljs-number">2</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h3><p>其实就是遍历顺序换一下，全局变量替换传参数确实方便很多</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> convertBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>) </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        root.val += pre;        pre = root.val;        dfs(root.left);    &#125;    dfs(root);    <span class="hljs-keyword">return</span> root;&#125;;</code></pre></div><h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h3><p>就是想不到怎么才能控制递归中对数组访问的位置</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = preorder.length;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) map.set(inorder[i],i);        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span>(<span class="hljs-params">preorder,inorder,preorder_left,preorder_right,inorder_left,inorder_right</span>) </span>&#123;        <span class="hljs-keyword">if</span>(preorder_left &gt; preorder_right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">let</span> preorder_root = preorder_left;        <span class="hljs-keyword">let</span> inorder_root = map.get(preorder[preorder_root]);        <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(preorder[preorder_root]);        <span class="hljs-keyword">let</span> size_left = inorder_root-inorder_left;        root.left = build(preorder,inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+size_left,inorder_left,inorder_root<span class="hljs-number">-1</span>);        root.right = build(preorder,inorder,preorder_left+size_left+<span class="hljs-number">1</span>,preorder_right,inorder_root+<span class="hljs-number">1</span>,inorder_right);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">return</span> build(preorder,inorder,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);&#125;;</code></pre></div><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p>自底向上计算，应用之前用过的最优解，自顶向下也可以，但需要记录已经计算的值，不然会有很多重复的子结构重复计算</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> coinChange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coins, amount</span>) </span>&#123;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(amount+<span class="hljs-number">1</span>);    dp.fill(amount+<span class="hljs-number">1</span>);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=amount;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;coins.length;j++) &#123;            <span class="hljs-keyword">if</span>(i &gt;= coins[j]) dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i],dp[i-coins[j]]+<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount]&gt;amount?<span class="hljs-number">-1</span>:dp[amount];&#125;;</code></pre></div><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></h3><p>要求是根据层级将结果分开，所以要记录每一层的节点个数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">let</span> q = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;    q.push(root);    <span class="hljs-keyword">while</span>(q.length != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">let</span> num = q.length;        res[l] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;            <span class="hljs-keyword">let</span> node = q.shift();            res[l].push(node.val);            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) q.push(node.left);            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) q.push(node.right);        &#125;        l++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><p>可以说剑指offer和HOT100总算是刷过一遍了，打算之后主要复习旧题，做做每日一题就可以，然后就是熟悉下牛客网站的做题。</p><p>这里之后放的一般是每日一题和用JS做的复习题</p><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h3><p>数学证明，如果X无法到达Y，则对于X与Y之间的任意Z，都到达不了Y</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gas, cost</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = gas.length;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt; n) &#123;        <span class="hljs-keyword">let</span> sumGas=<span class="hljs-number">0</span>, sumCost=<span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(cnt&lt;n) &#123;            <span class="hljs-keyword">const</span> j = (i+cnt)%n;            sumGas+=gas[j];            sumCost+=cost[j];            <span class="hljs-keyword">if</span>(sumCost &gt; sumGas) <span class="hljs-keyword">break</span>;            cnt++;        &#125;        <span class="hljs-keyword">if</span>(cnt === n) <span class="hljs-keyword">return</span> i;        <span class="hljs-keyword">else</span> i = i+cnt+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11月做题记录&quot;&gt;&lt;a href=&quot;#11月做题记录&quot; class=&quot;headerlink&quot; title=&quot;11月做题记录&quot;&gt;&lt;/a&gt;11月做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长上升子序列&quot;&gt;&lt;a href=&quot;#最长上升子序列&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>9月做题记录</title>
    <link href="http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-01T09:45:34.000Z</published>
    <updated>2020-09-28T03:41:08.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9月做题记录"><a href="#9月做题记录" class="headerlink" title="9月做题记录"></a>9月做题记录</h1><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[][] mark;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] board;    <span class="hljs-keyword">public</span> String word;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        m = board.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        n = board[<span class="hljs-number">0</span>].length;        mark = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">this</span>.word = word;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(dfs(i,j,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start==word.length()-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> board[i][j] == word.charAt(start);        <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(start)) &#123;            mark[i][j] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++) &#123;                <span class="hljs-keyword">int</span> newx = i+direction[k][<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newy = j+direction[k][<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span>(inArea(newx,newy) &amp;&amp; !mark[newx][newy]) &#123;                    <span class="hljs-keyword">if</span>(dfs(newx,newy,start+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;            mark[i][j] = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;n;    &#125;&#125;</code></pre></div><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> val = node.val;        <span class="hljs-keyword">if</span>(lower!=<span class="hljs-keyword">null</span> &amp;&amp; val&lt;=lower) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(upper!=<span class="hljs-keyword">null</span> &amp;&amp; val&gt;=upper) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.left,lower,val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(!helper(node.right,val,upper)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p>画个图，数量最多的任务排成一列，每个占n个位置的一行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:tasks) map[c-<span class="hljs-string">'A'</span>]++;        Arrays.sort(map);        <span class="hljs-keyword">int</span> max_val=map[<span class="hljs-number">25</span>]-<span class="hljs-number">1</span>, pool=max_val*n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">24</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; map[i]&gt;<span class="hljs-number">0</span>;i--) pool -= Math.min(max_val,map[i]);        <span class="hljs-keyword">return</span> pool&gt;<span class="hljs-number">0</span>?pool+tasks.length:tasks.length;    &#125;&#125;</code></pre></div><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p>动态规划，<code>dp[i][j]</code>为前i个数可以组成和为j的方法的个数，则有<code>dp[i][j]=dp[i-1][j-num[i]]+dp[i-1][j+num[i]]</code>，或者用递归也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];        dp[nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] = <span class="hljs-number">1</span>;        dp[-nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1000</span>] += <span class="hljs-number">1</span>;        <span class="hljs-comment">// 因为nums[0]可能是0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2001</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=-<span class="hljs-number">1000</span>;sum&lt;=<span class="hljs-number">1000</span>;sum++) &#123;                <span class="hljs-keyword">if</span>(dp[sum+<span class="hljs-number">1000</span>]&gt;<span class="hljs-number">0</span>) &#123;                    next[sum+<span class="hljs-number">1000</span>+nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                    next[sum+<span class="hljs-number">1000</span>-nums[i]] += dp[sum+<span class="hljs-number">1000</span>];                &#125;            &#125;            dp = next;        &#125;        <span class="hljs-keyword">return</span> S&gt;<span class="hljs-number">1000</span>?<span class="hljs-number">0</span>:dp[S+<span class="hljs-number">1000</span>];    &#125;&#125;</code></pre></div><h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p>前K问题一般考虑快排，但我是直接统计次数然后排序。。暴力解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">int</span> value = map.getOrDefault(num,<span class="hljs-number">0</span>).intValue()+<span class="hljs-number">1</span>;            map.put(num,value);        &#125;        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());        list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;              <span class="hljs-keyword">return</span> o2.getValue().compareTo(o1.getValue());          &#125;        &#125;);        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) res[i]=list.get(i).getKey();        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p>总是忘了怎么写</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> check(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> &amp;&amp; q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span> || q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);    &#125;&#125;</code></pre></div><h3 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p>不能使用滑动窗口的原因是数组内可能有负值，无法确定右移多少位置会使新加入的值的和为0</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;            pre += nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(pre-k)) res += map.get(pre-k);            map.put(pre,map.getOrDefault(pre,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p>归并排序，没太懂时间复杂度和空间复杂度如何符合要求</p><div class="hljs"><pre><code class="hljs vbscript">/** * Definition <span class="hljs-keyword">for</span> singly-linked list. * <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123; *     <span class="hljs-built_in">int</span> val; *     ListNode <span class="hljs-keyword">next</span>; *     ListNode(<span class="hljs-built_in">int</span> x) &#123; val = x; &#125; * &#125; */<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> ListNode sortList(ListNode head) &#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span>==<span class="hljs-literal">null</span>) return head;        ListNode slow=head,fast=head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>) &#123;            slow = slow.<span class="hljs-keyword">next</span>;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        ListNode tmp = slow.<span class="hljs-keyword">next</span>;        slow.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;        ListNode <span class="hljs-built_in">left</span> = sortList(head);        ListNode <span class="hljs-built_in">right</span> = sortList(tmp);        ListNode h = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode res = h;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">left</span>!=<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">right</span>!=<span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &lt;= <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>;                <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>.<span class="hljs-keyword">next</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>.val &gt; <span class="hljs-built_in">right</span>.val) &#123;                h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">right</span>;                <span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>.<span class="hljs-keyword">next</span>;            &#125;            h = h.<span class="hljs-keyword">next</span>;        &#125;        h.<span class="hljs-keyword">next</span> = <span class="hljs-built_in">left</span>==<span class="hljs-literal">null</span>?<span class="hljs-built_in">right</span>:<span class="hljs-built_in">left</span>;        return res.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre></div><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p>开始想用队列做，发现题解这TM也能动态规划。。</p><p>把数组分成K大小的块，从左往右定义一个数组存放每个块起点到当前位置的最大值，再从右往左做相同操作，这样当一个窗口包括了两个块的部分区域时，这个窗口内最大值一定是右边块的从左往右数组的最右值，与左边块的从右往左数组的最左值之间的最大值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span>(n*k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        left[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        right[n-<span class="hljs-number">1</span>] = nums[n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i%k==<span class="hljs-number">0</span>) left[i] = nums[i];            <span class="hljs-keyword">else</span> left[i] = Math.max(left[i-<span class="hljs-number">1</span>],nums[i]);            <span class="hljs-keyword">int</span> j = n-i-<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>((j+<span class="hljs-number">1</span>)%k==<span class="hljs-number">0</span>) right[j] = nums[j];            <span class="hljs-keyword">else</span> right[j] = Math.max(right[j+<span class="hljs-number">1</span>],nums[j]);        &#125;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-k+<span class="hljs-number">1</span>;i++)            res[i] = Math.max(right[i],left[i+k-<span class="hljs-number">1</span>]);                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p>找个好起点移动就行</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=matrix.length;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> n=matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;m &amp;&amp; j&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(target == matrix[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(target &lt; matrix[i][j]) j--;            <span class="hljs-keyword">else</span> i++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p>自己做是克隆数组后排序，从前往后和从后往前分别找无序数组的起点和终点</p><p>官解的思路是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界，所以从头遍历找降序的最小值，从尾遍历找升序的最大值，然后再两次这样的遍历分别找二者的正确位置，这个区间就是res</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] help = nums.clone();        Arrays.sort(help);        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; nums[i]==help[i]) i++;        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j]==help[j]) j--;        <span class="hljs-keyword">return</span> j-i+<span class="hljs-number">1</span>;     &#125;&#125;</code></pre></div><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><ol><li>先按身高降序排序，相同身高按k升序排序，经过此次排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序。请记住这两点，敲黑板</li><li>创建一个集合，这个集合的每个元素是一个一维数组，也就是我们二维数组的一行。</li><li>以行为单位遍历排好序的people[][]数组，假设每行数据是p[], 把每行元素插入到集合的索引为p[1]的位置，</li><li>把集合中的数据转换为一个二维数组，返回即是正确结果</li></ol><p>下面解释为什么经过第三步后就达到了我们题目要求的输出结果：</p><p>经过第一步排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序，所以  在进行第三步的过程中，高的人的数据肯定是先被存入集合的，所以每当我们取出一行数据，集合中已有的元素的身高肯定都是大于等于当前元素的身高的，所以当我们取出p[]数组后，发现前面应该有p[1]个人比自己高或者高度和自己相同，那么当前元素就应该排在集合的p[1]下标的位置(仔细想想是不是)，好比说目前有一个队列的人，这些人要么比你高，要么和你一样高，现在要你插入入队中，保证你前面有p[1]个人的身高大于等于你，你是不是应该排在索引为p[1]的位置</p><p>所以经过第三步的插入操作后，把每个人都插入到了正确的位置，所以根据这个集合转换的二维数组当然就是正确结果了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;        Arrays.sort(people,<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>]?o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>]:o2[<span class="hljs-number">0</span>]-o1[<span class="hljs-number">0</span>];            &#125;        &#125;);        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] p:people) res.add(p[<span class="hljs-number">1</span>],p);        <span class="hljs-keyword">int</span> n = people.length;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p>这题也能动态规划。。时间复杂度为n*n^1/2，官解中有n^1/2的方法(数学方案)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;i-j*j&gt;=<span class="hljs-number">0</span>;j++)                dp[i] = Math.min(dp[i],dp[i-j*j]+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p>自己是用了两层递归，因为只用DFS函数的话某个节点作为起点递归到下一层时它的子节点还可以作为起点递归，而另一边这个节点作为中间节点递归的函数中它的子节点也被作为起点的函数调用，如果这个子节点是终点的话那就是重复计数了两次</p><p>题解中的思路是用前缀和，使用一个map存放从根节点到当前节点之前的所有前缀和及其计数。这样在遍历到当前节点时，无需二重DFS，直接通过求目标差值，这个差值如果是之前某个节点作为终点的路径和，那一定在map中有存放，并且value就是这个值的个数，O(1)时间即可得到以当前节点为目标和路径末尾的路径总数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        helper(root,sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        dfs(root,sum,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) helper(root.left,sum);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) helper(root.right,sum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> now)</span> </span>&#123;        now += root.val;        <span class="hljs-keyword">if</span>(sum == now) res++;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) dfs(root.left,sum,now);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) dfs(root.right,sum,now);    &#125;&#125;</code></pre></div><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p>不会做，背包问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) sum += num;        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[target+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target) dp[nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=target;nums[i]&lt;=j;j--) &#123;                <span class="hljs-keyword">if</span>(dp[target]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                dp[j] = dp[j] || dp[j-nums[i]];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[target];    &#125;&#125;</code></pre></div><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p>动态规划加空间优化，<code>dp[i][j]</code>表示由i到j位置的子串是否是回文串，若<code>j=i或j-i=1且s[i]=s[j]时</code>，它当然是回文串，但如果j与i相隔较远，则需要看<code>s[j]与s[i]是否相等，且dp[i+1][j-1]是否是回文串</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=j;i++) &#123;                <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j) &amp;&amp; (j-i&lt;=<span class="hljs-number">1</span> || dp[i+<span class="hljs-number">1</span>])) &#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    res++;                &#125;                <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><p>开始用JS做题吧，感觉需要提升JS的熟练度</p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p>官解的话：避免使用 O(n)额外空间的方法就是改变输入，所以用快慢指针找到中间节点，同时反转前面或后面的链表，之后按个比较，但官方多了将链表恢复原状，因为实际写成函数后使用者不会想要在调用函数后原链表被改变</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">let</span> mid = head;    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">let</span> reverse = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.next!=<span class="hljs-literal">null</span>) &#123;        pre = mid;        mid = mid.next;        head = head.next.next;        pre.next = reverse;        reverse = pre;    &#125;    <span class="hljs-keyword">if</span>(head) mid = mid.next;    <span class="hljs-keyword">while</span>(mid) &#123;        <span class="hljs-keyword">if</span>(reverse.val != mid.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        reverse = reverse.next;        mid = mid.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p>官解中的并查集写的很棒，DFS和BFS都可以，遍历到值为1的点时开始找这个点所在的连通分量并将其中包含的所有点都变为0，不影响之后寻找其他连通分量，最后岛屿的数量就是连通分量的个数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> numIslands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;    <span class="hljs-keyword">const</span> rows = grid.length;    <span class="hljs-keyword">if</span>(rows==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++) &#123;            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">"1"</span>) &#123;                dfs(grid,i,j,rows,cols);                res++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">grid,i,j,rows,cols</span>) </span>&#123;    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;rows<span class="hljs-number">-1</span> || j&gt;cols<span class="hljs-number">-1</span> || grid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    grid[i][j] = <span class="hljs-string">"0"</span>;    dfs(grid,i+<span class="hljs-number">1</span>,j,rows,cols);    dfs(grid,i<span class="hljs-number">-1</span>,j,rows,cols);    dfs(grid,i,j+<span class="hljs-number">1</span>,rows,cols);    dfs(grid,i,j<span class="hljs-number">-1</span>,rows,cols);&#125;</code></pre></div><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p>自己用双指针，向后找第一个0用i标记，i之后的第一个非0用j标记，交换二者，与官解区别在于交换次数少，主动找0，官解即使是i与j指向同一个非0元素也会交换</p><p>官解：从index=0开始，j指向元素不为0时与i指向元素交换，二者加一，指向为0时i不动j加一</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len=nums.length;    <span class="hljs-keyword">while</span>(j&lt;len) &#123;        <span class="hljs-keyword">while</span>(i&lt;len &amp;&amp; nums[i]!=<span class="hljs-number">0</span>) i++;        j=i;        <span class="hljs-keyword">while</span>(j&lt;len &amp;&amp; nums[j]==<span class="hljs-number">0</span>) j++;        <span class="hljs-keyword">if</span>(j&lt;len) help(nums,i,j);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">help</span>(<span class="hljs-params">nums,i,j</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = nums[i];    nums[i] = nums[j];    nums[j] = tmp;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">var moveZeroes = function(nums) &#123;</span><span class="hljs-comment">    let i=0;</span><span class="hljs-comment">    let j=0;</span><span class="hljs-comment">    let len=nums.length;</span><span class="hljs-comment">    for(j=0;j&lt;len;j++) &#123;</span><span class="hljs-comment">        if(nums[j]!=0) swap(i++,j);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p>和之前做过的思路不同在于，每次新进栈的元素都和最小栈的栈顶元素比较一个最小值后决定，不论是哪个最小栈元素都会新增，所以在出栈时只要同时删除最小栈和主栈的栈顶就可以(不用担心会将最小元素删掉，因为如果主栈删掉的不是它，那最小栈删掉的也只是其复制体，主体还在下面)</p><p>顺便提一下JS的原型链是干嘛的来着。。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack = [];    <span class="hljs-keyword">this</span>.min_stack = [<span class="hljs-literal">Infinity</span>];&#125;;<span class="hljs-comment">/** </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.push(x);    <span class="hljs-keyword">this</span>.min_stack.push(<span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>],x));&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.x_stack.pop();    <span class="hljs-keyword">this</span>.min_stack.pop();&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x_stack[<span class="hljs-keyword">this</span>.x_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.min_stack[<span class="hljs-keyword">this</span>.min_stack.length<span class="hljs-number">-1</span>];&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new MinStack()</span><span class="hljs-comment"> * obj.push(x)</span><span class="hljs-comment"> * obj.pop()</span><span class="hljs-comment"> * var param_3 = obj.top()</span><span class="hljs-comment"> * var param_4 = obj.getMin()</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p>JS新建对象怎么做？</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t1, t2</span>) </span>&#123;    <span class="hljs-keyword">if</span>(t1==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t2;    <span class="hljs-keyword">if</span>(t2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t1;    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);    res.val = t1.val + t2.val;    res.left = mergeTrees(t1.left,t2.left);    res.right = mergeTrees(t1.right,t2.right);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p>DP</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProduct = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> min = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">let</span> pre_max = max;        max = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.max(max*nums[i],min*nums[i]),nums[i]);        min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.min(pre_max*nums[i],min*nums[i]),nums[i]);        res = <span class="hljs-built_in">Math</span>.max(res,max);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">最大正方形</a></h3><p>DP，记录每一个点作为正方形的右下角能完成的最大边长，就是它上方，左方，左上方三个点能完成边长的最小值，滚动数组优化</p><p>JS申请数组的方式好奇怪。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maximalSquare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">let</span> m = matrix.length;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> n = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> tmp2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">'0'</span>) &#123;                dp[j] = <span class="hljs-number">0</span>;                <span class="hljs-keyword">continue</span>;            &#125;            tmp2 = dp[j];            dp[j] = <span class="hljs-built_in">Math</span>.min(tmp,<span class="hljs-built_in">Math</span>.min(dp[j],dp[j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;            tmp = tmp2;            res = <span class="hljs-built_in">Math</span>.max(res,dp[j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res*res;&#125;;</code></pre></div><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p>摩尔投票！</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) res = nums[i];        count += res==nums[i]?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>做过的还是不会做。。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span> || root==p || root==q) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">let</span> left = lowestCommonAncestor(root.left,p,q);    <span class="hljs-keyword">let</span> right = lowestCommonAncestor(root.right,p,q);    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;    <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9月做题记录&quot;&gt;&lt;a href=&quot;#9月做题记录&quot; class=&quot;headerlink&quot; title=&quot;9月做题记录&quot;&gt;&lt;/a&gt;9月做题记录&lt;/h1&gt;&lt;h3 id=&quot;单词搜索&quot;&gt;&lt;a href=&quot;#单词搜索&quot; class=&quot;headerlink&quot; title=&quot;单</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
  </entry>
  
  <entry>
    <title>8月做题记录</title>
    <link href="http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/01/8%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-01T03:45:34.000Z</published>
    <updated>2020-08-31T09:08:05.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8月做题记录"><a href="#8月做题记录" class="headerlink" title="8月做题记录"></a>8月做题记录</h1><p>每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录</p><h3 id="最小区间"><a href="#最小区间" class="headerlink" title="最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">最小区间</a></h3><p>8月1日，一上来就给我整个这，昨天还误伤了本科同学给人家道歉，晚上要了暗恋的隔壁实验室小姐姐的VX结果发现和想象中的根本不是同一个人，下一周还要出差，我TM烦死</p><p>这题用堆做就是用那个优先队列，记录当前所有列表头指针指向元素中最大最小的两个，获取区间，之后将小值的列表指针后移，更新最小值和最大值，更新区间，当所有列表中有一个走完了就结束循环</p><p>用滑动窗口可太恶心了，用map映射了每一个值在哪些列表里出现过，key就是元素值，value是一个list存放所有包含这个key值的列表的索引，当窗口右指针滑到能包含所有列表索引，更新一次区间，然后左指针左移动，继续找新区间，循环是所有数字中最大最小的两个，相当于遍历所有key。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;        <span class="hljs-keyword">int</span> size = nums.size();        Map&lt;Integer, List&lt;Integer&gt;&gt; indices = <span class="hljs-keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">int</span> xMin = Integer.MAX_VALUE, xMax = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums.get(i)) &#123;                List&lt;Integer&gt; list = indices.getOrDefault(x, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());                list.add(i);                indices.put(x, list);                xMin = Math.min(xMin, x);                xMax = Math.max(xMax, x);            &#125;        &#125;        <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];        <span class="hljs-keyword">int</span> inside = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = xMin, right = xMin - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> bestLeft = xMin, bestRight = xMax;        <span class="hljs-keyword">while</span> (right &lt; xMax) &#123;            right++;            <span class="hljs-keyword">if</span> (indices.containsKey(right)) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : indices.get(right)) &#123;                    freq[x]++;                    <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">1</span>) &#123;                        inside++;                    &#125;                &#125;                <span class="hljs-keyword">while</span> (inside == size) &#123;                    <span class="hljs-keyword">if</span> (right - left &lt; bestRight - bestLeft) &#123;                        bestLeft = left;                        bestRight = right;                    &#125;                    <span class="hljs-keyword">if</span> (indices.containsKey(left)) &#123;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: indices.get(left)) &#123;                            freq[x]--;                            <span class="hljs-keyword">if</span> (freq[x] == <span class="hljs-number">0</span>) &#123;                                inside--;                            &#125;                        &#125;                    &#125;                    left++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;bestLeft, bestRight&#125;;    &#125;&#125;</code></pre></div><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></h3><p>唉，，最近的hard都不会做。。这题用动规也可，只不过双指针更秀</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> leftmax=<span class="hljs-number">0</span>, rightmax=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(left&lt;right) &#123;            <span class="hljs-keyword">if</span>(height[left] &lt;= height[right]) &#123;                <span class="hljs-keyword">if</span>(height[left]&gt;=leftmax) leftmax=height[left];                <span class="hljs-keyword">else</span> res+=leftmax-height[left];                left++;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(height[right]&gt;=rightmax) rightmax=height[right];                <span class="hljs-keyword">else</span> res+=rightmax-height[right];                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        flatten(root.right);        flatten(root.left);        root.right = pre;        root.left = <span class="hljs-keyword">null</span>;        pre = root;    &#125;&#125;</code></pre></div><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a></h3><p>看K神实现的BFS拓扑排序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];        List&lt;List&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++) adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] cp:prerequisites) &#123;            indegrees[cp[<span class="hljs-number">0</span>]]++;            adj.get(cp[<span class="hljs-number">1</span>]).add(cp[<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)            <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>) q.add(i);        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> pre = q.poll();            numCourses--;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur:adj.get(pre))                <span class="hljs-keyword">if</span>(--indegrees[cur] == <span class="hljs-number">0</span>) q.add(cur);        &#125;        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">字符串相加</a></h3><p>每次遇到这种简单题都有点懵逼。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);        <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> n1 = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> n2 = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">'0'</span> : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> tmp = n1 + n2 + carry;            carry = tmp / <span class="hljs-number">10</span>;            res.append(tmp % <span class="hljs-number">10</span>);            i--; j--;        &#125;        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) res.append(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res.reverse().toString();    &#125;&#125;</code></pre></div><h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p>遍历二叉树DP，每个根节点都分为偷与不偷两种情况，用哈希表存储每个节点作为根节点能偷到的最大值(维护两个哈希表分别记录偷与不偷)，可以空间优化。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] res = dfs(root);        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dfs(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[] l = dfs(root.left);        <span class="hljs-keyword">int</span>[] r = dfs(root.right);        <span class="hljs-keyword">int</span> select = root.val + l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> notselect = Math.max(l[<span class="hljs-number">0</span>],l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>],r[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;select,notselect&#125;;    &#125;&#125;</code></pre></div><h3 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">计数二进制子串</a></h3><p>由于0和1都必须是连续的，所以把S分成了0和1个数组成的一个数组[2,3,1,3]，相邻数字分别是0或1，所以取较小值就是他们能组成的合法的子序列的个数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> ptr=<span class="hljs-number">0</span>,last=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>,n=s.length();        <span class="hljs-keyword">while</span>(ptr &lt; n) &#123;            <span class="hljs-keyword">char</span> cur = s.charAt(ptr);            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(ptr&lt;n &amp;&amp; s.charAt(ptr)==cur) &#123;                count++;                ptr++;            &#125;            res += Math.min(last,count);            last = count;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></h3><p>一般这种要求找出符合条件的字符串并放在list里面返回的都是使用DFS</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEG_COUNT=<span class="hljs-number">4</span>;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SEG_COUNT];    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">// segments = new int[SEG_COUNT];</span>        dfs(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> segID, <span class="hljs-keyword">int</span> segStart)</span> </span>&#123;        <span class="hljs-keyword">if</span>(segID == SEG_COUNT) &#123;            <span class="hljs-keyword">if</span>(segStart == s.length()) &#123;                StringBuffer ipaddr = <span class="hljs-keyword">new</span> StringBuffer();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SEG_COUNT;i++) &#123;                    ipaddr.append(segments[i]);                    <span class="hljs-keyword">if</span>(i!=SEG_COUNT-<span class="hljs-number">1</span>) ipaddr.append(<span class="hljs-string">'.'</span>);                &#125;                res.add(ipaddr.toString());            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(segStart == s.length()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(s.charAt(segStart) == <span class="hljs-string">'0'</span>) &#123;            segments[segID] = <span class="hljs-number">0</span>;            dfs(s,segID+<span class="hljs-number">1</span>,segStart+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> addr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> segEnd = segStart;segEnd&lt;s.length();segEnd++) &#123;            addr = addr*<span class="hljs-number">10</span> + (s.charAt(segEnd)-<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">if</span>(addr&gt;<span class="hljs-number">0</span> &amp;&amp; addr&lt;=<span class="hljs-number">255</span>) &#123;                segments[segID] = addr;                dfs(s,segID+<span class="hljs-number">1</span>,segEnd+<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></h3><p>本题优化难度在于如何不使用栈空间中序遍历二叉树，使用<code>Morris中序遍历</code>，由于搜索树的中序遍历是递增序列，所以在遍历过程中找到逆序对交换节点即可</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        TreeNode x = <span class="hljs-keyword">null</span>, y = <span class="hljs-keyword">null</span>, pred = <span class="hljs-keyword">null</span>, predecessor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span>                predecessor = root.left;                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-keyword">null</span> &amp;&amp; predecessor.right != root) &#123;                    predecessor = predecessor.right;                &#125;                                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-keyword">null</span>) &#123;                    predecessor.right = root;                    root = root.left;                &#125;                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span>                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                        y = root;                        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                            x = pred;                        &#125;                    &#125;                    pred = root;                    predecessor.right = <span class="hljs-keyword">null</span>;                    root = root.right;                &#125;            &#125;            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span>            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt; pred.val) &#123;                    y = root;                    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;                        x = pred;                    &#125;                &#125;                pred = root;                root = root.right;            &#125;        &#125;        swap(x, y);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = x.val;        x.val = y.val;        y.val = tmp;    &#125;&#125;</code></pre></div><h3 id="回文对"><a href="#回文对" class="headerlink" title="回文对"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">回文对</a></h3><p>不会做，需要使用<code>字典树 + manacher</code></p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h3><p>总算是自己做出一道DFS的组合问题了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        dfs(nums,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, List&lt;Integer&gt; cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(start == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;nums.length;i++) &#123;            cur.add(nums[i]);            swap(nums,i,start);            dfs(nums,start+<span class="hljs-number">1</span>,cur);            cur.remove(cur.size()-<span class="hljs-number">1</span>);            swap(nums,i,start);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h3><p>可以先按角平分线翻转之后再逐行对称反转，或者是像这样按每一个外圈旋转，然后往里面缩</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos2 = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (pos1 &lt; pos2)&#123;            add = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (add &lt; pos2 - pos1)&#123;                temp = matrix[pos1][pos1 + add];                matrix[pos1][pos1 + add] = matrix[pos2 - add][pos1];                matrix[pos2 - add][pos1] = matrix[pos2][pos2 -add];                matrix[pos2][pos2 -add] = matrix[pos1 + add][pos2];                matrix[pos1 + add][pos2] = temp;                add++;            &#125;            pos1++;            pos2--;        &#125;    &#125;&#125;</code></pre></div><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h3><p>可以分到一组的单词，他们之中出现的字符的个数一定都相等，用map保存这些个数，统计26个字母出现的个数用#分割作为key，或者对字符排序后作为key，只要二者一组则字母序排序一定是一样的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();        HashMap&lt;String,List&gt; res = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(String s: strs) &#123;            Arrays.fill(count,<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: s.toCharArray()) count[c-<span class="hljs-string">'a'</span>]++;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++) &#123;                sb.append(<span class="hljs-string">'#'</span>);                sb.append(count[i]);            &#125;            String key = sb.toString();            <span class="hljs-keyword">if</span>(!res.containsKey(key)) res.put(key,<span class="hljs-keyword">new</span> ArrayList());            res.get(key).add(s);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(res.values());    &#125;&#125;</code></pre></div><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></h3><p>用max保存遍历的每一个位置所能到达的最远位置，如果能超过末尾元素说明可达</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(i &lt;= max) &#123;                max = Math.max(max,i+nums[i]);                <span class="hljs-keyword">if</span>(max &gt;= n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h3><p>对tuple进行排序，java用数组排序的函数，有接口重写没太看懂，不知道用JS的话要怎么实现呢？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;        <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][];        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(intervals,Comparator.comparingInt(a-&gt;a[<span class="hljs-number">0</span>]));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] interval: intervals) &#123;            <span class="hljs-keyword">int</span> mergedSize = merged.size();            <span class="hljs-keyword">if</span> (merged.isEmpty()) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!merged.isEmpty() &amp;&amp; merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]) &#123;                merged.add(interval);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> lastRight = merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];                merged.get(mergedSize-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(lastRight, interval[<span class="hljs-number">1</span>]);            &#125;        &#125;        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);    &#125; &#125;</code></pre></div><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></h3><p>本身字符不需要改变可以直接等于<code>dp[i-1][j-1]</code>,<code>dp[i-1][j]</code>表示删除word1的最后一个字符，<code>dp[i][j-1]</code>表示在最后插入word2的最后一个字符，<code>dp[i-1][j-1]</code>表示word1的最后一个字符替换位word2的最后一个字符</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;        <span class="hljs-keyword">int</span> n1 = word1.length();        <span class="hljs-keyword">int</span> n2 = word2.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++) &#123;                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>)) dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                <span class="hljs-keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i][j-<span class="hljs-number">1</span>]),dp[i-<span class="hljs-number">1</span>][j])+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n1][n2];    &#125;&#125;</code></pre></div><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></h3><p>用指针指向边界，然后遍历时交换位置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>,p0=<span class="hljs-number">0</span>,p2=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(cur&lt;=p2) &#123;            <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">0</span>) &#123;                swap(nums,cur,p0);                cur++;                p0++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">2</span>) &#123;                swap(nums,cur,p2);                p2--;            &#125;            <span class="hljs-keyword">else</span> cur++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></h3><p>滑动窗口，不会做，check也看不懂是在干嘛。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">int</span> tLen = t.length();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;            <span class="hljs-keyword">char</span> c = t.charAt(i);            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len = Integer.MAX_VALUE, ansL = -<span class="hljs-number">1</span>, ansR = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> sLen = s.length();        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;            ++r;            <span class="hljs-keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;                    len = r - l + <span class="hljs-number">1</span>;                    ansL = l;                    ansR = l + len;                &#125;                <span class="hljs-keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);                &#125;                ++l;            &#125;        &#125;        <span class="hljs-keyword">return</span> ansL == -<span class="hljs-number">1</span> ? <span class="hljs-string">""</span> : s.substring(ansL, ansR);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;        Iterator iter = ori.entrySet().iterator();         <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;             Map.Entry entry = (Map.Entry) iter.next();             Character key = (Character) entry.getKey();             Integer val = (Integer) entry.getValue();             <span class="hljs-keyword">if</span> (cnt.getOrDefault(key, <span class="hljs-number">0</span>) &lt; val) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></h3><p>对输出的集合中每一个小序列添加新的数字后（这里复制用的是新空间），再放到输出集合中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; output = <span class="hljs-keyword">new</span> ArrayList();    output.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;      List&lt;List&lt;Integer&gt;&gt; newSubsets = <span class="hljs-keyword">new</span> ArrayList();      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : output) &#123;        newSubsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(curr)&#123;&#123;add(num);&#125;&#125;);      &#125;      <span class="hljs-keyword">for</span> (List&lt;Integer&gt; curr : newSubsets) &#123;        output.add(curr);      &#125;    &#125;    <span class="hljs-keyword">return</span> output;  &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8月做题记录&quot;&gt;&lt;a href=&quot;#8月做题记录&quot; class=&quot;headerlink&quot; title=&quot;8月做题记录&quot;&gt;&lt;/a&gt;8月做题记录&lt;/h1&gt;&lt;p&gt;每几天就做一份md太麻烦了还得重新加标签，以后就一月一份了，反正搜也能搜到而且有目录&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.23至7.31做题记录</title>
    <link href="http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/23/7.23%E8%87%B37.31%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-23T06:42:30.000Z</published>
    <updated>2020-07-31T05:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-23至7-31做题记录"><a href="#7-23至7-31做题记录" class="headerlink" title="7.23至7.31做题记录"></a>7.23至7.31做题记录</h1><p>今天开始做HOT100的题目，之前的题目会用JS作为复习更新在JS力扣练习的文章里。</p><p>7.23每日一题是矩阵的最短路径，就不贴上来了。</p><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a></h3><p>时间复杂度要求O(log(m + n))，所以使用两个指针移动计数寻找总长度一半这样的不行，因为复杂度为O(m+n)，题解利用两个数组是排序的，用二分来寻找中位数K，在A的K/2位置与B的K/2位置比较，较小的那一个之前的所有元素一定不包含中位数，所以可以直接排除掉K/2个数，循环即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> totalLength = length1 + length2;        <span class="hljs-keyword">if</span>(totalLength%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> mid = totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = getKthElement(nums1,nums2,mid+<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> median;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> mid1=totalLength/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, mid2=totalLength/<span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, mid1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, mid2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;            <span class="hljs-keyword">return</span> median;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> index1=<span class="hljs-number">0</span>, index2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> KthElement = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">if</span>(index1 == length1) <span class="hljs-keyword">return</span> nums2[index2+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(index2 == length2) <span class="hljs-keyword">return</span> nums1[index1+k-<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[index1],nums2[index2]);            <span class="hljs-keyword">int</span> half = k/<span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> newindex1 = Math.min(index1+half,length1)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> newindex2 = Math.min(index2+half,length2)-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> pivot1 = nums1[newindex1], pivot2 = nums2[newindex2];            <span class="hljs-keyword">if</span>(pivot1 &lt;= pivot2) &#123;                k -= (newindex1-index1+<span class="hljs-number">1</span>);                index1 = newindex1+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                k -= (newindex2-index2+<span class="hljs-number">1</span>);                index2 = newindex2+<span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>题解还给了一种O(min(m,n))的方法：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">力扣官方题解</a></p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></h3><p>真尼玛这也能动态规划，中心扩散，还有一种时间复杂度更低的我没有看</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;        String res = s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-comment">// 中心位置枚举到 len - 2 即可</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            String oddStr = centerSpread(s, i, i);            String evenStr = centerSpread(s, i, i + <span class="hljs-number">1</span>);            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;            <span class="hljs-keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;                maxLen = maxLenStr.length();                res = maxLenStr;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">centerSpread</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span>        <span class="hljs-comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span>        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">int</span> i = left;        <span class="hljs-keyword">int</span> j = right;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; len) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;                i--;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span>        <span class="hljs-keyword">return</span> s.substring(i + <span class="hljs-number">1</span>, j);    &#125;&#125;</code></pre></div><h3 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">分割数组的最大值</a></h3><p>是真的牛批，看题解都差点没看懂，这他妈也是DP，时间复杂度更低的是贪心二分，因为那个值一定在数组总和与其中最大元素值之间，通过二分这个值来判断分出来的数组个数是否满足要求，这样更优</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) Arrays.fill(f[i],Integer.MAX_VALUE);        <span class="hljs-keyword">int</span>[] sub = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) sub[i+<span class="hljs-number">1</span>] = sub[i]+nums[i];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=Math.min(i,m);j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++) &#123;                    f[i][j] = Math.min(f[i][j],Math.max(sub[i]-sub[k],f[k][j-<span class="hljs-number">1</span>]));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h3><p>我以为还是DP，想复杂了，双指针O(n)就能解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, j=height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j)            res = Math.max(res,height[i]&lt;height[j]?(j-i)*height[i++]:(j-i)*height[j--]);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列</a></h3><p>这个用双指针做的，但是如果要求很多个s求是否为子序列不太好，官解用了DP。。真的离谱，维护了一个DP数组查找每个位置下一个字符的位置在哪里，这样包装成函数会很好用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(t.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(j&lt;t.length()) &#123;            <span class="hljs-keyword">if</span>(t.charAt(j) == s.charAt(i)) i++;            <span class="hljs-keyword">if</span>(i == s.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            j++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><h3 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">矩阵中的最长递增路径</a></h3><p>每次控制方向移动的步骤都有点懵，官解用DFS和拓扑排序做，后者其实就是动态规划的思想，但它统计用队列去搞了，就是队列实现拓扑的方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int longestIncreasingPath(int[][] matrix) &#123;</span><span class="hljs-comment">//         int n=matrix.length, m=matrix[0].length;</span><span class="hljs-comment">//         int[][] f = new int[n][m];</span><span class="hljs-comment">//         int res = Integer.MIN_VALUE;</span><span class="hljs-comment">//         // for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//         //     for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//         //         f[i][j]=1;</span><span class="hljs-comment">//         //     &#125;</span><span class="hljs-comment">//         // &#125;</span><span class="hljs-comment">//         for(int i=1;i&lt;=n;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=m;j++) &#123;</span><span class="hljs-comment">//                 f[i][j] = </span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public int cal(int i, int j, int[][] matrix, int[][] f) &#123;</span><span class="hljs-comment">//         int top=0, bottom=0,left=0,right=0;</span><span class="hljs-comment">//         if((j-1)&gt;=0) &#123;</span><span class="hljs-comment">//             left = matrix[i][j-1];</span><span class="hljs-comment">//             77</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         if((j+1)&lt;matrix[0].length) right = matrix[i][j+1];</span><span class="hljs-comment">//         if((i-1)&gt;=0) top = matrix[i-1][j];</span><span class="hljs-comment">//         if((i+1)&lt;matrix.length) bottom = matrix[i+1][j];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;这是自己写的DP没写完就去吃小龙虾了。。。回来懒得写直接copy官解</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> rows, columns;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        rows = matrix.length;        columns = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][columns];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; columns; ++j) &#123;                ans = Math.max(ans, dfs(matrix, i, j, memo));            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span>[][] memo)</span> </span>&#123;        <span class="hljs-keyword">if</span> (memo[row][column] != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> memo[row][column];        &#125;        ++memo[row][column];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newRow = row + dir[<span class="hljs-number">0</span>], newColumn = column + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="hljs-number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;                memo[row][column] = Math.max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> memo[row][column];    &#125;&#125;</code></pre></div><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></h3><p>这题K神讲过，用递归深度遍历就行，就是输入每个键对应的字母有点麻烦</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Map&lt;String, String&gt; phone = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;    put(<span class="hljs-string">"2"</span>, <span class="hljs-string">"abc"</span>);    put(<span class="hljs-string">"3"</span>, <span class="hljs-string">"def"</span>);    put(<span class="hljs-string">"4"</span>, <span class="hljs-string">"ghi"</span>);    put(<span class="hljs-string">"5"</span>, <span class="hljs-string">"jkl"</span>);    put(<span class="hljs-string">"6"</span>, <span class="hljs-string">"mno"</span>);    put(<span class="hljs-string">"7"</span>, <span class="hljs-string">"pqrs"</span>);    put(<span class="hljs-string">"8"</span>, <span class="hljs-string">"tuv"</span>);    put(<span class="hljs-string">"9"</span>, <span class="hljs-string">"wxyz"</span>);  &#125;&#125;;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String curres, String nextdigit)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nextdigit.length() == <span class="hljs-number">0</span>) res.add(curres);        <span class="hljs-keyword">else</span> &#123;            String digit = nextdigit.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);            String letter = phone.get(digit);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;letter.length();i++) &#123;                String addletter = letter.substring(i,i+<span class="hljs-number">1</span>);                dfs(curres+addletter,nextdigit.substring(<span class="hljs-number">1</span>));            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits.length() != <span class="hljs-number">0</span>) dfs(<span class="hljs-string">""</span>,digits);        <span class="hljs-keyword">return</span> res;     &#125;&#125;</code></pre></div><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h3><p>自己写的迭代方法恶心的批爆，提交了官解的迭代，在这里码一下官解的递归，简洁明了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l2;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l1, l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="寻宝"><a href="#寻宝" class="headerlink" title="寻宝"></a><a href="https://leetcode-cn.com/problems/xun-bao/" target="_blank" rel="noopener">寻宝</a></h3><p>这个每日一题太强了，我不会做，看官解看的很吃力。</p><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h3><p>用递归回溯，没有考虑到其实只要当前添加位置右括号数量比左括号数量少就一定不会错误，而左括号在没有超过最大数目时可以任意添加</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;         List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();         recur(res,<span class="hljs-keyword">new</span> StringBuilder(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);         <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder cur, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close, <span class="hljs-keyword">int</span> max)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cur.length() == max*<span class="hljs-number">2</span>) &#123;            res.add(cur.toString());            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span>(open &lt; max) &#123;            cur.append(<span class="hljs-string">'('</span>);            recur(res,cur,open+<span class="hljs-number">1</span>,close,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span>(close &lt; open) &#123;            cur.append(<span class="hljs-string">')'</span>);            recur(res,cur,open,close+<span class="hljs-number">1</span>,max);            cur.deleteCharAt(cur.length()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></h3><p>合并两个链表和前面的那个方法一样，这里用的是分治的思路合并K个，官解中用优先队列也可以，Java中实现了优先队列的方法可以直接调用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists.length == <span class="hljs-number">0</span> || lists == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,lists.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> lists[left];        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        ListNode l1 = merge(lists,left,mid);        ListNode l2 = merge(lists,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1,l2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val) &#123;            l1.next = mergeTwoLists(l1.next,l2);            <span class="hljs-keyword">return</span> l1;        &#125;        <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l2.next,l1);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre></div><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h3><p>题目一开始没太看懂。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="hljs-number">1</span>]) i--;        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(j&gt;i &amp;&amp; nums[j]&lt;=nums[i]) j--;            swap(nums,i,j);        &#125;        reverse(nums,i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = start+<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            swap(nums,i,j);            i++;            j--;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre></div><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></h3><p>和之前找旋转点一个主要思路，<code>nums[left] &lt;= nums[mid]</code>需要加=号是因为如果target不在left到mid的区间需要<code>left=mid+1</code>，由于计算mid取整，所以mid和left是有可能一样的，没有等号就无法进入这条语句了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid]) &#123;                <span class="hljs-keyword">if</span>(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left=mid+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> right=mid-<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h3><p>二分的边界真的能把人写吐🤮，收藏一篇分析二分边界的文章：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">labuladong</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;=target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span> || nums[j]!=target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> right = j;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;=j) &#123;            <span class="hljs-keyword">int</span> m = (i+j)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m]&lt;target) i=m+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j=m-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,right&#125;;    &#125;&#125;</code></pre></div><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></h3><p>DFS添加和剪枝，先搞一个排序，注意为了不重复需要在循环中定义每次开始的循环位置。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        List&lt;Integer&gt; curres = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(candidates);        dfs(candidates,target,curres,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; curres, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(curres));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;candidates.length;i++) &#123;            <span class="hljs-keyword">if</span>(target-candidates[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            curres.add(candidates[i]);            dfs(candidates,target-candidates[i],curres,i);            curres.remove(curres.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-23至7-31做题记录&quot;&gt;&lt;a href=&quot;#7-23至7-31做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.23至7.31做题记录&quot;&gt;&lt;/a&gt;7.23至7.31做题记录&lt;/h1&gt;&lt;p&gt;今天开始做HOT100的题目，之前的题目会用JS作为</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="HOT100" scheme="http://yoursite.com/tags/HOT100/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>7.21至7.22做题记录</title>
    <link href="http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/21/7.21%E8%87%B37.22%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-21T02:57:16.000Z</published>
    <updated>2020-07-22T08:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-21至7-22做题记录"><a href="#7-21至7-22做题记录" class="headerlink" title="7.21至7.22做题记录"></a>7.21至7.22做题记录</h1><h3 id="不同的二叉搜索树2"><a href="#不同的二叉搜索树2" class="headerlink" title="不同的二叉搜索树2"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">不同的二叉搜索树2</a></h3><p>与7.15号那个第一题不同在于那题只需要统计不同树的数量，这个是要创建树并全部返回，那个用dp这个用递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        <span class="hljs-keyword">return</span> create(<span class="hljs-number">1</span>,n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        List&lt;TreeNode&gt; alltree = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(start &gt; end) &#123;            alltree.add(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> alltree;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++) &#123;            List&lt;TreeNode&gt; left = create(start,i-<span class="hljs-number">1</span>);            List&lt;TreeNode&gt; right = create(i+<span class="hljs-number">1</span>,end);            <span class="hljs-keyword">for</span>(TreeNode treel:left) &#123;                <span class="hljs-keyword">for</span>(TreeNode treer:right) &#123;                    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);                    root.left = treel;                    root.right = treer;                    alltree.add(root);                &#125;            &#125;        &#125;                <span class="hljs-keyword">return</span> alltree;    &#125;&#125;</code></pre></div><h3 id="求前N项的和"><a href="#求前N项的和" class="headerlink" title="求前N项的和"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求前N项的和</a></h3><p>不让用加减乘除和条件判断，K神说用逻辑运算符的短路效果控制递归的执行与否</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> x = n&gt;<span class="hljs-number">1</span> &amp;&amp; (n+=sumNums(n-<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> n;    &#125;   &#125;</code></pre></div><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h3><p>K神写的位运算太吊了：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">Krahets</a></p><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>因为是搜索树所以通过节点的值判断p和q的位置：在两侧则当前为公共祖先，在同一侧则有当前节点大于二者或小于二者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p.val &gt; q.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root,q,p);        <span class="hljs-keyword">int</span> left=p.val, right=q.val;        <span class="hljs-keyword">return</span> dfs(root,left,right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(root.val&gt;=left &amp;&amp; root.val&lt;=right) <span class="hljs-keyword">return</span> root;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; left) <span class="hljs-keyword">return</span> dfs(root.right,left,right);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dfs(root.left,left,right);    &#125; &#125;</code></pre></div><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>看的K神 :<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">Krahets</a>的答案，太tm吊了，我连简单题都不会做呜呜呜~~</p><p>至此，剑指offer的所有题目都做完了，明天开始做HOT100的题目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-21至7-22做题记录&quot;&gt;&lt;a href=&quot;#7-21至7-22做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.21至7.22做题记录&quot;&gt;&lt;/a&gt;7.21至7.22做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同的二叉搜索树2&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.16至7.20做题记录</title>
    <link href="http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/16/7.16%E8%87%B37.20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-16T06:57:40.000Z</published>
    <updated>2020-07-20T07:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-16至7-20做题记录"><a href="#7-16至7-20做题记录" class="headerlink" title="7.16至7.20做题记录"></a>7.16至7.20做题记录</h1><h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">判断二分图</a></h3><p>看了题解，其实就是遍历图，用染色法在遍历的过程中，将相邻的节点分成不同颜色集合的，如果能分完就返回true，遇到相邻节点但是是一个颜色返回false，DFS\BFS都可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNCOLORED = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RED = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GREEN = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] color;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> valid;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = graph.length;        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        valid = <span class="hljs-keyword">true</span>;        Arrays.fill(color,UNCOLORED);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n &amp;&amp; valid;i++) &#123;            <span class="hljs-keyword">if</span>(color[i] == UNCOLORED)                dfs(i,RED,graph);        &#125;        <span class="hljs-keyword">return</span> valid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> cur_co, <span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        color[cur] = cur_co;        <span class="hljs-keyword">int</span> nei_co = color[cur]==RED?GREEN:RED;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nei:graph[cur]) &#123;            <span class="hljs-keyword">if</span>(color[nei] == UNCOLORED) &#123;                dfs(nei,nei_co,graph);                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[nei] != nei_co) &#123;                valid = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span>;            &#125;            &#125;    &#125;&#125;</code></pre></div><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h3><p>这尼玛居然是简单难度。。。看K神题解用之前的含有min函数的栈那个方法去做，用队列保存一个最大值，这样每次窗口取最大值的时间复杂度就是O(1)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length-k+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) &#123;            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast()&lt;nums[i]) q.removeLast();            q.addLast(nums[i]);        &#125;        res[<span class="hljs-number">0</span>]=q.peekFirst();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=k; j &lt; nums.length; i++,j++) &#123; <span class="hljs-comment">// 形成窗口后</span>            <span class="hljs-keyword">if</span>(q.peekFirst() == nums[i]) q.removeFirst();            <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.peekLast() &lt; nums[j]) q.removeLast();            q.addLast(nums[j]);            res[i+<span class="hljs-number">1</span>] = q.peekFirst();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></h3><p>直接二分不解释</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l&lt;=r) &#123;            <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) r=mid-<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;         &#125;        <span class="hljs-keyword">return</span> l;    &#125;&#125;</code></pre></div><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">队列的最大值</a></h3><p>比较辅助队列和主队列的值是否相等时不能用==,需要用equals，思想和之前栈的那个题一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;        Deque&lt;Integer&gt; q;    Deque&lt;Integer&gt; help_q;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        help_q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> help_q.peekFirst();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        q.addLast(value);        <span class="hljs-keyword">while</span>(!help_q.isEmpty() &amp;&amp; help_q.peekLast()&lt;value) help_q.removeLast();        help_q.addLast(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(q.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(q.peekFirst().equals(help_q.peekFirst())) help_q.removeFirst();        <span class="hljs-keyword">return</span> q.poll();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><span class="hljs-comment"> * int param_1 = obj.max_value();</span><span class="hljs-comment"> * obj.push_back(value);</span><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></h3><p>和室友讨论想到动规，类似机器人找路径的二维矩阵，只能往左或往下走</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s1.length();        <span class="hljs-keyword">int</span> m = s2.length();        <span class="hljs-keyword">if</span>(s3.length() != n+m) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">int</span> p = i+j-<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) dp[j] = dp[j]&amp;&amp;s1.charAt(i-<span class="hljs-number">1</span>)==s3.charAt(p);                <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) dp[j] |= dp[j-<span class="hljs-number">1</span>]&amp;&amp;s2.charAt(j-<span class="hljs-number">1</span>)==s3.charAt(p);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m];    &#125;&#125;</code></pre></div><h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p>这他妈都能动态规划？原来动规不都是从前往后遍历一次的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[][] rec = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>][n+<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span>[] val = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];        val[<span class="hljs-number">0</span>] = val[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) val[i] = nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">2</span>;j&lt;=n+<span class="hljs-number">1</span>;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i+<span class="hljs-number">1</span>;k&lt;j;k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i]*val[k]*val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = Math.max(rec[i][j],sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h3><p>这题居然是简单题。。。最高赞的题解是计算出每种点数出现的次数然后除以总次数，我觉得不如这个老哥直接计算概率</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">double</span> pre[]=&#123;<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">5</span>*i+<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;pre.length;j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">6</span>;x++) &#123;                    tmp[j+x] += pre[j]/<span class="hljs-number">6</span>;                &#125;            &#125;            pre = tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;&#125;</code></pre></div><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/Ef73zZv6wiaXwiJRnCLpoQ" target="_blank" rel="noopener">动态规划初级试炼场</a></p><h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h3><p>最近的简单题是真滴牛批，约瑟夫环倒推就两行，我想不出来。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            ans = (ans + m) % i;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-16至7-20做题记录&quot;&gt;&lt;a href=&quot;#7-16至7-20做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.16至7.20做题记录&quot;&gt;&lt;/a&gt;7.16至7.20做题记录&lt;/h1&gt;&lt;h3 id=&quot;判断二分图&quot;&gt;&lt;a href=&quot;#判断二分</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.11至7.15做题记录</title>
    <link href="http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/15/7.11%E8%87%B37.15%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-15T03:19:57.000Z</published>
    <updated>2020-07-15T03:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-11至7-15做题记录"><a href="#7-11至7-15做题记录" class="headerlink" title="7.11至7.15做题记录"></a>7.11至7.15做题记录</h1><h3 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a></h3><p>不会做。。。</p><h3 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">地下城游戏</a></h3><p>从开始往前走需要同时考虑最低初始健康和过程中的路径和两个值，所以“有两个重要程度相同的参数同时影响后续的决策，这样的动态规划是不满足「无后效性」的”</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dungeon)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=dungeon.length, m=dungeon[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[m-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--) &#123;                dp[j] = Math.max(<span class="hljs-number">1</span>,Math.min(dp[j],dp[j+<span class="hljs-number">1</span>])-dungeon[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><h3 id="两个数组的交集2"><a href="#两个数组的交集2" class="headerlink" title="两个数组的交集2"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集2</a></h3><p>很容易想到用hashmap做，但巧妙在于一定去更短的那个数组放到map里</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;            <span class="hljs-keyword">return</span> intersect(nums2, nums1);        &#125;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums1) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;            map.put(num, count);        &#125;        <span class="hljs-keyword">int</span>[] intersection = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums2) &#123;            <span class="hljs-keyword">int</span> count = map.getOrDefault(num,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) &#123;                intersection[index++] = num;                count--;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) map.put(num, count);                <span class="hljs-keyword">else</span> map.remove(num);            &#125;        &#125;         <span class="hljs-keyword">return</span> Arrays.copyOfRange(intersection, <span class="hljs-number">0</span>, index);    &#125;&#125;</code></pre></div><h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h3><p>笨比才用两数之和的方法做，人家说了是递增排序肯定是有用的，用双指针滑动窗口就可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>(map.containsKey(num)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num,target-num&#125;;            map.put(target-num,num);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><p>没错我就用的两数之和的那个。。。</p><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></h3><p>题不难想到解法，但边界的转移需要注意</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = triangle.size();        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        f[<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i] = f[i-<span class="hljs-number">1</span>]+triangle.get(i).get(i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i-<span class="hljs-number">1</span>;j&gt;<span class="hljs-number">0</span>;j--) f[j] = Math.min(f[j],f[j-<span class="hljs-number">1</span>])+triangle.get(i).get(j);            f[<span class="hljs-number">0</span>] += triangle.get(i).get(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) min = Math.min(min,f[i]);        <span class="hljs-keyword">return</span> min;    &#125;&#125;</code></pre></div><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">和为s的连续正数序列</a></h3><p>和之前那个题一样，但返回的list toarray没搞明白</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, j=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;        List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(i&lt;=target/<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(sum &lt; target) sum += j++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) sum -= i++;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;j;k++) arr[k-i] = k;                res.add(arr);                sum -= i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]); <span class="hljs-comment">// 这里的new int[][]没搞清楚</span>    &#125;&#125;</code></pre></div><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p> <a href="https://baike.baidu.com/item/卡特兰数" target="_blank" rel="noopener">卡特兰数</a> 是真滴牛批，<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/" target="_blank" rel="noopener">灵魂画手</a>的题解写的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) dp[i] += dp[j-<span class="hljs-number">1</span>]*dp[i-j];        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-11至7-15做题记录&quot;&gt;&lt;a href=&quot;#7-11至7-15做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.11至7.15做题记录&quot;&gt;&lt;/a&gt;7.11至7.15做题记录&lt;/h1&gt;&lt;h3 id=&quot;计算右侧小于当前元素的个数&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>7.6至7.10做题记录</title>
    <link href="http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/06/7.6%E8%87%B37.10%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-06T02:14:42.000Z</published>
    <updated>2020-07-10T08:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-6至7-10做题记录"><a href="#7-6至7-10做题记录" class="headerlink" title="7.6至7.10做题记录"></a>7.6至7.10做题记录</h1><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h3><p>题不难但是没想到空间复杂度的优化</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePaths(int m, int n) &#123;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j] + f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 空间复杂度优化</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(cur,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                cur[j] += cur[j-<span class="hljs-number">1</span>] ;            &#125;        &#125;        <span class="hljs-keyword">return</span> cur[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="不同路径2"><a href="#不同路径2" class="headerlink" title="不同路径2"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径2</a></h3><p>和上一个差不多，多了障碍，以后做动规要考虑优化滚动数组</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><span class="hljs-comment">//         if(obstacleGrid[0][0] == 1) return 0;</span><span class="hljs-comment">//         int m=obstacleGrid.length, n=obstacleGrid[0].length;</span><span class="hljs-comment">//         int[][] f = new int[m+1][n+1];</span><span class="hljs-comment">//         f[1][1] = 1;</span><span class="hljs-comment">//         for(int i=1;i&lt;=m;i++) &#123;</span><span class="hljs-comment">//             for(int j=1;j&lt;=n;j++) &#123;</span><span class="hljs-comment">//                 if(i==1 &amp;&amp; j==1) continue;</span><span class="hljs-comment">//                 if(obstacleGrid[i-1][j-1] == 1) continue;</span><span class="hljs-comment">//                 f[i][j] = f[i-1][j]+f[i][j-1];</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return f[m][n];</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 利用滚动数组优化空间复杂度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> m=obstacleGrid.length, n=obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;            <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;            res[i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;                    res[j] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>) res[j] += res[j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> res[n-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h3><p>对各类排序算法的衍生应用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//不一定可以在原数组上更改所以copy一份</span>        <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) copy[i] = nums[i];        <span class="hljs-comment">//传入可以重复使用的辅助空间，这样就不用每次都新开空间了</span>        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">return</span> reversePairs(copy,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,tmp);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> leftPairs = reversePairs(nums,left,mid,tmp);        <span class="hljs-keyword">int</span> rightPairs = reversePairs(nums,mid+<span class="hljs-number">1</span>,right,tmp);        <span class="hljs-keyword">if</span>(nums[mid] &lt;= nums[mid+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> leftPairs + rightPairs;        <span class="hljs-keyword">int</span> mergecount = merge(nums,left,mid,right,tmp);        <span class="hljs-keyword">return</span> leftPairs + rightPairs + mergecount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] tmp)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++) tmp[i] = nums[i];        <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=left;k&lt;=right;k++) &#123;            <span class="hljs-keyword">if</span>(i == mid+<span class="hljs-number">1</span>) nums[k] = tmp[j++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == right+<span class="hljs-number">1</span>) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++];            <span class="hljs-keyword">else</span> &#123;                nums[k] = tmp[j++];                count += mid-i+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></h3><p>题很简单但是感觉自己的代码很干练所以贴一下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span> &amp;&amp; root.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.val == sum;        <span class="hljs-keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);    &#125;&#125;</code></pre></div><h3 id="在排序数组中查找数字1"><a href="#在排序数组中查找数字1" class="headerlink" title="在排序数组中查找数字1"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字1</a></h3><p>我的想法是二分找到tar，再向两边扩散增加res，K神直接两次二分找左右边界：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> mid = right / <span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(nums[mid]!=target &amp;&amp; left&lt;right) &#123;            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;                left = mid+<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;                right = mid-<span class="hljs-number">1</span>;                mid = left+(right-left)/<span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(nums[mid] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;nums.length&amp;&amp;nums[i]==target;i++,res++);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==target;i--,res++);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">0~n-1中缺失的数字</a></h3><p>题不难，但是自己对退出循环的条件以及退出后该返回的值总是不清楚，看K神就分析的很清楚</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == mid) left = mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> right = mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre></div><h3 id="恢复空格"><a href="#恢复空格" class="headerlink" title="恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">恢复空格</a></h3><p>需要手写字典树，要会</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">respace</span><span class="hljs-params">(String[] dictionary, String sentence)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = sentence.length();        Trie root = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span>(String str: dictionary) root.insert(str);        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;            dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;            Trie cur = root;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--) &#123;                <span class="hljs-keyword">int</span> t = sentence.charAt(j-<span class="hljs-number">1</span>)-<span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.next[t].isEnd == <span class="hljs-keyword">true</span>) dp[i]=Math.min(dp[i],dp[j-<span class="hljs-number">1</span>]);                <span class="hljs-comment">//防止retrained这种，re不是词但train是，必须一直往前找最小的才行，除非是0</span>                <span class="hljs-keyword">if</span>(dp[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;                cur = cur.next[t];             &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        <span class="hljs-keyword">public</span> Trie[] next;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEnd;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];            isEnd = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span> </span>&#123;            Trie cur = <span class="hljs-keyword">this</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;                <span class="hljs-keyword">int</span> t=s.charAt(i) - <span class="hljs-string">'a'</span>;                <span class="hljs-keyword">if</span>(cur.next[t] == <span class="hljs-keyword">null</span>) cur.next[t] = <span class="hljs-keyword">new</span> Trie();                cur = cur.next[t];            &#125;            cur.isEnd = <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p>想不出来，动规每天都好几个状态，每天都新计算这些状态，可优化空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = prices.length;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;            f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]-prices[i]);            f[i][<span class="hljs-number">1</span>] = f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i];            f[i][<span class="hljs-number">2</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);        &#125;        <span class="hljs-keyword">return</span> Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],f[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre></div><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">平衡二叉树</a></h3><p>自顶向下写的，时间复杂度NlogN，最差logN层，每层都遍历N数量级的节点。而自底向上可以做到N复杂度，只需要遍历所有节点就可以，后者是K神的做法：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/" target="_blank" rel="noopener">Krahets</a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> Math.abs(depth(root.left)-depth(root.right))&lt;=<span class="hljs-number">1</span>             &amp;&amp; isBalanced(root.left)             &amp;&amp; isBalanced(root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(depth(root.left),depth(root.right));    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数</a></h3><p>位运算找一个很简单，但找两个就很巧妙了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) k ^= num;        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((k&amp;mask) == <span class="hljs-number">0</span>) mask &lt;&lt;= <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums) &#123;            <span class="hljs-keyword">if</span>((mask&amp;num) == <span class="hljs-number">0</span>) a^=num;            <span class="hljs-keyword">else</span> b ^= num;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b&#125;;    &#125;&#125;</code></pre></div><h3 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 II</a></h3><p>不会做，看K神<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">Krahets</a>的也很难看懂，他的one和two代表的是两个数：</p><p>one：0000000000</p><p>two：0100101000</p><p>num：0101000010</p><p>类似这样的两个数，再遍历数组计算每一位的状态，返回的就是要找的数，因为每一位是同时操作的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-6至7-10做题记录&quot;&gt;&lt;a href=&quot;#7-6至7-10做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.6至7.10做题记录&quot;&gt;&lt;/a&gt;7.6至7.10做题记录&lt;/h1&gt;&lt;h3 id=&quot;不同路径&quot;&gt;&lt;a href=&quot;#不同路径&quot; cla</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>JS力扣练习</title>
    <link href="http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/04/JS%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0/</id>
    <published>2020-07-04T07:35:24.000Z</published>
    <updated>2020-07-05T03:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS力扣练习"><a href="#JS力扣练习" class="headerlink" title="JS力扣练习"></a>JS力扣练习</h1><p>这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java</p><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p>这个题目真的很浪漫，错的人迟早会走散，而对的人迟早会相逢。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;    <span class="hljs-keyword">var</span> n1=headA;    <span class="hljs-keyword">var</span> n2=headB;    <span class="hljs-keyword">while</span>(n1!=n2) &#123;        <span class="hljs-keyword">if</span>(n1==<span class="hljs-literal">null</span>) n1=headB;        <span class="hljs-keyword">else</span> n1=n1.next;        <span class="hljs-keyword">if</span>(n2==<span class="hljs-literal">null</span>) n2=headA;        <span class="hljs-keyword">else</span> n2=n2.next;    &#125;    <span class="hljs-keyword">return</span> n1;&#125;;</code></pre></div><h3 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间节点</a></h3><p>思考利用链表节点之间的距离变化来解决</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> fast = head, slow = head;    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>) &#123;        fast = fast.next.next;        slow = slow.next;    &#125;    <span class="hljs-keyword">return</span> slow;&#125;;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS力扣练习&quot;&gt;&lt;a href=&quot;#JS力扣练习&quot; class=&quot;headerlink&quot; title=&quot;JS力扣练习&quot;&gt;&lt;/a&gt;JS力扣练习&lt;/h1&gt;&lt;p&gt;这边记录力扣上用JS做的一些题目，用以练习JS，常规刷题还是在用java&lt;/p&gt;
&lt;h3 id=&quot;相交链表&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>7.1至7.5做题记录</title>
    <link href="http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/07/01/7.1%E8%87%B37.5%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-01T02:45:23.000Z</published>
    <updated>2020-07-06T02:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-1至7-5做题记录"><a href="#7-1至7-5做题记录" class="headerlink" title="7.1至7.5做题记录"></a>7.1至7.5做题记录</h1><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组</a></h3><p>其实想到是用动规去做了，但是状态定义和状态转移都没想到，遇到动规可以尝试从后往前推</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length][B.length];        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.length;i++)            f[i][<span class="hljs-number">0</span>] = A[i]==B[<span class="hljs-number">0</span>]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;A.length;j++)            f[<span class="hljs-number">0</span>][j] = A[<span class="hljs-number">0</span>]==B[j]?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;A.length;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;B.length;j++) &#123;                f[i][j] = A[i]==B[j]?f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;                max = Math.max(max,f[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h3><p>我不会做我是笨蛋，看大佬的题解吧：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">Krahets</a></p><h3 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h3><p>呵呵，我会做个吊毛，高中时可能还能做出来吧，看大佬的：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">Krahets</a></p><h3 id="有序矩阵中第K小的元素"><a href="#有序矩阵中第K小的元素" class="headerlink" title="有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">有序矩阵中第K小的元素</a></h3><p>有序矩阵要找好起始点，按条件找移动方式</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=matrix.length;        <span class="hljs-keyword">int</span> left = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> right = matrix[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span>(left&lt;right) &#123;             <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(check(matrix,mid,k,n)) right=mid;            <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n) &#123;            <span class="hljs-keyword">if</span>(matrix[i][j] &lt;= mid) &#123;                num += i+<span class="hljs-number">1</span>;                j++;            &#125;            <span class="hljs-keyword">else</span>                i--;        &#125;        <span class="hljs-keyword">return</span> num&gt;=k;    &#125;&#125;</code></pre></div><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h3><p>发现自己手写快排很不熟练，每次都要看很久。。</p><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></h3><p>二叉搜索树的中序遍历就是一个有序数组，从中间分开递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> help(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        root.left = help(nums,left,mid-<span class="hljs-number">1</span>);        root.right = help(nums,mid+<span class="hljs-number">1</span>,right);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre></div><h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h3><p>二维矩阵呗</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m=grid.length, n=grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;</code></pre></div><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h3><p>自己只用了map，没想到更优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// class Solution &#123;</span><span class="hljs-comment">//     public int lengthOfLongestSubstring(String s) &#123;</span><span class="hljs-comment">//         HashMap&lt;Integer,Character&gt; map = new HashMap();</span><span class="hljs-comment">//         int max = Integer.MIN_VALUE;</span><span class="hljs-comment">//         int j = 0;</span><span class="hljs-comment">//         for(int i=0;i&lt;s.length();i++) &#123;</span><span class="hljs-comment">//             char cur = s.charAt(i);</span><span class="hljs-comment">//             if(map.containsValue(cur)) &#123;</span><span class="hljs-comment">//                 max = Math.max(max,map.size());</span><span class="hljs-comment">//                 for(;map.get(j)!=cur;j++) map.remove(j);</span><span class="hljs-comment">//                 map.remove(j++);</span><span class="hljs-comment">//                 map.put(i,cur);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//             else map.put(i,cur);</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         max = Math.max(max,map.size());</span><span class="hljs-comment">//         return max;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">int</span> j = map.getOrDefault(s.charAt(i), -<span class="hljs-number">1</span>);            map.put(s.charAt(i),i);            tmp = tmp&lt;i-j?tmp+<span class="hljs-number">1</span>:i-j;            res = Math.max(res,tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></h3><p>东子哥说的动规没想出来，用栈也做错了。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        stack.push(-<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'('</span>) stack.push(i);            <span class="hljs-keyword">else</span> &#123;                stack.pop();                <span class="hljs-keyword">if</span>(stack.isEmpty()) stack.push(i);                <span class="hljs-keyword">else</span> max = Math.max(max,i-stack.peek());            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h3><p>想象因数分解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;            dp[i] = Math.min(Math.min(n2, n3), n5);            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h3><p>和之前的正则表达式匹配几乎一模一样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=s.length(), m=p.length();        <span class="hljs-keyword">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) f[i][j] = i==<span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">'*'</span>) &#123;                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">1</span>)==s.charAt(i-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">'?'</span>))                            f[i][j] = f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) f[i][j] = f[i][j-<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span>) f[i][j] |= f[i-<span class="hljs-number">1</span>][j];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-1至7-5做题记录&quot;&gt;&lt;a href=&quot;#7-1至7-5做题记录&quot; class=&quot;headerlink&quot; title=&quot;7.1至7.5做题记录&quot;&gt;&lt;/a&gt;7.1至7.5做题记录&lt;/h1&gt;&lt;h3 id=&quot;最长重复子数组&quot;&gt;&lt;a href=&quot;#最长重复子数组&quot; c</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>6.25至6.30做题记录</title>
    <link href="http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/30/6.25%E8%87%B36.30%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-30T12:26:40.000Z</published>
    <updated>2020-07-02T03:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-25至6-30做题记录"><a href="#6-25至6-30做题记录" class="headerlink" title="6.25至6.30做题记录"></a>6.25至6.30做题记录</h1><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p>未排序的数组中找元素，不需要把整个数组实现排序，又快排找位置的思想最快，堆排序也可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">return</span> quicksort(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>, nums.length-k);        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> q = randompartition(a,l,r);        <span class="hljs-keyword">if</span>(q == index) <span class="hljs-keyword">return</span> a[q];        <span class="hljs-keyword">return</span> q&gt;index?quicksort(a,l,q-<span class="hljs-number">1</span>,index):quicksort(a,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(a,i,r);        <span class="hljs-keyword">return</span> partition(a,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(a[j] &lt;= a[r])                swap(a,j,++i);        &#125;        swap(a,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=a[i];        a[i]=a[j];        a[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的K个数</a></h3><p>这一题和上一题几乎一样，注意找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN) 的排序，用快排就可以解决topK问题</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Random random = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">if</span>(arr.length==<span class="hljs-number">0</span> || k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> quicksort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] quicksort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index) &#123;        <span class="hljs-keyword">int</span> q = randompartition(arr,l,r);        <span class="hljs-keyword">if</span>(q==index) <span class="hljs-keyword">return</span> Arrays.copyOf(arr, q + <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> q&gt;index?quicksort(arr,l,q-<span class="hljs-number">1</span>,index):quicksort(arr,q+<span class="hljs-number">1</span>,r,index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randompartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;        swap(arr,i,r);        <span class="hljs-keyword">return</span> partition(arr,l,r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=l-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[r])                swap(arr,j,++i);        &#125;        swap(arr,i+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> tmp=arr[i];        arr[i]=arr[j];        arr[j]=tmp;    &#125;&#125;</code></pre></div><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h3><p>一开始是用队列做的，其实不需要这么麻烦，用双指针可以节省空间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (end &lt; n) &#123;            sum += nums[end];            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;                ans = Math.min(ans, end - start + <span class="hljs-number">1</span>);                sum -= nums[start];                start++;            &#125;            end++;        &#125;        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;    &#125;&#125;</code></pre></div><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h3><p>自己用链表实现的，每次插入时插到合适的位置，找中位数时遍历去找，看了大佬的代码发现其实用堆做是最优解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> odd = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span>&#123;        <span class="hljs-keyword">int</span> val;        node next;        node(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;    &#125;    node head;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        head=<span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        len++;        odd=!odd;        node n = <span class="hljs-keyword">new</span> node(num);        n.next=<span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) head = n;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(num&lt;head.val) &#123;                n.next=head;                head=n;                <span class="hljs-keyword">return</span> ;            &#125;            node cur=head;            <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-keyword">null</span> &amp;&amp; cur.next.val&lt;num) cur=cur.next;            n.next=cur.next;            cur.next=n;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(odd) &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> cur.val;        &#125;        <span class="hljs-keyword">else</span> &#123;            node cur=head;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len/<span class="hljs-number">2</span>;i++) cur=cur.next;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(cur.val+cur.next.val)/<span class="hljs-number">2</span>;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><span class="hljs-comment"> * obj.addNum(num);</span><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><span class="hljs-comment"> */</span><span class="hljs-comment">// class MedianFinder &#123;</span><span class="hljs-comment">//     Queue&lt;Integer&gt; A, B;</span><span class="hljs-comment">//     public MedianFinder() &#123;</span><span class="hljs-comment">//         A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半</span><span class="hljs-comment">//         B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public void addNum(int num) &#123;</span><span class="hljs-comment">//         if(A.size() != B.size()) &#123;</span><span class="hljs-comment">//             A.add(num);</span><span class="hljs-comment">//             B.add(A.poll());</span><span class="hljs-comment">//         &#125; else &#123;</span><span class="hljs-comment">//             B.add(num);</span><span class="hljs-comment">//             A.add(B.poll());</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     public double findMedian() &#123;</span><span class="hljs-comment">//         return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span></code></pre></div><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h3><p>O(n)解决</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max=nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> pre=nums[<span class="hljs-number">0</span>], cur=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++) &#123;            cur=nums[i]&gt;nums[i]+pre?nums[i]:nums[i]+pre;            max=Math.max(cur,max);            pre=cur;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p>这题是真蒙的，居然和题解一样。。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)            res[i] = res[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> r=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nums.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;            res[i] = res[i]*r;            r=r*nums[i];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h3><p>和之前K神写的一个状态转换的题很像，都是一样的递归，一样的剪枝。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();    <span class="hljs-keyword">char</span>[] c;    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;        c=s.toCharArray();        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == c.length - <span class="hljs-number">1</span>) &#123;            res.add(String.valueOf(c)); <span class="hljs-comment">// 添加排列方案</span>            <span class="hljs-keyword">return</span>;        &#125;        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;c.length;i++) &#123;            <span class="hljs-keyword">if</span>(set.contains(c[i])) <span class="hljs-keyword">continue</span>;            set.add(c[i]);            swap(i,x);            dfs(x+<span class="hljs-number">1</span>);            swap(i,x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">char</span> tmp = c[a];        c[a] = c[b];        c[b] = tmp;    &#125;&#125;</code></pre></div><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></h3><p>题目要求时间复杂度O(n)，并且使用常数级别空间，这种要求很刁钻的题目，就要让原有的nums数组承担比原本负责记录数据更多的内容，也就是它的下标也要赋予含义，用来记录某种状态</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                <span class="hljs-comment">// 满足在指定范围内、并且没有放在正确的位置上，才交换</span>                <span class="hljs-comment">// 例如：数值 3 应该放在索引 2 的位置上</span>                swap(nums, nums[i] - <span class="hljs-number">1</span>, i);            &#125;        &#125;        <span class="hljs-comment">// [1, -1, 3, 4]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 都正确则返回数组长度 + 1</span>        <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    &#125;&#125;</code></pre></div><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h3><p><strong>摩尔投票法：</strong> 核心理念为 <strong>“正负抵消”</strong> ；时间和空间复杂度分别为 O(N)和 O(1)；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> votes=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;            <span class="hljs-keyword">if</span>(votes==<span class="hljs-number">0</span>) x=num;            votes += x==num?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-25至6-30做题记录&quot;&gt;&lt;a href=&quot;#6-25至6-30做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.25至6.30做题记录&quot;&gt;&lt;/a&gt;6.25至6.30做题记录&lt;/h1&gt;&lt;h3 id=&quot;数组中的第K个最大元素&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>JS中的变量类型与强制转换</title>
    <link href="http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-06-30T12:18:08.000Z</published>
    <updated>2020-06-30T14:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS中的变量类型与强制转换"><a href="#JS中的变量类型与强制转换" class="headerlink" title="JS中的变量类型与强制转换"></a>JS中的变量类型与强制转换</h1><p>JS中一共有六种数据类型：</p><p>String 字符串    Number 数值    Boolean 布尔值    Null 空值    Undefined 未定义    Object 对象</p><p>其中，前五个都属于基本数据类型，而Object属于引用数据类型。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"abc"</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//string</span>a = <span class="hljs-string">"这是一个双引号 \""</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个换行符 \n"</span>;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">"这是一个制表符 \t"</span>;<span class="hljs-built_in">console</span>.log(a);</code></pre></div><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span> * <span class="hljs-string">"def"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN Not a Number</span>a = <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//NaN也是number类型</span>a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0.30000000000000004 JS中浮点类型并不精确</span>a = <span class="hljs-built_in">Number</span>.MAX_VALUE+<span class="hljs-built_in">Number</span>.MAX_VALUE;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//Infinity表示超过了number的最大表示范围</span>a = <span class="hljs-literal">Infinity</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);  <span class="hljs-comment">//Infinity也是number类型</span></code></pre></div><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>布尔值只有true和false两个值。</p><h3 id="Null和Undefined类型"><a href="#Null和Undefined类型" class="headerlink" title="Null和Undefined类型"></a>Null和Undefined类型</h3><p>null专门用来表示一个空的对象，所以它的类型不是Null。undefined只用来表示声明的未定义的变量。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//Object</span><span class="hljs-keyword">var</span> b;<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//Undefined</span></code></pre></div><h3 id="强制转换为String类型"><a href="#强制转换为String类型" class="headerlink" title="强制转换为String类型"></a>强制转换为String类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//调用被转数据类型的toString()方法，但不会改变原数据的类型，注意Null和Undefined是没有toString()方法的</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-keyword">var</span> b = a.toString(); <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;b = a.toString(); <span class="hljs-comment">//无效</span>a = <span class="hljs-literal">undefined</span>;b = a.toString(); <span class="hljs-comment">//无效</span><span class="hljs-comment">//调用String()函数,将转换变量作为参数传入，对于Number和Boolean实际还是调用toString()，但对null和undefined可以转为字符串</span>a = <span class="hljs-number">123</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//null</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span>a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">String</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span></code></pre></div><h3 id="强制转换为Number类型"><a href="#强制转换为Number类型" class="headerlink" title="强制转换为Number类型"></a>强制转换为Number类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用Number()函数</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"abc"</span>; <span class="hljs-comment">//abc不能转换为数字</span>a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-string">"  "</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//如果字符串是空串或者全是空格就会转为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = <span class="hljs-literal">true</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值真为1</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//1</span>a = <span class="hljs-literal">false</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//布尔值假为0</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//0</span>a = <span class="hljs-literal">null</span>;a = <span class="hljs-built_in">Number</span>(a); <span class="hljs-comment">//null转为数字就是0</span><span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-literal">undefined</span>;a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined只能转为NaN</span><span class="hljs-comment">// 专门负责字符串的转换:parseInt()--字符串转整数 parseFloat()字符串转浮点数</span>a = <span class="hljs-string">"123xp"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123 parseInt()将字符串中有效的数字部分取出转为int</span>a = <span class="hljs-string">"123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123</span>a = <span class="hljs-string">"gg123def567"</span>;a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN</span><span class="hljs-comment">//对于非string类型的变量如a=true，会先转为字符串“true”，再作为参数，所以返回是NaN</span></code></pre></div><h3 id="强制转换为布尔类型"><a href="#强制转换为布尔类型" class="headerlink" title="强制转换为布尔类型"></a>强制转换为布尔类型</h3><p>对于数字转布尔，除了0和NaN为false，其它值都是true。</p><p>对于字符串转布尔，除了空串为false，其余都是true，包括空格串。</p><p>Null转布尔是false。</p><p>Undefined转布尔是false。</p><h3 id="使用算术运算符转换数据类型"><a href="#使用算术运算符转换数据类型" class="headerlink" title="使用算术运算符转换数据类型"></a>使用算术运算符转换数据类型</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 对非Number类型的数据运算（加法对字符串有特殊）时，会将其先转为Number再运算，所以对直接a-0可以转number</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"123"</span> - <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = +<span class="hljs-string">"123"</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number 正负号直接将数据转为Number</span>a = <span class="hljs-number">1</span> + <span class="hljs-literal">true</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span>a = a + <span class="hljs-literal">NaN</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//NaN 任何值与NaN运算都是NaN</span><span class="hljs-comment">// 两个字符串相加不是Number，而是拼接字符串，注意只有加法！！</span>a = <span class="hljs-string">"123"</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 123456</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//string</span><span class="hljs-comment">// 任何值与字符串相加都是先转为字符串，然后拼串</span>a = <span class="hljs-number">123</span> + <span class="hljs-string">"456"</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//123456</span><span class="hljs-comment">// 所以对数据直接加一个“”空串可以转为字符串</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;a href=&quot;#JS中的变量类型与强制转换&quot; class=&quot;headerlink&quot; title=&quot;JS中的变量类型与强制转换&quot;&gt;&lt;/a&gt;JS中的变量类型与强制转换&lt;/h1&gt;&lt;p&gt;JS中一共有六种数据类型：&lt;/p&gt;
&lt;p&gt;Strin</summary>
      
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>6.15至6.24做题记录</title>
    <link href="http://yoursite.com/2020/06/24/6.15%E8%87%B36.24%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/24/6.15%E8%87%B36.24%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-24T07:26:40.000Z</published>
    <updated>2020-06-24T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-15至6-24做题记录"><a href="#6-15至6-24做题记录" class="headerlink" title="6.15至6.24做题记录"></a>6.15至6.24做题记录</h1><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h3><p>二叉树的递归问题最重要的就是分析好递归的终止条件，题解中recur函数判断以A为根节点的树是否包含B树，也就是说如果A，B节点值不等则只有可能是A的左子树或右子树包含B，如果节点值相等就继续向下判断——A的左子树包含B的左子树，A右包含B右，直到B为空。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-keyword">return</span> (A!=<span class="hljs-keyword">null</span> &amp;&amp; B!=<span class="hljs-keyword">null</span> &amp;&amp; (judge(A,B) || isSubStructure(A.left,B) ||                 isSubStructure(A.right,B)));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode a, TreeNode b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(b==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(a==<span class="hljs-keyword">null</span> || a.val!=b.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> judge(a.left,b.left) &amp;&amp; judge(a.right,b.right);    &#125;&#125;</code></pre></div><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h3><p>这道题的题解是用辅助栈，数据栈存要求的数据，辅助栈存最小值，只有比栈顶小时才入栈(等于时也要入栈，因为出栈判断是只要值相等就出栈)，我的思路是自己建立链表节点，节点中用pre_min记录在它之前的有最小值的节点是哪个，如果他自己最小就指向他自己，这样出栈后只要查找当前栈顶的pre_min指向就可以了</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack_node</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        stack_node pre;        stack_node next;        stack_node pre_min;        stack_node(<span class="hljs-keyword">int</span> x) &#123;val=x;&#125;    &#125;    <span class="hljs-keyword">int</span> min=Integer.MAX_VALUE;    stack_node bottom;    stack_node cur;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        bottom = <span class="hljs-keyword">new</span> stack_node(Integer.MAX_VALUE);        cur=bottom;        cur.pre_min=cur;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        stack_node push = <span class="hljs-keyword">new</span> stack_node(x);        push.pre=cur;        cur.next=push;        <span class="hljs-keyword">if</span>(x&lt;min) &#123;            min = x;            push.pre_min=push;        &#125;        <span class="hljs-keyword">else</span>            push.pre_min=cur.pre_min;        cur=push;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        cur=cur.pre;        min=cur.pre_min.val;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cur.val;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.min();</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化和反序列化</a></h3><p>题目要求是“不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。”这道题的序列化不难，最好选择先序遍历这样重构树的时候比较方便，递归遍历树然后把值一个个加到string里，注意空节点的录入以及节点之间的分割。</p><p>反序列化时用刚才的分割字符转为string数组，再转为list，将list作为参数传入递归，每次用掉一个节点就remove一个节点，然后将list传入递归左子树，然后是右子树。当list的首位给的值代表null就说明这个小子树构建完了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-comment">// Encodes a tree to a single string.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">my_serialize</span><span class="hljs-params">(TreeNode root, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> str+=<span class="hljs-string">"None,"</span>;        str+=String.valueOf(root.val)+<span class="hljs-string">","</span>;        str=my_serialize(root.left,str);        str=my_serialize(root.right,str);        <span class="hljs-keyword">return</span> str;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> my_serialize(root,<span class="hljs-string">""</span>);    &#125;    <span class="hljs-comment">// Decodes your encoded data to tree.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">my_deserialize</span><span class="hljs-params">(List&lt;String&gt; data_list)</span> </span>&#123;        <span class="hljs-keyword">if</span>(data_list.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">"None"</span>)) &#123;            data_list.remove(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        TreeNode root=<span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(data_list.get(<span class="hljs-number">0</span>)));        data_list.remove(<span class="hljs-number">0</span>);        root.left=my_deserialize(data_list);        root.right=my_deserialize(data_list);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        String[] sp_data=data.split(<span class="hljs-string">","</span>);        List&lt;String&gt; data_list=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(sp_data));        <span class="hljs-keyword">return</span> my_deserialize(data_list);    &#125;&#125;<span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><span class="hljs-comment">// Codec codec = new Codec();</span><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span></code></pre></div><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h3><p>直接建栈模拟就行，遇到错就返回false，这居然是中等题…..</p><h3 id="最佳观光组合"><a href="#最佳观光组合" class="headerlink" title="最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">最佳观光组合</a></h3><p>一道动规题，遍历一次，记录每个点和它之前的某个点的评分最大值，仔细观察可发现，若i与j组合最大，到j的下一个点k时，要么k与j组合更大，要么k与i组合更大，不可能是k之前的其他元素了，因为如果有m能使k与m的组合更大的话，那么j当初也应该与m组合而不是与i组合，其实光看计算公式就是这个道理：A[i]+i+A[j]-j，对点j来说，A[j]-j是固定值，只要找到j之前的一个i使A[i]+i最大就行，而这样的i找到了就是固定的不会变</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur,pre=A[<span class="hljs-number">0</span>],max=A[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;A.length;i++) &#123;            cur=Math.max(A[i]+A[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>,A[i]+pre-A[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(cur&gt;max) max=cur;            pre=cur;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h3 id="从上到下打印二叉树3"><a href="#从上到下打印二叉树3" class="headerlink" title="从上到下打印二叉树3"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树3</a></h3><p>与这个系列的前两题不同在于要“之”字输出，也就是要考虑层数</p><p>我的代码复杂再居然又建了一个栈，其实一个队列就可以，因为java里那个队列是双端队列正反插都可以</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) queue.add(root);        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;                TreeNode node = queue.poll();                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 -&gt; 队列头部</span>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 -&gt; 队列尾部</span>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="从先序遍历还原二叉树"><a href="#从先序遍历还原二叉树" class="headerlink" title="从先序遍历还原二叉树"></a><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/" target="_blank" rel="noopener">从先序遍历还原二叉树</a></h3><p>题解用栈保存要回溯的状态，参数是一个字符串，作为S之后出现的T字符，它要么是S的左子树的根节点，要么就是S的某个祖先的右子树的根节点，这要看T前有几个“-”来判断，定义“-”的个数是level，则当level与栈的大小+1相等时就表明T就是S的左子树，否则栈内元素不停出栈直到满足条件，每次新建节点最后都入栈。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">recoverFromPreorder</span><span class="hljs-params">(String S)</span> </span>&#123;        Deque&lt;TreeNode&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (pos &lt; S.length()) &#123;            <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (S.charAt(pos) == <span class="hljs-string">'-'</span>) &#123;                ++level;                ++pos;            &#125;            <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (pos &lt; S.length() &amp;&amp; Character.isDigit(S.charAt(pos))) &#123;                value = value * <span class="hljs-number">10</span> + (S.charAt(pos) - <span class="hljs-string">'0'</span>);                ++pos;            &#125;            TreeNode node = <span class="hljs-keyword">new</span> TreeNode(value);            <span class="hljs-keyword">if</span> (level == path.size()) &#123;                <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;                    path.peek().left = node;                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">while</span> (level != path.size()) &#123;                    path.pop();                &#125;                path.peek().right = node;            &#125;            path.push(node);        &#125;        <span class="hljs-keyword">while</span> (path.size() &gt; <span class="hljs-number">1</span>) &#123;            path.pop();        &#125;        <span class="hljs-keyword">return</span> path.peek();    &#125;&#125;</code></pre></div><h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h3><p>后序遍历，所以数组末尾是根节点，作为分割点，从前往后找属于左子树和右子树的部分，看是否满足规则，把分好的索引放入递归处理</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;        <span class="hljs-keyword">return</span> recur(postorder,<span class="hljs-number">0</span>,postorder.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> split=i;        <span class="hljs-keyword">while</span>(postorder[split]&lt;postorder[j]) split++;        <span class="hljs-keyword">int</span> max=split;        <span class="hljs-keyword">while</span>(postorder[max]&gt;postorder[j]) max++;        <span class="hljs-keyword">return</span> max==j &amp;&amp; recur(postorder,i,split-<span class="hljs-number">1</span>) &amp;&amp; recur(postorder,split,max-<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h3><p>递归判断，用一个栈保存已经走过的路径，如果路不通将栈顶remove，如示例中的树，传入参数可以是左子树，tar为22-5=17，和右子树，tar也是17，找到当前节点无左右子树且等于tar，加入path，并将path拷贝一份到res中，继续递归</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;        recur(root, sum);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        path.add(root.val);        tar -= root.val;        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            res.add(<span class="hljs-keyword">new</span> LinkedList(path));        recur(root.left, tar);        recur(root.right, tar);        path.removeLast();    &#125;&#125;</code></pre></div><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></h3><p>这题我做的太复杂了，递归很多导致时间复杂度高，实际上当遇到计算自己子树的值为负数时，直接将这个子树的值设为0就可以</p><p>我的代码里recurMaxEdge找到当前节点能连接的最大的一条边，recurMaxRoot找到通过当前节点路径的最大值，最后findmax递归遍历</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> max=Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        findmax(root);        <span class="hljs-keyword">return</span> max;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recurMaxEdge</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> Math.max(root.val,(root.val+Math.max(recurMaxEdge(root.left),recurMaxEdge(root.right))));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recurMaxRoot</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> a=root.val,b=recurMaxEdge(root.left),c=recurMaxEdge(root.right);        <span class="hljs-keyword">return</span> Math.max(a,Math.max(Math.max(a+b,a+c),a+b+c));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findmax</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> cur=recurMaxRoot(root);        <span class="hljs-keyword">if</span>(max&lt;cur) max=cur;        findmax(root.left);        findmax(root.right);    &#125;&#125;</code></pre></div><p>复杂的原因就是不确定一个节点加上它左子树节点给它的那个“最大值”是正是负，所以加了很多没用的判断和递归，实际上对每个节点提供最大值计算时如果结果是负数，那它就是0，因为没人会加上负数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> maxSum = Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        maxGain(root);        <span class="hljs-keyword">return</span> maxSum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;                <span class="hljs-comment">// 递归计算左右子节点的最大贡献值</span>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span>        <span class="hljs-keyword">int</span> leftGain = Math.max(maxGain(node.left), <span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> rightGain = Math.max(maxGain(node.right), <span class="hljs-number">0</span>);        <span class="hljs-comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span>        <span class="hljs-keyword">int</span> priceNewpath = node.val + leftGain + rightGain;        <span class="hljs-comment">// 更新答案</span>        maxSum = Math.max(maxSum, priceNewpath);        <span class="hljs-comment">// 返回节点的最大贡献值</span>        <span class="hljs-keyword">return</span> node.val + Math.max(leftGain, rightGain);    &#125;&#125;</code></pre></div><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>这题很秀，用hashmap做可以，也可以直接复制！！深拷贝和浅拷贝的区别就是这个</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    Node next;</span><span class="hljs-comment">    Node random;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int val) &#123;</span><span class="hljs-comment">        this.val = val;</span><span class="hljs-comment">        this.next = null;</span><span class="hljs-comment">        this.random = null;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;        HashMap&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//创建HashMap集合</span>        Node cur=head;        <span class="hljs-comment">//复制结点值</span>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//存储put:&lt;key,value1&gt;</span>            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val)); <span class="hljs-comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span>            cur=cur.next;        &#125;        <span class="hljs-comment">//复制结点指向</span>        cur = head;        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//得到get:&lt;key&gt;.value2,3</span>            map.get(cur).next = map.get(cur.next); <span class="hljs-comment">//新结点next指向同旧结点的next指向</span>            map.get(cur).random = map.get(cur.random); <span class="hljs-comment">//新结点random指向同旧结点的random指向</span>            cur = cur.next;        &#125;        <span class="hljs-comment">//返回复制的链表</span>        <span class="hljs-keyword">return</span> map.get(head);    &#125;&#125;</code></pre></div><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h3><p>和三数之和一个思路</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,cur=Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> left=i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right=nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(left&lt;right) &#123;                <span class="hljs-keyword">int</span> sum=nums[i]+nums[left]+nums[right];                <span class="hljs-comment">// while(left&lt;right &amp;&amp; nums[left]==nums[left+1]) left++;</span>                <span class="hljs-comment">// while(left&lt;right &amp;&amp; nums[right]==nums[right-1]) right--; </span>                <span class="hljs-keyword">if</span>(cur&gt;Math.abs(sum-target)) &#123;                    cur=Math.abs(sum-target);                    res=sum;                &#125;                <span class="hljs-keyword">if</span>(sum &lt; target) left++;                <span class="hljs-keyword">if</span>(sum &gt; target) right--;                <span class="hljs-keyword">if</span>(sum == target) <span class="hljs-keyword">return</span> res;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h3><p>二叉搜索树的中序遍历是递增排列！所以根据这个建立链表</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">    public int val;</span><span class="hljs-comment">    public Node left;</span><span class="hljs-comment">    public Node right;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        left = _left;</span><span class="hljs-comment">        right = _right;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Node head,pre;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        dfs(root);        head.left=pre;        pre.right=head;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(cur.left);        <span class="hljs-keyword">if</span>(pre==<span class="hljs-keyword">null</span>) head=cur;        <span class="hljs-keyword">else</span> pre.right=cur;        cur.left=pre;        pre=cur;        dfs(cur.right);     &#125;&#125;</code></pre></div><p>最近因为考试，很久都没有记录题目，晚上总结一下前端CSS的一些内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-15至6-24做题记录&quot;&gt;&lt;a href=&quot;#6-15至6-24做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.15至6.24做题记录&quot;&gt;&lt;/a&gt;6.15至6.24做题记录&lt;/h1&gt;&lt;h3 id=&quot;树的子结构&quot;&gt;&lt;a href=&quot;#树的子结</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
    <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>6.10至6.14做题记录</title>
    <link href="http://yoursite.com/2020/06/14/6.10%E8%87%B36.14%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/14/6.10%E8%87%B36.14%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-14T08:15:43.000Z</published>
    <updated>2020-06-14T13:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-10至6-14做题记录"><a href="#6-10至6-14做题记录" class="headerlink" title="6.10至6.14做题记录"></a>6.10至6.14做题记录</h1><h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h3><p>当n不大时当然很好做，如果n非常大需要使用string来表示大数</p><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h3><p>做了这个题才意识到自己有多笨比</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] out=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;Integer&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;T.length;i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i]&gt;T[stack.peek()]) &#123;                out[stack.peek()]=i-stack.peek();                stack.pop();            &#125;            stack.push(i);        &#125;        <span class="hljs-keyword">return</span> out;    &#125;&#125;</code></pre></div><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h3><p>这其实应该和第一题两数之和是一个系列的，两数之和很好做，遍历一次就能得到输出。但这个还不允许输出重复的三元组，而且像这种数组题，遇事不决可先排序。排序之后先固定一个数，那么剩余的两个数分布左右，此时可以根据三数之和与要求的sum之间的差判断分布左右的两个数的移动方式(没错就是因为现在是排好序的数组！！)</p><p>而且在移动过程中完成去除重复的操作，因为固定两个数字后第三个数怎么也不会变，所以直接略过这组数字即可。</p><p>看的题解写的，就不贴自己的代码了，害！<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">灵魂画手</a></p><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">表示数值的字符串</a></h3><p>只怪自己编译原理没好好学！但其实测试用例给的很奇怪，这题.1也算数字的，”   .2e23   “这种也算….</p><h3 id="转变数组后最接近目标值的数组和"><a href="#转变数组后最接近目标值的数组和" class="headerlink" title="转变数组后最接近目标值的数组和"></a><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">转变数组后最接近目标值的数组和</a></h3><p>遇事不决就先排序！这题官解给的是二分，感觉更好一些，当数组长度很长时时间复杂度会比较低，下面代码思路是先排个序，然后从第一个元素开始累加，每次累加后计算目标值减去累加和，除以剩下数字个数得到的平均值avg，等到遇到数字大于他那波计算出的avg，说明此时从他开始往后的数字都可以按规则变成avg，返回avg即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        Arrays.sort(arr);        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> avg=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;            avg=(target-sum)/(arr.length-i);            <span class="hljs-keyword">if</span>(arr[i]&gt;=avg) &#123;                <span class="hljs-keyword">double</span> avgd=(<span class="hljs-keyword">double</span>)(target-sum)/(arr.length-i);                <span class="hljs-keyword">if</span>(avgd-avg&gt;<span class="hljs-number">0.5</span>)                    <span class="hljs-keyword">return</span> avg+<span class="hljs-number">1</span>;                <span class="hljs-keyword">return</span> avg;            &#125;            sum+=arr[i];        &#125;        <span class="hljs-keyword">return</span> arr[arr.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><p>官解的意思是排序之后，对于可能可以作为输入的每个value，二分查找这个value的下标，计算和，比较。</p><p>或者是排序后，将value的上下两个边界值也作为二分条件，找mid。</p><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h3><p>目前除了6.6-6.9中出现过的单词接龙以外最难的hard题目，想暴力基本不可能。</p><p><strong><em>做了这个题有两点感悟：这也要动态规划，这也能动态规划？！</em></strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">int</span> n=s.length();        <span class="hljs-keyword">int</span> m=p.length();        <span class="hljs-keyword">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++) &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) &#123;                    f[i][j]= i==<span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>)!=<span class="hljs-string">'*'</span>) &#123;                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">'.'</span>))                            f[i][j]=f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">2</span>)                            f[i][j] |= f[i][j-<span class="hljs-number">2</span>];                        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>)==<span class="hljs-string">'.'</span>))                            f[i][j] |= f[i-<span class="hljs-number">1</span>][j];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[n][m];    &#125;&#125;</code></pre></div><p>还做了一些链表的题，很明显手生了，但都是简单题目，所以不打算全部放在博客上了，这边只记录一些有价值有思考的题目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-10至6-14做题记录&quot;&gt;&lt;a href=&quot;#6-10至6-14做题记录&quot; class=&quot;headerlink&quot; title=&quot;6.10至6.14做题记录&quot;&gt;&lt;/a&gt;6.10至6.14做题记录&lt;/h1&gt;&lt;h3 id=&quot;打印从1到最大的n位数&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="每日一题" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
