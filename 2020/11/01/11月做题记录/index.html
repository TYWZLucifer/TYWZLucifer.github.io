<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fishicon.png">
  <link rel="icon" type="image/png" href="/img/fishicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="pluto">
  <meta name="keywords" content="">
  <title>11月做题记录 - pluto</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="pluto" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>52Hz的小七不二</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/fishback.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-11-01 12:45">
      November 1, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      46
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：November 18, 2020 am
                
              </p>
            
            <article class="markdown-body">
              <h1 id="11月做题记录"><a href="#11月做题记录" class="headerlink" title="11月做题记录"></a>11月做题记录</h1><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p>dp搜索每一个nums[i]之前的项，赋给其能给的最大值，所以优化时间复杂度可以使用二分</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">// var lengthOfLIS = function(nums) &#123;</span>
<span class="hljs-comment">//     dp = [1];</span>
<span class="hljs-comment">//     for(var i=1;dp[i]=1,i&lt;nums.length;i++) &#123;</span>
<span class="hljs-comment">//         for(var j=0;j&lt;i;j++) &#123;</span>
<span class="hljs-comment">//             nums[i]&gt;nums[j] &amp;&amp; (dp[i]=Math.max(dp[j]+1,dp[i]));</span>
<span class="hljs-comment">//         &#125;</span>
<span class="hljs-comment">//     &#125;</span>
<span class="hljs-comment">//     return nums.length&lt;2?nums.length:Math.max(...dp);</span>
<span class="hljs-comment">// &#125;;</span>

<span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
    <span class="hljs-keyword">let</span> n = nums.length;
    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;
        <span class="hljs-keyword">if</span>(nums[i]&gt;tail[end]) &#123;
            end++;
            tail[end] = nums[i];
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> right = end;
            <span class="hljs-keyword">while</span>(left&lt;right) &#123;
                <span class="hljs-keyword">let</span> mid = left + <span class="hljs-built_in">parseInt</span>((right-left)/<span class="hljs-number">2</span>);
                <span class="hljs-keyword">if</span>(tail[mid] &lt; nums[i]) left = mid+<span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> right = mid;
            &#125;
            tail[left] = nums[i];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;
&#125;</code></pre></div>



<h3 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p>要求找到环形入口，并且空间复杂度为O(1)，所以不能用hashset，用快慢指针，由于F=2S，F=S+nb <code>F比S多走了N个b环的距离，并且走的距离是S的两倍</code>，S=nb，相遇时慢指针一定走过n个环的距离，每次慢指针走到环入口一定是a+nb，所以S接下来到入口的距离就是a，此时把F放置在head，二者同时移动，相遇时就是入口</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
    <span class="hljs-keyword">var</span> slow = head;
    <span class="hljs-keyword">var</span> fast = head;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123; 
        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span> || fast.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        slow = slow.next;
        fast = fast.next.next;
        <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;
    &#125;
    fast = head;
    <span class="hljs-keyword">while</span>(slow != fast) &#123;
        slow = slow.next;
        fast = fast.next;
    &#125;
    <span class="hljs-keyword">return</span> slow;
&#125;;</code></pre></div>



<h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p>从左往右依次遍历heighs，如果递增则说明此时较高的bar还有增长空间，如果遇到比前一个矮的bar，则说明之前的bar已经到达极限可以开始计算，之前的bar无论是否是等高的都可以回推左边界，因为每回推一次都更新最大面积，如果不等高则宽为1，如果等高最左边的高bar会提供最大的宽度，这样算出来的最大面积就是有效的，JS使用栈真的好方便。。</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>&#123;
    <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> stack = [];
    heights = [<span class="hljs-number">0</span>,...heights,<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;heights.length;i++) &#123;
        <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stack[stack.length<span class="hljs-number">-1</span>]]) &#123;
            <span class="hljs-keyword">let</span> stackTopIndex = stack.pop();
            maxArea = <span class="hljs-built_in">Math</span>.max(maxArea,heights[stackTopIndex]*(i-stack[stack.length<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>));
        &#125;
        stack.push(i);
    &#125;
    <span class="hljs-keyword">return</span> maxArea;
&#125;;</code></pre></div>

<p>其中用到JS中的<a href="https://www.cnblogs.com/wangyunhui/p/7511615.html" target="_blank" rel="noopener">扩展运算符</a></p>
<h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p>ES5和ES6的类定义方法不一样，ES5中用函数的形式，ES6可以想Java一样用class定义，使用内置对象Map，其中keys方法返回一个包含插入的键值顺序的Iterator，越晚插入的排越后面</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;
    <span class="hljs-keyword">constructor</span>(capacity) &#123;
        <span class="hljs-keyword">this</span>.capacity = capacity;
        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    &#125;

    <span class="hljs-keyword">get</span>(key) &#123;
        <span class="hljs-keyword">let</span> val = <span class="hljs-keyword">this</span>.map.get(key);
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(val) === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">this</span>.map.delete(key);
        <span class="hljs-keyword">this</span>.map.set(key,val);
        <span class="hljs-keyword">return</span> val;
    &#125;

    put(key,value) &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.map.has(key)) <span class="hljs-keyword">this</span>.map.delete(key);
        <span class="hljs-keyword">this</span>.map.set(key,value);
        <span class="hljs-keyword">let</span> keys = <span class="hljs-keyword">this</span>.map.keys();
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.map.size&gt;<span class="hljs-keyword">this</span>.capacity) <span class="hljs-keyword">this</span>.map.delete(keys.next().value);
    &#125;
&#125;</code></pre></div>



<h3 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><p>搜索词语和搜索前缀只有判定isEnd不同</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Initialize your data structure here.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;
    <span class="hljs-keyword">constructor</span>() &#123;
        <span class="hljs-keyword">this</span>.next = &#123;&#125;;
        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-literal">false</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;
    <span class="hljs-keyword">constructor</span>() &#123;
        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> TrieNode();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * Inserts a word into the trie. </span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span>
<span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span>
<span class="hljs-comment">    */</span>
    insert(word) &#123;
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;
            <span class="hljs-keyword">if</span>(!node.next[word[i]]) node.next[word[i]] = <span class="hljs-keyword">new</span> TrieNode();
            node = node.next[word[i]];
        &#125;
        node.isEnd = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * Returns if the word is in the trie. </span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span>
<span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span>
<span class="hljs-comment">    */</span>
    search(word) &#123;
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(word);
        <span class="hljs-keyword">return</span> node!=<span class="hljs-literal">null</span> &amp;&amp; node.isEnd;
    &#125;

    searchPrefix(word) &#123;
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;word.length;i++) &#123;
            <span class="hljs-keyword">if</span>(node.next[word[i]]) node = node.next[word[i]];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        &#125;
        <span class="hljs-keyword">return</span> node;
    &#125;
    
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * Returns if there is any word in the trie that starts with the given prefix. </span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">prefix</span></span></span>
<span class="hljs-comment">    * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span>
<span class="hljs-comment">    */</span> 
    startsWith(prefix) &#123;
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.searchPrefix(prefix);
        <span class="hljs-keyword">return</span> node !=<span class="hljs-literal">null</span>;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span>
<span class="hljs-comment"> * var obj = new Trie()</span>
<span class="hljs-comment"> * obj.insert(word)</span>
<span class="hljs-comment"> * var param_2 = obj.search(word)</span>
<span class="hljs-comment"> * var param_3 = obj.startsWith(prefix)</span>
<span class="hljs-comment"> */</span></code></pre></div>



<h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">汉明距离</a></h3><p>布赖恩·克尼根算法，x异或x-1可以消除最右侧的1</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;
    <span class="hljs-keyword">var</span> xor = x ^ y;
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(xor) &#123;
        res++;
        xor &amp;= xor<span class="hljs-number">-1</span>;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre></div>



<h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p>类似环形链表找入口，因为有重复数，所以必定存在环，按索引找下一个节点<code>i=nums[i]</code></p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span> &#123;
        slow = nums[slow];
        fast = nums[nums[fast]];
    &#125;<span class="hljs-keyword">while</span>(slow != fast)
    slow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(slow != fast) &#123;
        slow = nums[slow];
        fast = nums[fast];
    &#125;
    <span class="hljs-keyword">return</span> slow;
&#125;;</code></pre></div>



<h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h3><p>自己的做法是将数组中的元素与下标一一对应，如果有数字没有在它“正确”的位置上就说明这个位置缺少数字，但这样做时间复杂度貌似不符合要求。。</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> findDisappearedNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;
        <span class="hljs-keyword">while</span>(nums[i]!=i+<span class="hljs-number">1</span> &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>]!=nums[i]) swap(nums,i); 
    &#125;
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;nums.length;i++) &#123;
        <span class="hljs-keyword">if</span>(nums[i] != i+<span class="hljs-number">1</span>) res[j++]=i+<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums,i</span>) </span>&#123;
    <span class="hljs-keyword">let</span> tmp = nums[nums[i]<span class="hljs-number">-1</span>];
    nums[nums[i]<span class="hljs-number">-1</span>] = nums[i];
    nums[i] = tmp; 
&#125;</code></pre></div>

<p>官方解答是遍历原数组，将<code>nums[nums[i]-1]</code>*-1，如果已经是负数则不需要再×-1，遍历完成后只有缺失数字的下标处对应的数组值是正值。</p>
<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p>解答做法是用滑动窗口，因为不需要与匹配字符串完全相同，所以用HashMap统计每个字符出现的次数，与匹配符相同就可以了，但是录入时就需要注意控制窗口的大小与匹配符一样大才行</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">p</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> needs=&#123;&#125;,windows=&#123;&#125;;
    <span class="hljs-keyword">let</span> match=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;p.length;i++) &#123;
        needs[p[i]]?needs[p[i]]++:needs[p[i]]=<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">let</span> needsLen = <span class="hljs-built_in">Object</span>.keys(needs).length;
    <span class="hljs-keyword">while</span>(right &lt; s.length) &#123;
        <span class="hljs-keyword">let</span> c1 = s[right];
        <span class="hljs-keyword">if</span>(needs[c1]) &#123;
            windows[c1]?windows[c1]++:windows[c1]=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(windows[c1] == needs[c1]) match++;
        &#125;
        right++;
        <span class="hljs-keyword">while</span>(match == needsLen) &#123;
            <span class="hljs-keyword">if</span>(right-left == p.length) res.push(left);
            <span class="hljs-keyword">let</span> c2 = s[left];
            <span class="hljs-keyword">if</span>(needs[c2]) &#123;
                <span class="hljs-keyword">if</span>(--windows[c2] &lt; needs[c2]) match--;
            &#125;
            left++;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre></div>



<h3 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p>这是并查集做法，也可以把关系看成图的边，求解就是找图中两点是否存在路径，可以用DFS，BFS</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> calcEquation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">equations, values, queries</span>) </span>&#123;
    <span class="hljs-keyword">let</span> parentMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">let</span> valueMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; equations.length; i++) &#123;
        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;
            parentMap.set(equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">0</span>]);
        &#125;
        <span class="hljs-keyword">if</span> (!parentMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;
            parentMap.set(equations[i][<span class="hljs-number">1</span>], equations[i][<span class="hljs-number">1</span>]);
        &#125;

        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">0</span>])) &#123;
            valueMap.set(equations[i][<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-keyword">if</span> (!valueMap.has(equations[i][<span class="hljs-number">1</span>])) &#123;
            valueMap.set(equations[i][<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);
        &#125;
        union(parentMap, valueMap, equations[i][<span class="hljs-number">0</span>], equations[i][<span class="hljs-number">1</span>], values[i]);
    &#125;

    <span class="hljs-keyword">const</span> result = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;
        <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, queries[i][<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, queries[i][<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span> (!tmp1 || !tmp2) &#123;
            result.push(<span class="hljs-number">-1.0</span>);
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-keyword">if</span> (tmp1.index === tmp2.index) &#123;
            result.push(tmp1.value / tmp2.value);
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            result.push(<span class="hljs-number">-1.0</span>);
        &#125;     
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">parentMap, valueMap, index1, index2, value</span>) </span>&#123;
    <span class="hljs-keyword">let</span> tmp1 = find(parentMap, valueMap, index1);
    <span class="hljs-keyword">let</span> tmp2 = find(parentMap, valueMap, index2);
    parentMap.set(tmp1.index, tmp2.index);
    valueMap.set(tmp1.index, (value * tmp2.value) / tmp1.value);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">parentMap, valueMap, index</span>) </span>&#123;
    <span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (parentMap.get(index) &amp;&amp; parentMap.get(index) !== index) &#123;
        value *= valueMap.get(index);
        index = parentMap.get(index);
    &#125;
    <span class="hljs-keyword">if</span> (!parentMap.get(index)) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    &#125;
    <span class="hljs-keyword">return</span> &#123;
        index,
        value
    &#125;;
&#125;</code></pre></div>



<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p>自己写的这个递归太多所以效率很差，可以用内部函数使用res全局变量</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * function TreeNode(val) &#123;</span>
<span class="hljs-comment"> *     this.val = val;</span>
<span class="hljs-comment"> *     this.left = this.right = null;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">return</span> calmax(root);
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caldistance</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> lefthigh=<span class="hljs-number">0</span>,rigthhigh=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(root.left !== <span class="hljs-literal">null</span>) lefthigh = calhigh(root.left);
    <span class="hljs-keyword">if</span>(root.right !== <span class="hljs-literal">null</span>) rigthhigh = calhigh(root.right);
    <span class="hljs-keyword">return</span> lefthigh+rigthhigh;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calhigh</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(calhigh(root.left),calhigh(root.right))+<span class="hljs-number">1</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calmax</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(caldistance(root),calmax(root.left),calmax(root.right));
&#125;</code></pre></div>

<p>其中res作为全局变量进入每一轮的递归中，效率更高</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depth</span>(<span class="hljs-params">node</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> L = depth(node.left);
        <span class="hljs-keyword">let</span> R = depth(node.right);
        res = <span class="hljs-built_in">Math</span>.max(res,L+R);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(L,R)+<span class="hljs-number">1</span>;
    &#125;
    depth(root);
    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre></div>



<h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p>JS在返回{}这种元组的时候不是按照下标0，1，2索引的，而是传递的变量名作为key来索引</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> decodeString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
    <span class="hljs-keyword">return</span> dfs(s,<span class="hljs-number">0</span>);
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">s,i</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(i &lt; s.length) &#123;
        <span class="hljs-keyword">if</span>(s.charAt(i)&gt;=<span class="hljs-string">'0'</span> &amp;&amp; s.charAt(i)&lt;=<span class="hljs-string">'9'</span>) num = num*<span class="hljs-number">10</span> + <span class="hljs-built_in">Number</span>.parseInt(s.charAt(i));
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'['</span>) &#123;
            <span class="hljs-keyword">let</span> tmp = dfs(s,i+<span class="hljs-number">1</span>);
            i = tmp[<span class="hljs-string">'i'</span>];
            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>) &#123;
                res = res + tmp[<span class="hljs-string">'res'</span>];
                num--;
            &#125;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">']'</span>) <span class="hljs-keyword">return</span> &#123;i,res&#125;;
        <span class="hljs-keyword">else</span> res += s.charAt(i);
        i++;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>



<h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特位计数</a></h3><p>对于奇数，只是最后一位比它前面的偶数多了一个1，而对于偶数，除以二不会影响1的个数，只是让末尾少了一个0</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> countBits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = [];
    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++) &#123;
        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[i] = res[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> res[i] = res[i/<span class="hljs-number">2</span>];
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre></div>



<h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h3><p>其实就是遍历顺序换一下，全局变量替换传参数确实方便很多</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> convertBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        dfs(root.right);
        root.val += pre;
        pre = root.val;
        dfs(root.left);
    &#125;
    dfs(root);
    <span class="hljs-keyword">return</span> root;
&#125;;</code></pre></div>



<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h3><p>就是想不到怎么才能控制递归中对数组访问的位置</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;
    <span class="hljs-keyword">let</span> n = preorder.length;
    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) map.set(inorder[i],i);
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span>(<span class="hljs-params">preorder,inorder,preorder_left,preorder_right,inorder_left,inorder_right</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(preorder_left &gt; preorder_right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> preorder_root = preorder_left;
        <span class="hljs-keyword">let</span> inorder_root = map.get(preorder[preorder_root]);
        <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(preorder[preorder_root]);
        <span class="hljs-keyword">let</span> size_left = inorder_root-inorder_left;
        root.left = build(preorder,inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+size_left,inorder_left,inorder_root<span class="hljs-number">-1</span>);
        root.right = build(preorder,inorder,preorder_left+size_left+<span class="hljs-number">1</span>,preorder_right,inorder_root+<span class="hljs-number">1</span>,inorder_right);
        <span class="hljs-keyword">return</span> root;
    &#125;

    <span class="hljs-keyword">return</span> build(preorder,inorder,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);
&#125;;</code></pre></div>



<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p>自底向上计算，应用之前用过的最优解，自顶向下也可以，但需要记录已经计算的值，不然会有很多重复的子结构重复计算</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> coinChange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coins, amount</span>) </span>&#123;
    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(amount+<span class="hljs-number">1</span>);
    dp.fill(amount+<span class="hljs-number">1</span>);
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;=amount;i++) &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;coins.length;j++) &#123;
            <span class="hljs-keyword">if</span>(i &gt;= coins[j]) dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i],dp[i-coins[j]]+<span class="hljs-number">1</span>);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dp[amount]&gt;amount?<span class="hljs-number">-1</span>:dp[amount];
&#125;;</code></pre></div>



<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></h3><p>要求是根据层级将结果分开，所以要记录每一层的节点个数</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">let</span> q = [];
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;
    q.push(root);
    <span class="hljs-keyword">while</span>(q.length != <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">let</span> num = q.length;
        res[l] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;
            <span class="hljs-keyword">let</span> node = q.shift();
            res[l].push(node.val);
            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) q.push(node.left);
            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) q.push(node.right);
        &#125;
        l++;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre></div>

<p>可以说剑指offer和HOT100总算是刷过一遍了，打算之后主要复习旧题，做做每日一题就可以，然后就是熟悉下牛客网站的做题。</p>
<p>这里之后放的一般是每日一题和用JS做的复习题</p>
<h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h3><p>数学证明，如果X无法到达Y，则对于X与Y之间的任意Z，都到达不了Y</p>
<div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gas, cost</span>) </span>&#123;
    <span class="hljs-keyword">let</span> n = gas.length;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(i &lt; n) &#123;
        <span class="hljs-keyword">let</span> sumGas=<span class="hljs-number">0</span>, sumCost=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> cnt=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(cnt&lt;n) &#123;
            <span class="hljs-keyword">const</span> j = (i+cnt)%n;
            sumGas+=gas[j];
            sumCost+=cost[j];
            <span class="hljs-keyword">if</span>(sumCost &gt; sumGas) <span class="hljs-keyword">break</span>;
            cnt++;
        &#125;
        <span class="hljs-keyword">if</span>(cnt === n) <span class="hljs-keyword">return</span> i;
        <span class="hljs-keyword">else</span> i = i+cnt+<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
&#125;;</code></pre></div>


            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Algorithm/">Algorithm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/leetcode/">leetcode</a>
                    
                      <a class="hover-with-bg" href="/tags/HOT100/">HOT100</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/12/14/12%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">12月做题记录</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/01/9%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">
                        <span class="hidden-mobile">9月做题记录</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "11月做题记录&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  














</body>
</html>
